---
title: 模板与泛型
date: 2022-02-11 22:01:25
tags:
---
## 函数模板

模板定义以关键词`template`开始，后跟一个**模板参数列表**，由若干个用逗号分隔的**模板参数**组成。编译器会推断模板参数的类型，为不同的类型实例化出不同的版本。

**类型参数**前必须使用关键词`class`或`typename`。在模板参数列表中这两者等价，`typename`更加贴切模板参数的含义（并且不暗示类型必须是类），是在`class`之后引入的。

模板中还可以定义**非类型参数**，表示一个特定类型的参数，因此模板中应该用类型名而非`typename`。这些值必须是**常量表达式**，因为在编译阶段就需要被替换，来源为用户指定或编译器推断。

```C++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){
  return strcmp(p1, p2);
}
compare("hi", "mom");
```

在调用时，编译器会使用**字面值常量**的大小来代替N和M。	

在**模板参数列表**后可以加`inline`或`constexpr`。

从上述例子中可以看到2个编写泛型代码的重要原则：

- 模板中的函数参数是`const`引用：这样可以同时支持允许拷贝和不允许拷贝的版本，而且避免拷贝可以减少浪费。
- 函数体中的判断条件仅使用`<`运算：因为模板是**类型无关的**，只对参数的所支持的操作由要求。这一点比较接近Python的鸭子类型或者Go的接口设计，他们想传达的想法都是用类的行为来区分类型，而不是类的名字和继承结构。限制模板使用的运算类型，是为了让该模板支持更多的类型。==模板程序应该尽量减少对实参类型的要求。==

#### 模板编译

在调用函数时，编译器只需要知道函数的声明；使用类类型的对象时，类定义是可用的，但是函数成员的定义可以不用。因此，我们将类定义和函数声明放在**头文件**，普通函数和类成员函数的定义放在**源文件**。

但是模板不同，编译器需要掌握函数模板或类模板成员函数的定义，才能生成一个实例化版本。因此模板的头文件中通常既包括声明也包括定义。

编译器可能会在模板编译的三个阶段报错：

- 编译模板本身：只能检查语法错误，如忘记分号、变量名拼错
- 编译器遇到模板使用：对于函数模板调用，可以检查实参类型是否正确，参数类型是否匹配；对于类模板，检查模板实参的数量。总之查错有限。
- 模板实例化：直到该阶段才能发现类型相关的错误。

由于模板是类型无关的，因此编译器会检查实参是否支持模板要求的操作，但是这些都只能等实例化后才能发现。

## 类模板

与函数模板不同，编译器不能为类模板推断模板参数类型。需要用户在模板名后的尖括号中提供额外信息，也就是**显式模板实参**，他们会被绑定到模板参数。类似于使用容器时指定的元素类型。

默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化。

在类模板的作用域内，可以省略模板类型，`A&`等同于`A<T>&`，因为在该作用域内编译器可以自动替换。可以直接使用模板名`T`而不必指定实参。
如果是在类模板之外，则一定要提供模板实参，才能进入对应模板的作用域。

### 友元

类模板可以和另一个类模板，普通类，模板实参成为友元。可以和特定类型的类模板做友元，或者类模板的任何实例为友元。

### 模板类型别名

给定了模板实参的类模板会被实例化为一个类，可以用`typedef`来指定别名，但是`typedef`无法为模板创建别名。需要使用`using`。

```C++
template <typename T> using twin = pair<T, T>
```

接下来，`twin<T>`就等同于`pair<T,T>`。

在使用模板类型别名时，可以固定某些模板参数

```C++
template <typename T> using partNo = pair<T, unsigned>
```

### 类模板的static成员

对于每一个T来说，模板都会生成一个不同的类。类模板的每个static成员必须**有且仅有**一个定义，但是类模板的每个实例（对于每个T）都有一个独有的static成员。在访问时，必须指定它所在的域。

## 模板参数

模板参数会覆盖外层的同名变量，并且不允许重用（重新定义），也不允许在同一个模板参数列表中重复出现。

和函数声明类似，模板声明不在乎模板参数的名字，只在乎数量和种类（类型或非类型）。

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。

模板参数可以有默认值，如果全都使用默认值，使用模板时也需要加上空的尖括号。

### 类的类型成员

对于一个类而言，使用作用域运算符`::`可以访问其static成员和类型成员，因为编译器知道该类的明确定义，知道访问的是一个数据成员还是类型。但是对于模板而言，如果遇到`T::size_type *p`的代码，编译器不知道是用T类型中的size_type类型定义一个指针，还是说用T中的size_type成员与p相乘。

因此，默认情况下C++假定通过`::`访问的是名字而不是类型。如果是类型，需要用`typename`显式指定，而且必须是`typename`而不能是`class`。`typename T::value_type`可以获取类型。

## 成员模板

一个类可以包含函数模板，这样的成员称为**成员模板**。不能是虚函数。

对于模板类的成员模板，需要给定模板类的模板参数，成员模板的参数通过参数类型推断。

## 模板实参推断

将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有`const`转换和数组或函数到指针的转换。如果参数类型不是模板参数，则实参可以进行正常的类型转换。

对于函数模板而言，一般不需要用尖括号，因为可以通过实参类型来推断模板参数。但是有时我们需要用模板参数指定返回值类型，这时就无从推断了，需要提供**显式模板实参**，调用这样的函数需要尖括号。

有时返回值类型只能在运行时决定，比如一个模板函数传入一个容器的迭代器，返回容器内的元素的类型，只能在运行时通过`decltype`得知类型，那么就在返回值类型处先写`auto`。

```C++
template <typename T>
auto f(T a) -> decltype(*p){  
  return *p;
}
```

### 函数指针和实参推断

用函数模板初始化一个函数指针，或者为函数指针赋值时，编译器用指针的类型来推断模板实参。

```C++
template <typename T> int compare(const T&, const T&);
// pf1指向实例int compare(const int&, const int&)
int (*pf1)(const int&, const int&) = compare;
```

如果一些重载函数可以接收同个函数模板的不同实例，那么传入模板时需要用尖括号指定模板实参，否则编译器无法推断。

### 引用折叠和右值引用参数

将一个左值（例如`int i`）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如`T&&`）时，编译器推断模板类型参数为实参的**左值引用类型**。

中间跳过一大段解释

如果一个函数参数是指向模板参数类型的右值引用（如`T&&`），则可以传递给它任意类型的实参。如果将一个左值传递进去，则函数参数被实例化为一个普通的左值引用（`T&`）。

![image-20211230194339414](/Users/jackzhu/Library/Application Support/typora-user-images/image-20211230194339414.png)

16.2.5 非常难

### 转发

16.2.7跳过

关于`std::forward`，用来保持实参的细节。

## 重载与模板

## 可变参数模板

出现在模板参数内的叫**模板参数包**，函数参数内的叫**函数参数包**。用`...`来表示

```C++
template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);
```

用`sizeof`运算符可以知道参数数量，`sizeof...(Args)`。

与`initializer_list`只能接收相同类型的参数不同，可变参数可以接收不同类型的参数。

可变参数函数通常是递归的，每次递归处理一个参数，然后用剩余实参调用自身。为了能终止递归，还需要定义一个非可变参数的版本。
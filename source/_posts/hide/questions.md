---
ktitle: questions
date: 2022-08-09 00:23:38
tags: 
hide: true
---


本人在校期间学习认真刻苦，成绩优异，积极参与校内外活动和比赛，能够顺利和同学合作完成软件项目，并在过程中发挥带头作用。

本人热爱游戏行业，从孩童时期就接触过游戏，并对游戏行业产生浓厚兴趣。进入大学后，学习计算机方面的知识，希望能在游戏的服务端方向有所作为。


• 工作描述：参与部门项目的开发工作，撰写技术文档，掌握问题排查、bug 修复、开发环境部署流程。 
• 成果描述：学习项目所需的 Spring 技术栈、跨模块调用和服务器部署等技能；参与智能视频分析平 台解决方案项目，完成管理平台部分模块的开发任务，修复若干错误。
• 个人收获：学习 Spring 开发技术栈，熟悉项目开发流程，积累真实开发经验。

智能视频分析平台

• 应用技术：SpringMVC，SpringBoot，MySQL，Redis，ZooKeeper，Kafka，SeaweedFS
• 项目描述：搭建稳定可靠的基础服务“底座”为核心并提供可视化的系统管理工具用于摄像头管理、服务器管理、服务管理等基础管理子系统，在此基础上搭建以寻人为核心能力的视频智能分析系统。
• 主要工作：完成用户管理、协议接入与适配、应用管理等模块开发，撰写技术文档和接口文档，通过查询日志定位并修复错误。


二手房信息平台

• 应用技术：Python，Vue，Flask，SQLite，ECharts，XGBoost，Nginx，Docker
• 项目描述：毕业设计项目，开发二手房信息平台的前后端分离项目，包含功能有登录注册，用户上传房源，房价预测，房源展示和推荐，数据分析展示。
• 主要工作：编写 Python 爬虫程序爬取房源信息，使用 Vue+ElementUI 完成前端开发，使用高德地图API 开发前端地图插件，使用 Flask 完成后端开发，通过 docker 完成云服务器环境搭建和部署。

## 开放性问题

### 自我介绍

面试官您好，非常感谢能给我这次面试机会（很感谢您这么晚还抽空面试）。我叫XXX，本科就读于北京工业大学，研究生就读于香港科技大学，目前正在每日互动股份有限公司做Java开发的实习工作。

我过往的经历主要可以分为两部分。第一部分是我的在校经历，我在校期间成绩优秀，本科获得了北工大优秀毕业生和都柏林大学的一等学位。同时我在课余时间也会给自己充电，比如参加竞赛，阅读专业书籍等，也自学了多门语言。第二部分是我的实习经历，我在实习阶段主要学习了Spring相关的技术栈，以及积累了宝贵的真实项目开发经验。

Hello, thank you very much for giving me this opportunity. My name is XXX. I studied in Beijing University of technology as an undergraduate and in Hong Kong University of science and technology as a postgraduate. I am currently doing an internship in java development in Getui.

My past experience can be divided into two parts. The first part is my school experience. During my school years, I achieved excellent results. I obtained the outstanding graduate of Beijing University of technology and the first-class degree of Dublin University. At the same time, I will also enrich myself in my spare time, such as participating in competitions, reading professional books, etc. I have also learned many programming languages. The second part is my internship experience. In the internship stage, I mainly learned the spring framework and related technologies and accumulated real  experience in project development.

### 项目中遇到的问题

没遇到难点就诚实的说暂时没遇到什么深刻的难点，然后可以转移话题到做过什么**优化**。

新需求，过期删除，看英文文档，写demo；手写定时任务；不能直接删除；delete limit，但是末尾怎么办；提前获取要删除的数量，count顺序扫描很快，后台任务不加索引


- 过期删除
- SDK适配
- DBSCAN
- nginx+lua, openresty

### 学到最多东西的案例/最有成就感

初期目标设定：
中期遇到困难：
后期如何解决：
结束如何反思：

难者不会，会着不难，解决一个个问题的过程，和从中形成的方法论。


### 最大的优点

### 最大的缺点

团队管理能力



### 职业发展规划

### 兴趣爱好



## 计网

### TPC/IP五层模型

- 应用层：HTTP，SMTP，DNS，FTP
- 运输层：TCP，UDP
- 网络层：ICMP、IGMP、IP（IPv4、IPv6）、ARP、RARP
- 数据链路层：两个节点传输数据时，链路层将网络层交下来的数据报组装成帧，在链路上传送帧。每一帧都包括数据和控制信息（同步信息、地址信息、差错控制等）。 
- 物理层

### 三次握手四次挥手

![img](https://pics5.baidu.com/feed/838ba61ea8d3fd1fe5bf7195341a001794ca5f43.jpeg?token=a1ba6bb03045f8d2263c817d71219b2f&s=3B96ED0683E8450B16F27E790200D07F)

![img](https://pics6.baidu.com/feed/908fa0ec08fa513d3380aa7a393970f3b3fbd9cc.jpeg?token=6dfd67a4a0927fca26d5e7a1abae7f4a&s=7AAE3462315B41CE48D554CA0000E0B1)

![img](https://pics7.baidu.com/feed/8435e5dde71190ef08c7447eca4fb81efdfa602b.jpeg?token=74e81457ce3c2f49b48814839e548194&s=5EA83C6229C6E0CA5A7454CA0000E0B1)

### TCP实现可靠传输

TCP是通过序列号、检验和、确认应答信号、重发机制、连接管理、窗口控制、流量控制、拥塞控制一起保证TCP传输的可靠性的。

- 序列号：TCP给发送的每一个包都进行编号，接收方对数据包进行排序，把有序数据传送给应用层，TCP的接收端会**丢弃重复的数据**。
-  检验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。 
- 确认应答：如果收到的数据报报文段的检验和没有差错，就确认收到，如果有差错，TCP就丢弃这个报文段和不确认收到此报文段。 
- 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
-  **拥塞控制**：当网络拥塞时，减少数据的发送。 慢开始、拥塞避免、快重传、快恢复。
- 停止等待协议：它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 
- 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### UDP实现可靠传输

- RDT1.0：建立在理想可靠信道上，发送和接收方都只有等待调用状态
- RDT2.0：考虑了翻转错误，发送方增加了等待ACK或NAK状态。
- RDT2.1：考虑了ACK或NAK出错出错的情况。简单重传会导致重复分组，因此引入序列号，发送方給每个分组增加序列号，接收方丢弃重复分组。序列号目前可以只为0或1，说明每次只发送一个包。
- RDT2.2：取消NAK，在ACK中显式加入被确认分组的序列号，这样重复的ACK即代表NAK。
- RDT3.0：考虑了丢失分组，因此加入超时重传。如果ACK只是延迟了也无妨，因为接收端收到了重复的分组会自动丢弃。收到重复ack会忽略，因为包可能还在路上，所以只用管计时器。

### TIME_WAIT

四次挥手时，主动断连的一方发送最后一个ACK后会进入TIME_WAIT，会等待2MSL（最大报文生存期）才会回到CLOSED。这么做是确保另一方收到这个消息。万一这条消息丢失了，需要花1个MSL的时间，被关闭方会重发FIN，又要1个MSL来接收。

### GET和POST区别

- 语义不同：GET获取数据，POST提交数据
- 幂等性：GET有幂等性，每次GET的效果相同。POST没有
- 长度限制：浏览器一般对GET有长度限制，2048字节。POST无
- 参数位置：GET参数在URL中，由？开头，& 连接。POST参数在请求体中，URL上不可见。
- 编码：GET只能url编码，POST可以多种编码

### 粘包

TCP基于字节流，无法判断发送方报文段边界。

多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。

 解决粘包的方法： 

1. 发送方关闭Nagle算法，使用TCP_NODELAY选项关闭Nagle功能 
2. 发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界 
3. 数据包末尾加上特殊标记
4. 数据包头部加上数据包的长度。数据包头部定长4字节，可以存储数据包的整体长度 
5. 应用层自定义规则

### URL到内容显示过程

- 查浏览器缓存，看看有没有已经缓存好的，如果没有检查本机host文件，再没有就调用API，Linux下Socket函数 gethostbyname

- 向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议

- 如果在一个子网内采用ARP地址解析协议进行ARP查询。如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址

- 这时已有服务器IP，http默认是80 https是 443 端口号，会首先尝试http然后调用Socket建立TCP连接。

- 经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，

- 如果不是http协议，服务器会返回一个5开头的的重定向消息，告知使用https，也就是IP没变，只是端口变成443了，四次挥手断连

- 重新对443端口三次握手，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，

- 这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。

- 确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染


### HTTP状态码

| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| ---- | ---------------------------------------------- |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

200成功；301永久移动；302临时移动；304未修改，使用缓存；400语法错误，服务端无法解析；401未身份验证；403拒绝访问；404找不到资源；405请求方法不对；500服务器内部错误

### HTTPS

与HTTP区别：

- 默认端口号不同：HTTP是80，HTTPS是443
- 安全性：HTTP明文，HTTPS密文
- 协议：TCP；TLS，TLS基于TCP
- HTTP只需要进行TCP连接；HTTPS建立TCP连接后还需要建立TLS连接

建立连接过程：

1. 客户端发送一个**https**的请求到服务端
2. 服务端申请配置好数字证书，包含公钥和私钥
3. 服务端将证书传送给客户端，证书中包含了很多信息，比如证书的颁发机构，过期时间，网址，公钥等
4. 客户端解析证书，由客户端的TLS完成，首先会验证公钥是否有效，比如颁发机构，过期时间等。

### HTTP2.0

- 二进制格式（Binary Format）：HTTP1.x的解析是基于文本，存在天然缺陷。HTTP2.0的协议解析采用二进制格式，实现方便且健壮。

- 多路复用（MultiPlexing）：连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面。
- 头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小。
- 服务端推送（server push）：如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回。

## OS

### Linux常用命令

常用：cd, ls, ll, grep, cp, mv, rm, ps, kill, pwd

查看文件：more, less, cat

查看系统资源：top：查看操作系统的信息，如进程、CPU占用率、内存信息等（实时)； free：查看内存使用情况

### 死锁

必要条件：

- 互斥：资源是独占的，排他性使用
- 请求保持：进程在已经持有资源的情况下请求新资源，并且在阻塞期间不会释放已经获得的资源
- 不可抢占：进程已获得的资源不会被抢占，只能自己释放
- 循环等待：形成资源请求链

如何防止死锁：

- 预防：破坏四种必要条件。比如破坏循环等待：给资源编号，请求资源只能按照编号顺序请求。
- 检测和恢复：用抢占、回滚、杀进程来恢复。
- 避免：银行家算法

### 进程和线程区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 

1. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； 
2. 进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些； 
3. 进程的并发性较低，线程的并发性较高； 
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； 
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； 
6. 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

### 线程和协程的区别

1. 线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源，而创建协程不需要调用操作系统的功能，编程语言自身就能完成，所以协程也被称为**用户态线程**，协程比线程轻量很多；

2. 线程在多核环境下是能做到真正意义上的并行，而协程是为并发而产生的；

4. 线程进程都是同步机制，而协程则是异步；

5. 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力；

6. 操作系统对于线程开辟数量限制在千的级别，而协程可以达到上万的级别。

### 进程的状态

创建、就绪、执行、阻塞、终止

<img src="https://s2.loli.net/2022/08/10/KY3twdbBEefoqUg.png" alt="img" style="zoom:50%;" />

### 进程调度

- 先来先服务（FCFS）调度算法
- 短作业优先（SJF）调度算法
- 优先级调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 多级反馈队列调度算法

### 进程间通信

- 管道（匿名管道）：UNIX系统IPC最古老形式，本质上是内核中维护的一块内存缓冲区，Linux中通过`pipe()`创建，会产生两个fd，fd[0]是读端，fd[1]是写端，只能用于**具有亲缘关系**的进程。注意调用一次pipe产生一个管道，只能支持一个进程向另一个进程发送数据，如果需要双向通信需要定义2个管道。
- 有名管道（FIFO，命名管道，FIFO文件）：管道由于没有名字因此只能用于亲缘进程，因此提出有名管道，提供一个路径名与管道关联，以FIFO的文件形式存在于文件系统中，打开方式与普通文件一致。
- 信号（软件中断）：事件发生时对进程的通知机制，是软件层面对中断机制的一种模拟，是异步通信。
- 消息队列：一个消息链表，消息有特定格式和优先级。
- 共享内存：多个进程共享同一块物理内存，这一段物理内存会进入进程用户空间，因此这种IPC无需内核介入，数据不需要像管道那样经过内核区，所以更快。`shm()`
- 内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘。`mmap()`
- 信号量：主要解决进程和线程同步问题。
- 套接字

### 线程间通信

- 信号：pthread_kill()
- 互斥锁：**pthread_mutex_t**
- 读写锁：pthread_rwlock
- 自旋锁：自旋锁不是通过休眠来阻塞，而是一直忙等。因此适用于锁持有时间短，不想在调度上花成本，想要响应快，一个进程单独持有。
- 条件变量：**pthread_cond_t**
- 信号量：**sem_wait**，**sem_post**

### 堆和栈的区别

1. 管理方式：对于栈来讲，是由编译器自动管理，无需手动控制；对于堆来说，分配和释放都是由程序员控制的。 
2. 空间大小：一般栈的空间小于堆。堆内存几乎没有限制；但是栈空间一般有限。
3. 碎片问题：对于堆来讲，由于分配和释放是由程序员控制的（利用new/delete 或 malloc/free），频繁的操作势必会造成**内存空间的不连续**，从而造成大量的内存碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的数据结构，在某一数据弹出之前，它之前的所有数据都已经弹出。 
4. 生长方向：对于堆来讲，生长方向是向上的，也就是沿着内存地址增加的方向，栈相反。
5. 分配方式：堆都是动态分配的。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配。
6. 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率很高。堆则是 C/C++ 函数提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率要比栈底的多。

### 虚拟内存

存在意义：物理内存有限，给进程营造内存充足的错觉，便于程序调度；如果直接操作物理内存会不安全

### 分段和分页

1. 分段
   将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，实现了离散分配。分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
2. 分页
   用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。分页主要用于实现虚拟内存，从而获得更大的地址空间。
3. 段页式
   页式存储管理能有效地提高内存利用率（解决内存碎片），而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，就形成了段页式存储管理方式。
   段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，为了实现从逻辑地址到物理地址的转换，系统中需要同时配置段表和页表，利用段表和页表进行从用户地址空间到物理内存空间的映射。

系统为每一个进程建立一张段表，每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。

### 建立socket连接涉及哪些系统调用

1. 创建socket，返回socket的fd: `int socket(int __domain, int __type, int __protocol)`
2. 命名socket，fd上绑定IP：`int bind(int __fd, const sockaddr *__addr, socklen_t __len)`
3. 开始监听：`int listen(int __fd, int __n)`
4. 发起连接和接受连接
    - 客户端发起连接：`int connect(int __fd, const sockaddr *__addr, socklen_t __len)`\
    - 服务端接受连接，产生一个新的fd表示连接：`int accept(int __fd, sockaddr *__restrict__ __addr, socklen_t *__restrict__ __addr_len)`

5. 收发数据（以下是基础的读写，Linux还有一些高级IO函数）
    - 发送数据：`ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)`
    - 接受数据：`ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)`
6. 关闭连接（监听fd也需要关闭）：`int close(int __fd)`

### IO复用

传统的多进程并发模型 ：每进来一个新的I/O流会分配一个新的进程管理。

但是这样不适合高并发的场景，因此引入多路IO复用：用单个线程，同时记录跟踪多个I/O流(sock)的状态，来同时管理多个I/O流。每个IO流（socket）就是一个客户连接。

|            | select             | poll             | epoll                                             |
| :--------- | :----------------- | :--------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无上限           | 无上限                                            |
| fd拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询：O(n)         | 轮询：O(n)       | 回调：O(1)                                        |

```C++
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
struct pollfd {
    int  fd;     /* file descriptor */
    short events;   /* requested events */
    short revents;  /* returned events */
};

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

## MySQL

### MVCC如何实现的

InnoDB用事务版本号，行记录中的隐藏列和Undo Log实现。

- **事务版本号**：每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。
- **行记录的隐藏列**
  - row_id :隐藏的行 ID ,用来生成默认的聚集索引。
  - trx_id: 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。
  - roll_ptr:回滚指针，指向这个记录的 Undo Log 信息。
- **Undo Log**：数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找。

### 隔离级别

- 未提交读：脏读问题。允许读尚未提交的数据。
- 已提交读：不可重复读问题。**加读写锁**解决上一个问题。允许读取并发事务已经提交的数据。
- 可重复读（InnodDB默认级别）：幻读问题，比如B事务在A事务读取的范围内增加数据，A事务会发现数据变多。对同一字段的多次读取结果都是一致的。**解决方法：MVCC（快照读）。**数据更新时会在数据行的隐藏字段记录当前事务版本号，事务只能读取到小于等于当前版本号的数据。
- 可串行化 ：InnoDB在可重复读的级别下使用**Next-Key Lock（行锁+间隙锁）**，锁定一个范围，包含记录本身。因此避免了幻读的产生。

### 行锁类型

行锁是有可能死锁的，原因在于上锁顺序不一致。

- 记录锁：也被称为记录锁，属于单个行记录上的锁。
- 间隙锁 ：锁定一个范围，不包括记录本身。锁加在不存在的空闲空间，可以是两个索引记录之间（比如区间查询），也可能是第一个索引记录之前或最后一个索引之后的空间（小于或大于）。也有比如有三个索引（2,4,8） ，如果对4加锁，那么也会同时对(2,4)和(4,8)这两个间隙加锁。
- Next-Key Lock ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

间隙锁的两个例外：

- 如果索引列是唯一索引，那么只会锁住这条记录(只加行锁)，而不会锁住间隙。
- 对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么依然会加间隙锁。

**意向锁**：意向读锁和意向写锁都是表级锁，不会和行级锁冲突，只会和表级锁冲突。当一个事务要加表锁时，需要判断该表是否有互斥的表锁和行锁，如果没有意向锁的话，需要遍历每一行才能知道有无行锁。

当给某一行增加共享锁、排他锁时，数据库会自动给这一行所处的表添加意向共享锁（IS Lock）、意向排他锁（IX Lock），等于说用意向锁来概括整张表的行锁情况，让加表锁时不需要遍历即可判断。

### 索引类型

除了主键索引，还有辅助索引：

- 唯一索引：不重复，可以null
- 普通索引：允许重复和null
- 前缀索引：只适用于字符串
- 全文索引：检索大文本，InnoDB在5.6后加入

### 主从复制

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。 
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。 
3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。 

复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。

### 慢查询

- slow_query_log：这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。
- long_query_time：当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。
- slow_query_log_file：记录日志的文件名。
- log_queries_not_using_indexes：这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。

### 日志类型

- redu log：物理格式，保证事务持久性，日志记录事务执行后的状态
- undo log：事务回滚，保证事务原子性
- bin log：主从复制，从库利用主库上的binlog进行重播，实现主从同步。事务提交时将sql记录。

### 三范式

- 第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。
- 第二范式要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。
- 第三范式要求：实体中的属性不能是其他实体中的非主属性。即：属性不依赖于其他非主属性。

## Redis

### 双写一致性

考虑**旁路缓存模式**，也就是读数据库前先尝试从缓存读取。该模式下的写流程应该是**先更新数据库，再删除缓存**。Redis缓存需要考虑一致性和实时性。

如果是采用更新数据库和缓存的方案，无论哪个先更新，都存在问题：假如有一步成功，但另一步失败。

- 先更新缓存，再更新数据库：更新缓存后数据库更新失败，缓存失效后变回旧值。
- 先更新数据库，再更新缓存：用户读到旧值，直到缓存失效后与数据库同步。

在并发时这两种方案也有问题。此外，如果数据变更后马上就写入缓存，但是该数据不一定会被马上访问，缓存中会增加很多低频数据。

更新缓存的劣势：

- 写入的缓存可能需要计算才能得到
- 在数据库**写多读少**的场景下，数据还没读到就被更新，浪费。

因此采用**删除缓存**的方案。那么具体先更新数据库还是先删缓存呢

这里如果第二步失败也有问题，先看并发问题：
都是A来更新，B来访问。注意，只考虑最终情况，不考虑访问到一次脏数据。

- 先删缓存，再更数据库：A删除缓存后，B读不到缓存，从数据库中读到旧值，然后A往数据库写新值，B往缓存写旧值。
- 先更新数据库，再删缓存：缓存正好到期失效，B查询数据得到旧值，A将新值写入数据库后删除缓存，B将旧值写入缓存。

这一步其实很难发生，因为写数据库比读慢很多，B写入缓存的旧值大概率会在A删除缓存前完成。

### 延迟双删

先删缓存，再更新数据库，休眠一会再删缓存。解决先删缓存再更数据库，同时也解决读写分离+主从复制延迟的问题。
这个休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒。 为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。
为了保证第二次删除一定能成功需要重试机制。

### 缓存击穿、穿透、雪崩

**缓存击穿**：当一份访问量非常大的热点数据缓存失效的瞬间，大量的请求直达存储层，导致服务崩溃。可以通过热点数据不设置过期时间来解决，或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。

**缓存穿透**：大量请求的 key 不存在缓存中，导致请求直接打到数据库上。解决：缓存无效key；布隆过滤器：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

**缓存雪崩**：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上。 **针对 Redis 服务不可用的情况**：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用；限流，避免同时处理大量的请求。**针对热点缓存失效的情况**：设置不同的失效时间比如随机设置缓存的失效时间；缓存永不失效。

### 数据结构

- 字符串：len, free（buf中未使用字节数）, char buf[]
- 链表：prev, next, void* value
- 字典：dictht { dictEntry **table（哈希表数组指针）, size, sizemask（总是size-1）, used} 。dictEntry是键值对。dict { dictType, dictht[2], rehashidx, privdata }。ht[0]用来保存使用，ht[1]用作扩容时的临时空间。
- 跳跃表
- 整数集合：intset{ encoding, length, contents[] }
- 压缩列表

### 对象

redisObject{ type, encoding, void* ptr}

<img src="https://s1.ax1x.com/2022/07/26/jzASR1.png" alt="jzASR1.png" style="zoom:50%;" />

###  内存淘汰

运行内存达到阈值（maxmemory）就会触发。64位默认0（无限制），32位默认3GB。

1. **noeviction**：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；
2. **allkeys-lru**：淘汰整个键值中最久未使用的键值；
3. **allkeys-random**：随机淘汰任意键值;
4. **volatile-lru**：淘汰所有设置了过期时间的键值中最久未使用的键值；
5. **volatile-random**：随机淘汰设置了过期时间的任意键值；
6. **volatile-ttl**：优先淘汰更早过期的键值。

在 Redis 4.0 版本中又新增了 2 种淘汰策略：

1. **volatile-lfu**：淘汰所有设置了过期时间的键值中，最少使用的键值；
2. **allkeys-lfu**：淘汰整个键值中最少使用的键值。

### 过期策略

- 立刻删除：内存可以尽快释放，但是影响性能
- 惰性删除：访问时才判断过期，资源占用少，但是不及时
- 定期删除：定期检查库，随机删除过期键

Redis 使用的是惰性删除加定期删除的过期策略。

### 分布式锁

`SETNX`命令，如果key已存在就什么都不做，通过返回值判断是否修改及成功，要加过期时间。

## C++

### 多态

- 静态多态：由**编译器**在**编译期**间完成的，编译器会根据实参类型来选择调用合适的函数。静态多态有函数重载、运算符重载、泛型编程等。
- 动态多态：程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

### static

- 局部静态变量：生命周期直到程序结束，但是作用域只在局部，离开后不会销毁但是也无法访问。
- 全局静态变量：作用域在定义的文件内（全局变量在整个工程文件）

### 虚函数

当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储类虚函数指针的数据结构。virtual 成员函数会被放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时, vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。

在多继承时，派生类会继承所有基类的虚函数表，自己的虚指针

有纯虚函数的类才是抽象类。构造函数不能是虚函数。

### C++11新特性

static_assert 编译时断言；新增加类型 long long ，unsigned long long，char16_t，char32_t，原始字符串；auto；decltype；委托构造函数；constexpr；模板别名；alignas；alignof；原子操作库；nullptr；显示转换运算符；继承构造函数；变参数模板；列表初始化；右值引用；Lambda 表达式；override、final；unique_ptr、shared_ptr；initializer_list；array、unordered_map、unordered_set；线程支持库

### STL容器

1. 序列式容器 array、vector、deque、list、forward_list 
2. 关联式容器 map、multimap、set、multiset 
3. 无序关联式容器 unordered_map、unordered_multimap、unordered_set、unordered_multiset 
4. 容器适配器 stack、queue、priority_queue

### new的原理

new 的实现原理： 如果是简单类型，则直接调用 operator new()，在 operator new() 函数中会调用 malloc() 函数，如果调用 malloc() 失败会调用 _callnewh()，如果 _callnewh() 返回 0 则抛出 bac_alloc 异常，返回非零则继续分配内存。 如果是复杂类型，先调用 operator new()函数，然后在分配的内存上调用构造函数。

### new和malloc的区别

- new 是操作符，而 malloc 是函数； 

- 使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸；
- new 分配失败的时候会直接抛出异常，malloc 分配失败会返回 NULL； 
- 对于非简单类型，new 在分配内存后，会调用构造函数，而 malloc 不会； 
- new 分配成功后会返回对应类型的指针，而 malloc 分配成功后会返回 void * 类型； 
- malloc 可以分配任意字节，new 只能分配实例所占内存的整数倍数大小；
- new 可以被重载，而 malloc 不能被重载；
- 使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充，new 没有这样直观的配套设施来扩充内存。
- new 操作符从自由存储区上分配内存空间，而 malloc 从堆上动态分配内存；

### 指针和引用

1. 定义和性质不同。指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。指针定义格式为：数据类型 *；而引用的定义格式为：数据类型 &
2. 引用不可以为空，当被创建的时候必须初始化，而指针变量可以是空值，在任何时候初始化； 
3. 指针可以有多级，但引用只能是一级； 
4. 引用使用时无需解引用（*），指针需要解引用； 
5. 指针变量的值可以是 NULL，而引用的值不可以为 NULL； 
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了； 
7. sizeof 引用得到的是所指向的变量（对象）的大小，而 sizeof 指针得到的是指针变量本身的大小； 
8. 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本； 

### 红黑树

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

### 四种类型转换

- static_cast：替代编译器执行的隐式转换。比如执行int与float的转换，隐式转换编译器会警告精度损失，静态转换表示有意为之。可以用于基类与派生类的指针或引用的转换，但是不做运行时检查，不如dynamic_cast安全。
- dynamic_cast：主要用于类层次间的上行转换和下行转换向上转型和static_cast是一样的；在下行转换时有**类型检查**的功能，比 static_cast 更安全
- const_cast：该运算符用来修改类型的const属性。注意:不能直接对非指针和非引用的变量使用 const_cast 操作符 
- reinterpret_cast 重新解释转换：是最不安全的一种转换机制。主要用于将一种数据类型从一种类型转换为另一种类型，比如指针和整数的转换，`int*`和`char*`的转换。

### C++程序内存分布

- 栈区：地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的数据结构中的栈，先进后出。
- 堆区：地址向上增长，一般由程序员分配释放，程序结束时可能由OS回收。分配方式类似于链表。
- 全局区（静态区）：全局变量和静态变量。初始化的在一块区域，未初始化在相邻的另一块区域。程序结束后由OS释放
- 文字常量区：常量字符串就是放在这里的。程序结束后由系统释放
- 程序代码区(text)—存放函数体的二进制代码。

### 编译过程

1. 预编译
2. 编译：进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。
3. 汇编：将汇编代码转变成机器可以执行的指令(机器码文件)。
4. 链接：静态链接、动态链接

### const指针

`int *const p`是常量指针，这个指针本身是常量，指向变量后不许改变。

`int const *p`和`const int *p`是指针常量，指向一个常量。

区分就看`const`在`*`的左边还是右边。在右边是顶层const，修饰指针；在左边是底层const，修饰底层变量。

### 智能指针

`auto_ptr`在C98加入，C11被`unique_ptr`取代，C17移除。只要诟病在于拷贝会造成所有权转移，不符合常识，也不能作为函数参数，不能作为类成员被拷贝等。在`unique_ptr`中需要使用move才能转移所有权。

避免：裸指针和智能指针混用；智能指针混用；不要管理同一个裸指针；避免使用get()获取原生指针；不要管理this指针；只管理堆上的对象；使用make_shared初始化

## Java

### 抽象类

1. 抽象类不能被实例化，编译不通过。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含具体实现。但是接口可以。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

### 抽象类和接口区别

1. 抽象类和接口都可以有属性，但接口不可以有构造函数
2. 抽象方法没有具体实现，1.8后接口函数可以有默认实现，但只能被子类调用而不能被实现。

### 泛型的意义

- 编译时的强类型检查
- 避免类型转换
- 实现通用算法

### 如何保证线程安全

常见的三种，按照资源占用由轻到重

1. **原子类**。JDK1.5开始提供`java.util.concurrent.atomic`包，提供原子操作类。包中一共17个类，可归纳为4种原子更新方式：原子更新基本类型、引用类型、属性、数组。无论哪种类型，都遵循**比较和替换**原则，即要更新的值是否等于期望值，如果是才更新。即CAS思想：CAS有三个参数，当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。
2. **volatile**：volatile是轻量级的synchronized，保证共享变量的可见性。可见性问题由处理器核心的缓存导致，处理器如果从缓存中读取变量，可能获取不到内存中的最新版本。volatile的内存语义为，当写一个volatile变量时，该线程的本地内存会被置为无效，迫使线程从主内存中读取。
3. **synchronized**：以上两种方式只能保证单个共享变量的安全，但是锁可以保证临界区内多个共享变量。synchronized是早期API，没考虑超时机制、非阻塞形式、多个条件变量等，因此JDK1.5加入了**Lock接口**，支持以上。
4. 其他：Semaphore，信号量；CountDownLatch，允许一个或多个线程等待其他线程操作完毕；CyclicBarrier，让一组线程在一个地方同步；ThreadLocal本地存储，不使用共享变量。

### AOP

### HashMap

JDK8之前是数组+链表，之后是数组+链表+红黑树。相同哈希值的元素组成链表，长度超过8会转为红黑树。负载因子达到0.75时扩容。

### 引用类型

- 强引用：不会被垃圾收集器回收。用 new创建
- 软引用：只有内存不够时会被回收。用`SoftReference<T>(obj)`创建
- 弱引用：一定会被回收，只能存活到下次垃圾回收发生。`WeakReference<T>`
- 虚引用：对象被垃圾回收时能收到一个系统通知。`PhantomReference<T>`

### 多线程

创建方法：继承Thread、实现Runnable、实现Callable（有返回值）

线程通信：wait/notify/notifyAll、join、管道

### 并发容器

同步容器主要包括2类：

- vector，stack，hashtable
    - Vector：实现List接口，本质上是数组，所有方法都是synchronized
    - stack：继承vector，所有方法synchronized
    - Hashtable：实现Map接口，有同步处理
- Collections类中提供的静态工厂方法创建的类（由Collections.synchronizedXXX等方法）

在jdk1.6对synchronized优化前，这类容器性能不好。而且虽然保证同时只有一个线程能访问，但也不是绝对安全。比如一个线程先把vector中remove了一个元素，另一个线程就会发现size变了。

并发容器有3个系列：

- Concurrent：基于跳表实现的map和set（有序set和map），哈希表，链表实现的队列和双向队列。

    锁竞争比CopyOnWrite高，但是写操作代价小。提供较低的遍历一致性，在迭代容器时修改容器，会导致获取size不精确，这是为了**保证吞吐量**设计的。

- CopyOnWrite：基于数组的List和set。

    一个线程写，多个线程读。读操作不加锁，写操作时通过在副本上加锁来保证并发安全，空间开销大。

- Blocking：链表实现的队列和双向队列，数组实现的队列。基于锁提供阻塞队列的能力。

强一致性要求用Hashtable，弱一致性用ConcurrentHashMap。读多写少用CopyOnWriteArrayList，写多读少用ConcurrentListedQueue。

### 并发哈希表

1.7采用分段锁。1.8对每一条数据加锁，CAS + `sychronized` 操作。

### 线程池的意义

1. 创建/销毁线程需要消耗系统资源，线程池可以**复用已创建的线程**。
2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
3. 可以对线程做统一管理。

### 线程池参数

- `corePoolSize` - 核心线程数量。任务提交时，判断的顺序为 `corePoolSize` => `workQueue` => `maximumPoolSize`。都放不下了交给`handler`处理。
- `maximumPoolSize` - 最大线程数量。
- `keepAliveTime`：线程保持活动的时间。非核心线程的最大空闲时间。
- `unit` - `keepAliveTime` 的时间单位。
- `workQueue` - 等待执行的任务队列。ArrayBlockingQueue需要指定大小，是有界的。LinkedBlockingQueue默认大小INT_MAX，可以看做无界，会使`maximumPoolSize` 失效。SynchronousQueue可以看做容量为1。
- `threadFactory` - 线程工厂。
- `handler` - 饱和策略。AbortPolicy丢弃，抛出异常，默认；DiscardPolicy丢弃，不抛异常；DiscardOldest，丢弃队头任务，重复尝试执行；CallerRuns直接调用run并阻塞执行；实现RejectedExecutionHandler自定义。

### 动态代理

在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁。

**JDK动态代理**：基于**实现接口**的方式

1. 获取 RealSubject 上的所有接口列表；
2. 确定要生成的代理类的类名，默认为：`com.sun.proxy.$ProxyXXXX`；
3. 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；
4. 将对应的字节码转换为对应的 class 对象；
5. 创建 `InvocationHandler` 实例 handler，用来处理 `Proxy` 所有方法调用；
6. Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。

代理类与委托类实现同一接口，主要是通过代理类实现 `InvocationHandler` 并重写 `invoke` 方法来进行动态代理的，在 `invoke` 方法中将对方法进行处理。

JDK 动态代理特点：

- 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。
- 缺点：强制要求代理类实现 `InvocationHandler` 接口。

**CGLIB动态代理**

CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。

CGLIB 动态代理的工作步骤：

- 生成代理类的二进制字节码文件；
- 加载二进制字节码，生成 `Class` 对象( 例如使用 `Class.forName()` 方法 )；
- 通过反射机制获得实例构造，并创建代理类对象。

CGLIB 动态代理特点：

优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。

缺点：不能对 `final` 类以及 `final` 方法进行代理。

### 保证并发安全的思路

1. 互斥同步：悲观策略，synchronized和Lock
2. 非阻塞同步：乐观并发策略，先操作后检测，Unsafe类的CAS操作（不需要加锁）
3. 无同步：不涉及共享数据。设计可重入代码，或者使用ThreadLocal。

### 锁类型

可重入

- `ReentrantLock` 、`ReentrantReadWriteLock` 是可重入锁。这点，从其命名也不难看出。
- `synchronized` 也是一个可重入锁。

公平锁与非公平锁

- `synchronized` 只支持非公平锁。
- `ReentrantLock` 、`ReentrantReadWriteLock`，默认是非公平锁，但支持公平锁。

独享与共享

- `synchronized` 、`ReentrantLock` 只支持独享锁。
- `ReentrantReadWriteLock` 其写锁是独享锁，其读锁是共享锁。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。

悲观与乐观

- `synchronized` 和`Lock`是悲观锁
- `CAS`机制是乐观锁

偏向锁、轻量级、重量级

- **偏向锁** - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- **轻量级锁** - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- **重量级锁** - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

### AQS 原理

locks包中的锁（常用的有 `ReentrantLock`、 `ReadWriteLock`），都是基于AQS实现的。提供对独享锁和共享锁的支持，各有一套API。

- AQS 使用一个整型的 `volatile` 变量来 **维护同步状态**。状态的意义由子类赋予。
- AQS 维护了一个 FIFO 的双链表，用来存储获取锁失败的线程。

## JVM

### JVM内存

线程私有：程序计数器，Java虚拟机栈（保存局部变量表、操作数栈、常量池引用等，为Java方法服务），本地方法栈（为Native方法服务）

共享：堆，方法区（永久代，保存已被加载的类信息、常量、静态变量），运行时常量池（方法区的一部分，把保存字面量和符号引用）

| 内存区域      | 内存作用范围   |                                                              |
| ------------- | -------------- | ------------------------------------------------------------ |
| 程序计数器    | 线程私有       | 当前线程所执行的字节码的行号指示器。                         |
| Java 虚拟机栈 | 线程私有       | 每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 **局部变量表**、**操作数栈**、**常量池引用** 等信息。每个方法的执行都对应一次入栈出栈。 |
| 本地方法栈    | 线程私有       | 与虚拟机栈的作用相似。区别在于：**虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务**。本地方法并不是用 Java 实现的，而是由 C 语言实现的。`OutOfMemoryError` |
| Java 堆       | 线程共享       | 存放对象实例，几乎所有的对象实例都是在这里分配内存。         |
| 方法区        | 线程共享       | 永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 |
| 运行时常量池  | 线程共享       | 用于存放编译器生成的各种字面量和符号引用，会在类加载后被放入这个区域。 |
| 直接内存      | 非运行时数据区 | 使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。 |

### 字节码

魔法数字，4字节，确定该文件能否被JVM接受；版本号，4字节，次版本和主版本；常量池，包括计数器和数据区；访问标志，2字节，描述是类还是接口，和访问级别；类名，2字节；父类名称，2字节；接口信息，2字节的计数器；n字节的接口名称索引；字段表；方发表；附加属性表

### 对象检测

Java中存在循环引用问题，无法使用引用计数法。JVM采用可达性分析，通过 **GC Roots** 作为起始点进行搜索，JVM 将能够到达到的对象视为**存活**，不可达的对象视为**死亡**。GC root可以是：虚拟机栈中引用的对象；本地方法栈中引用的对象（Native 方法）；方法区中，类静态属性引用的对象；方法区中，常量引用的对象

强引用（不回收），软引用（不够时回收），弱引用（下次一定回收），虚引用（回收时系统通知）

### 垃圾收集算法

- 标记-清除：原地清理被标记对象，存活对象较多时比价高效，适用于**老年代**；缺点是容易产生内存碎片，效率不稳定（标记数不确定)。吞吐量小，延迟低。
- 标记-整理：将存活对象整理到一起。适用于存活对象少，垃圾对象多。用于**老年代**。吞吐量大，延迟高
- 标记-复制：内存分成2块，每次将存活对象复制到一边，回收另一边。适用于存活对象少。用于**新生代**。缺点：可用空间少了一半
- 分代回收：堆内存分为年轻代和老年代。**年轻代使用复制，老年代使用标记清除或标记整理。**年轻代中有较大的Eden区和2个Survivor区。每次把Eden和一个Survivor区中的存活对象复制到另一个Survivor，在Survivor中复制次数达到阈值可以升级到老年代。

### 垃圾收集器

[![xZfN9g.png](https://s1.ax1x.com/2022/09/27/xZfN9g.png)](https://imgse.com/i/xZfN9g)

- 串行收集器：`-XX:+UseSerialGC` Serial；Serial Old（老年代版本，标记整理）。单线程stop-the-world收集，所有线程进入安全点时，应用线程暂停，串行GC以单线程回收内存。适用于堆内存小，CPU核少的环境，client模式默认收集器。

- 并行收集器：Parallel Scavenge(标记复制，关注吞吐量)；Parallel Old（老年代版本，标记整理）。server模式默认收集器，以吞吐量为目标。stop-the-world时**并行**收集，**年轻代采用复制算法，老年代采用标记-整理**。

    `-XX:+UseParallelGC`:**Parallel Scavenge** + **Serial Old** 

    `-XX:+UseParallelOldGC`:**Parallel Scavenge** + **Parallel Old**（吞吐量优先）

- 并发标记清除收集器：

  `-XX:+UseConcMarkSweepGC`:**CMS** + **ParNew** + **Serial Old**

  - CMS（Concurrent Mark Sweep并行**标记清除**）：目标是**最短停顿时间**。

    初始标记，仅标记GC Root能关联到的对象，速度快，要停顿；并发标记，GC root tracing，耗时最长，不用停顿；重新标记，停顿，修正并发标记期间改变的标记；并发清除，不停顿。

  - ParNew：Serial 收集器的多线程版本，Server 模式下的虚拟机首选年轻代收集器。

- G1收集器：兼顾吞吐量和停顿时间。Oracle JDK9 以后的默认 GC 收集器。**引入分区概念，弱化分代**。`-XX:+UseG1GC`

  G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。整体是标记整理，局部看region是复制。

  初始标记，停顿，单线程；并发标记，不停顿，与应用线程并发；最终标记，停顿，并发；筛选回收，根据region的回收价值和成本排序，回收一部分，停顿，并发。

## 其他

### 软件设计原则

- 单一职责原则（SRP）：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
- 开闭原则（OCP）：软件实体应当对扩展开放，对修改关闭。
- 里氏替换原则（LSP）：子类在继承父类时，不要改变父类原有的功能，可以替换父类
- 接口隔离原则（ISP）：客户端不应该被迫依赖于它不使用的方法。
- 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
- 迪米特法则（LoD）：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
- 合成复用原则（CRP）：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

### 线程安全的单例模式

饿汉模式没有线程安全问题，因为在程序运行之初就已经初始化。懒汉模式在并发环境下存在重复初始化的问题。解决方法：

1. 给整个`getInstance()`方法加`synchronized `
2. 加同步代码块，但是`getInstance()`中除了`return`之外的语句都需要加入同步区，性能和上一种差不多烂
3. 先判断是否为`null`，仅给`new`的语句加锁，但是仍然线程不安全，因为可能多个线程同时通过了判断。需要检查两次，**双检查锁机制**。在同步块内的`new`之前在判断一次是否为空。
4. 用static代码块可以让代码在使用类的时候就已经执行了

### 多级目录

当前目录ID：catalogueId；目录名称：name；目录级别ID：gradeId；父级目录ID：piarentId 

### ZAB原子广播

- Leader：维护与Follower和Observer的心跳，执行写操作并广播
- Follower：处理读请求，转发写请求，投票
- Observer：没有投票权的Follower

写操作时，Leader将写操作以Proposal形式发给所有Follower，得到超过半数ACK则向全体发送Commit。

logicClock记录头票轮次，以最后一次为准，忽略比自己轮次早的。票数相同时把自己的票归给vote_zxid或者vote_myid更大的。

### Bean生命周期

基于XML配置；注解配置；JAVA API配置（专门的Config类+@Configuration注解）

5种scope：

- Singleton：单例，每个IOC容器仅有一个实例
- Prototype：每次请求都产生新实例
- Request：每个HTTP请求产生新实例，且仅在该HTTP请求内有效
- Session：每个HTTP请求产生新实例，且仅在该session内有效
- Global session：仅在基于 portlet 的 web 应用中才有用

[![xEAIdx.png](https://s1.ax1x.com/2022/09/25/xEAIdx.png)](https://imgse.com/i/xEAIdx)

1. Spring 对 Bean 进行实例化（相当于 new XXX()）
2. Spring 将值和引用注入进 Bean 对应的属性中
3. 如果 Bean 实现了 `BeanNameAware` 接口，将 Bean 的 ID 传递给 `setBeanName` 方法
4. 如果 Bean 实现了 `BeanFactoryAware` 接口，把 `BeanFactory` 容器实例作为参数调用 `setBeanDactory` 方法。作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等
5. 如果 Bean 实现了 `ApplicationContextAware` 接口，Spring 容器将调用 `setApplicationContext` 方法，把应用上下文作为参数传入
   - 作用与 `BeanFactory` 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 `setApplicationContext` 方法时会把它自己作为 `setApplicationContext` 的参数传入，而 Spring 容器在调用 `setBeanFactory` 前需要使用者自己指定（注入）`setBeanFactory` 里的参数 `BeanFactory`
6. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessBeforeInitialization` 方法
   - 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能
7. 如果 Bean 实现了 `InitializingBean` 接口，Spring 将调用 `afterPropertiesSet` 方法，作用与在配置文件中对 Bean 使用 `init-method` 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。
8. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessAfterInitialization` 方法
9. 经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁
10. 如果 Bean 实现了 `DispostbleBean` 接口，Spring 将调用它的 `destory` 方法，作用与在配置文件中对 Bean 使用 `destory-method` 属性的作用一样，都是在 Bean 实例销毁前执行的方法。

### Spring的IOC容器

- BeanFactory，懒加载，使用语法显式提供资源，不支持国际化，不支持基于依赖的注解
- ApplicationContext：BeanFactory的扩展，即时加载，自己创建和管理资源，支持国际化，基于依赖的注解

好处：减少代码量；减少侵入，促进解耦；自持即时实例化和懒加载；易于测试

实现原理：工厂模式+反射机制

## 附录

### HTTP状态码

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

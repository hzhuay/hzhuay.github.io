---
title: questions
date: 2022-08-09 00:23:38
tags: 
hide: true
---

本人在校期间学习认真刻苦，成绩优异，积极参与校内外活动和比赛，能够顺利和同学合作完成软件项目，并在过程中发挥带头作用。
本人热爱游戏行业，从孩童时期就解除过游戏，并对游戏行业产生浓厚兴趣。进入大学后，学习计算机方面的知识，希望能在游戏的服务端方向有所作为。

• 工作描述：参与部门项目的开发工作，撰写技术文档，掌握问题排查、bug 修复、开发环境部署流程。
• 成果描述：
– 在 mentor 指点下，学习项目所需的 Spring 技术栈、跨模块调用和服务器部署等技能。
– 参与智能视频分析平台解决方案项目，完成管理平台部分模块的开发任务，修复若干错误。
• 个人收获：学习 Spring 开发技术栈，熟悉项目开发流程，体验真实开发场景。

智能视频分析平台

• 应用技术：SpringMVC，SpringBoot，MySQL，Redis，ZooKeeper，Kafka，SeaweedFS
• 项目描述：搭建稳定可靠的基础服务“底座”为核心并提供可视化的系统管理工具用于摄像头管理、服务器管理、服务管理等基础管理子系统，在此基础上搭建以寻人为核心能力的视频智能分析系统。
• 主要工作：完成用户管理、日志筛选获取、应用管理等模块开发，撰写技术文档和接口文档，通过查询日志定位并修复错误。

二手房信息平台

• 应用技术：Python，Vue，Flask，SQLite，ECharts，XGBoost，Nginx，Docker
• 项目描述：毕业设计项目，开发二手房信息平台的前后端分离项目，包含功能有登录注册，用户上传房源，房价预测，房源展示和推荐，数据分析展示。
• 主要工作：编写 Python 爬虫程序爬取房源信息，使用 Vue+ElementUI 完成前端开发，使用高德地图API 开发前端地图插件，使用 Flask 完成后端开发，通过 docker 完成云服务器环境搭建和部署。

## 开放性问题

### 自我介绍

面试官您好，非常感谢能给我这次面试机会（很感谢您这么晚还抽空面试）。我叫XXX，本科就读于北京工业大学，研究生就读于香港科技大学，目前正在每日互动股份有限公司做Java开发的实习工作。

我过往的经历主要可以分为两部分。第一部分是我的在校经历，我在校期间成绩优秀，本科获得了北工大优秀毕业生和都柏林大学的一等学位。同时我在课余时间也会给自己充电，比如参加竞赛，阅读专业书籍等，也自学了多门语言。第二部分是我的实习经历，我在实习阶段主要学习了Spring相关的技术栈，以及积累了宝贵的真实项目开发经验。

### 项目中遇到的问题

没遇到难点就诚实的说暂时没遇到什么深刻的难点，然后可以转移话题到做过什么**优化**。

新需求，过期删除，看英文文档，写demo；手写定时任务；不能直接删除；delete limit，但是末尾怎么办；提前获取要删除的数量，count顺序扫描很快，后台任务不加索引

### 最大的优点

### 最大的缺点

团队管理能力

### 职业发展规划

### 兴趣爱好



## 计网

### TPC/IP五层模型

- 应用层：HTTP，SMTP，DNS，FTP
- 运输层：TCP，UDP
- 网络层：ICMP、IGMP、IP（IPv4、IPv6）、ARP、RARP
- 数据链路层：两个节点传输数据时，链路层将网络层交下来的数据报组装成帧，在链路上传送帧。每一帧都包括数据和控制信息（同步信息、地址信息、差错控制等）。 
- 物理层

### TCP和UDP区别

### 三次握手四次挥手

### TCP如何实现可靠传输

TCP是通过序列号、检验和、确认应答信号、重发机制、连接管理、窗口控制、流量控制、拥塞控制一起保证TCP传输的可靠性的。

- 序列号：TCP给发送的每一个包都进行编号，接收方对数据包进行排序，把有序数据传送给应用层，TCP的接收端会**丢弃重复的数据**。
-  检验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。 
- 确认应答：如果收到的数据报报文段的检验和没有差错，就确认收到，如果有差错，TCP就丢弃这个报文段和不确认收到此报文段。 
- 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
-  拥塞控制：当网络拥塞时，减少数据的发送。 
- 停止等待协议：它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 
- 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### UDP如何实现可靠传输

- RDT1.0：建立在理想可靠信道上，发送和接收方都只有等待调用状态
- RDT2.0：考虑了翻转错误，发送方增加了等待ACK或NAK状态。
- RDT2.1：考虑了ACK或NAK出错出错的情况。简单重传会导致重复分组，因此引入序列号，发送方給每个分组增加序列号，接收方丢弃重复分组。序列号目前可以只为0或1，说明每次只发送一个包。
- RDT2.2：取消NAK，在ACK中显式加入被确认分组的序列号，这样重复的ACK即代表NAK。
- RDT3.0：考虑了丢失分组，因此加入超时重传。如果ACK只是延迟了也无妨，因为接收端收到了重复的分组会自动丢弃。收到重复ack会忽略，因为包可能还在路上，所以只用管计时器。

### TIME_WAIT

四次挥手时，主动断连的一方发送最后一个ACK后会进入TIME_WAIT，会等待2MSL（最大报文生存期）才会回到初始状态CLOSED。这么做是确保另一方收到这个消息。万一这条消息丢失了，需要花1个MSL的时间，被关闭方会重发FIN，又要1个MSL来接收。

### 拥塞控制机制

慢开始、拥塞避免、快重传、快恢复。GET和POST区别

- 语义不同：GET获取数据，POST提交数据
- 幂等性：GET有幂等性，每次GET的效果相同。POST没有
- 长度限制：浏览器一般对GET有长度限制，2048字节。POST无
- 参数位置：GET参数在URL中，由？开头，& 连接。POST参数在请求体中，URL上不可见。
- 编码：GET只能url编码，POST可以多种编码

### 粘包

TCP基于字节流，无法判断发送方报文段边界。

多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包。

 解决粘包的方法： 

1. 发送方关闭Nagle算法，使用TCP_NODELAY选项关闭Nagle功能 
2. 发送定长的数据包。每个数据包的长度一样，接收方可以很容易区分数据包的边界 
3. 数据包末尾加上特殊标记
4. 数据包头部加上数据包的长度。数据包头部定长4字节，可以存储数据包的整体长度 
5. 应用层自定义规则

### 滑动窗口



### URL到内容显式的过程

1、查浏览器缓存，看看有没有已经缓存好的，如果没有

2 、检查本机host文件，

3、调用API，Linux下Socket函数 gethostbyname

4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议

5、如果在一个子网内采用ARP地址解析协议进行ARP查询。如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）

6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会首先尝试http然后调用Socket建立TCP连接。

7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，

8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，

9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，

10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。

11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页

### HTTP状态码

| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| ---- | ---------------------------------------------- |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

200成功；301永久移动；302临时移动；304未修改，使用缓存；400语法错误，服务端无法解析；401未身份验证；403拒绝访问；404找不到资源；405请求方法不对；500服务器内部错误

### HTTPS

与HTTP区别：

- 默认端口号不同：HTTP是80，HTTPS是443
- 安全性：HTTP明文，HTTPS密文
- 协议：TCP；TLS，TLS基于TCP
- HTTP只需要进行TCP连接；HTTPS建立TCP连接后还需要建立TLS连接

建立连接过程：

1. 客户端发送一个**https**的请求到服务端
2. 服务端申请配置好数字证书，包含公钥和私钥
3. 服务端将证书传送给客户端，证书中包含了很多信息，比如证书的颁发机构，过期时间，网址，公钥等
4. 客户端解析证书，由客户端的TLS完成，首先会验证公钥是否有效，比如颁发机构，过期时间等。

### HTTP2.0

- 二进制格式（Binary Format）：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

- 多路复用（MultiPlexing）：连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面。
- 头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小。
- 服务端推送（server push）：如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回。

## OS

### Linux常用命令

常用：cd, ls, ll, grep, cp, mv, rm, ps, kill, pwd

查看文件：more, less, cat

查看系统资源：top：查看操作系统的信息，如进程、CPU占用率、内存信息等（实时)； free：查看内存使用情况

### 死锁

必要条件：

- 互斥：资源是独占的，排他性使用
- 请求保持：进程在已经持有资源的情况下请求新资源，并且在阻塞期间不会释放已经获得的资源
- 不可抢占：进程已获得的资源不会被抢占，只能自己释放
- 循环等待：形成资源请求链

如何防止死锁：

- 预防：破坏四种必要条件。比如破坏循环等待：给资源编号，请求资源只能按照编号顺序请求。
- 检测和恢复：用抢占、回滚、杀进程来恢复。
- 避免：银行家算法

### 进程和线程区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 

1. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； 
2. 进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些； 
3. 进程的并发性较低，线程的并发性较高； 
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； 
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； 
6. 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

### 线程和协程的区别

1. 线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源，而创建协程不需要调用操作系统的功能，编程语言自身就能完成，所以协程也被称为**用户态线程**，协程比线程轻量很多；

2. 线程在多核环境下是能做到真正意义上的并行，而协程是为并发而产生的；

4. 线程进程都是同步机制，而协程则是异步；

5. 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力；

6. 操作系统对于线程开辟数量限制在千的级别，而协程可以达到上万的级别。

### 进程的状态

创建、就绪、执行、阻塞、终止

<img src="https://s2.loli.net/2022/08/10/KY3twdbBEefoqUg.png" alt="img" style="zoom:50%;" />

### 进程调度

- 先来先服务（FCFS）调度算法
- 短作业优先（SJF）调度算法
- 优先级调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 多级反馈队列调度算法

### 进程间通信

- 管道（匿名管道）：UNIX系统IPC最古老形式，本质上是内核中维护的一块内存缓冲区，Linux中通过`pipe()`创建，会产生两个fd，fd[0]是读端，fd[1]是写端，只能用于**具有亲缘关系**的进程。注意调用一次pipe产生一个管道，只能支持一个进程向另一个进程发送数据，如果需要双向通信需要定义2个管道。
- 有名管道（FIFO，命名管道，FIFO文件）：管道由于没有名字因此只能用于亲缘进程，因此提出有名管道，提供一个路径名与管道关联，以FIFO的文件形式存在于文件系统中，打开方式与普通文件一致。
- 信号（软件中断）：事件发生时对进程的通知机制，是软件层面对中断机制的一种模拟，是异步通信。
- 消息队列：一个消息链表，消息有特定格式和优先级。
- 共享内存：多个进程共享同一块物理内存，这一段物理内存会进入进程用户空间，因此这种IPC无需内核介入，数据不需要像管道那样经过内核区，所以更快。`shm()`
- 内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘。`mmap()`
- 信号量：主要解决进程和线程同步问题。
- 套接字

### 线程间通信

- 信号：pthread_kill()
- 互斥锁：**pthread_mutex_t**
- 读写锁：pthread_rwlock
- 自旋锁：自旋锁不是通过休眠来阻塞，而是一直忙等。因此适用于锁持有时间短，不想在调度上花成本，想要响应快，一个进程单独持有。
- 条件变量：**pthread_cond_t**
- 信号量：**sem_wait**，**sem_post**



### IO多路复用

### 堆和栈的区别

1. 管理方式：对于栈来讲，是由编译器自动管理，无需手动控制；对于堆来说，分配和释放都是由程序员控制的。 
2. 空间大小：总体来说，栈的空间是要小于堆的。堆内存几乎是没有什么限制的；但是对于栈来讲，一般是有一定的空间大小的。 
3. 碎片问题：对于堆来讲，由于分配和释放是由程序员控制的（利用new/delete 或 malloc/free），频繁的操作势必会造成**内存空间的不连续**，从而造成大量的内存碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的数据结构，在某一数据弹出之前，它之前的所有数据都已经弹出。 
4. 生长方向：对于堆来讲，生长方向是向上的，也就是沿着内存地址增加的方向，对于栈来讲，它的生长方式是向下的，也就是沿着内存地址减小的方向增长。
5. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器实现的，无需我们手工实现。
6. 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率很高。堆则是 C/C++ 函数提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率要比栈底的多。

### 虚拟内存

存在意义：物理内存有限，给进程营造内存充足的错觉，便于程序调度；如果直接操作物理内存会不安全

### 分段和分页

1. 分段
   将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，实现了离散分配。分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
2. 分页
   用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。分页主要用于实现虚拟内存，从而获得更大的地址空间。
3. 段页式
   页式存储管理能有效地提高内存利用率（解决内存碎片），而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，就形成了段页式存储管理方式。
   段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，为了实现从逻辑地址到物理地址的转换，系统中需要同时配置段表和页表，利用段表和页表进行从用户地址空间到物理内存空间的映射。

系统为每一个进程建立一张段表，每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。

### 建立socket连接涉及哪些系统调用

1. 创建socket，返回socket的fd: `int socket(int __domain, int __type, int __protocol)`
2. 命名socket，fd上绑定IP：`int bind(int __fd, const sockaddr *__addr, socklen_t __len)`
3. 开始监听：`int listen(int __fd, int __n)`
4. 发起连接和接受连接
    - 客户端发起连接：`int connect(int __fd, const sockaddr *__addr, socklen_t __len)`\
    - 服务端接受连接，产生一个新的fd表示连接：`int accept(int __fd, sockaddr *__restrict__ __addr, socklen_t *__restrict__ __addr_len)`

5. 收发数据（以下是基础的读写，Linux还有一些高级IO函数）
    - 发送数据：`ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)`
    - 接受数据：`ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)`
6. 关闭连接（监听fd也需要关闭）：`int close(int __fd)`

### IO复用

传统的多进程并发模型 ：每进来一个新的I/O流会分配一个新的进程管理。

但是这样不适合高并发的场景，因此引入多路IO复用：用单个线程，同时记录跟踪多个I/O流(sock)的状态，来同时管理多个I/O流。每个IO流（socket）就是一个客户连接。

|            | select             | poll             | epoll                                             |
| :--------- | :----------------- | :--------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无上限           | 无上限                                            |
| fd拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询：O(n)         | 轮询：O(n)       | 回调：O(1)                                        |

## MySQL

### MVCC如何实现的

InnoDB用事务版本号，行记录中的隐藏列和Undo Log实现。

- **事务版本号**：每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。
- **行记录的隐藏列**
  - row_id :隐藏的行 ID ,用来生成默认的聚集索引。
  - trx_id: 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。
  - roll_ptr:回滚指针，指向这个记录的 Undo Log 信息。
- **Undo Log**：数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找。

### 缓存击穿、穿透、雪崩

**缓存击穿**：当一份访问量非常大的热点数据缓存失效的瞬间，大量的请求直达存储层，导致服务崩溃。 缓存击穿可以通过热点数据不设置过期时间来解决，这样就不会出现上述的问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。

**缓存穿透**：缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决：

1. 缓存无效key
2. 布隆过滤器：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

**缓存雪崩**：实际上，缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

### 隔离级别

- 未提交读：脏读问题。
- 已提交读：不可重复读问题。加读写锁解决上一个问题。
- 可重复读（InnodDB默认级别）：幻读问题。
- 可串行化 ：InnoDB在可重复读的级别下使用Next-Key Lock的锁算法，因此避免了幻读的产生。

### 主从复制

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。 
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。 
3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。 

复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。

### Redis和数据库如何保证双写一致性

先更新数据库，再删除缓存。首先删除缓存比重写缓存好，因为简单。如果反过来先删缓存的话，这是并发的读请求会从数据库中读到旧数据。先更新数据库，再删除缓存，影响较小。

## C++

### 多态

- 静态多态：由**编译器**在**编译期**间完成的，编译器会根据实参类型来选择调用合适的函数。静态多态有函数重载、运算符重载、泛型编程等。
- 动态多态：程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。

### 虚函数

当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储类虚函数指针的数据结构， 虚函数表是由编译器自动生成与维护的。virtual 成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时, vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。

### C++11新特性

static_assert 编译时断言；新增加类型 long long ，unsigned long long，char16_t，char32_t，原始字符串；auto；decltype；委托构造函数；constexpr；模板别名；alignas；alignof；原子操作库；nullptr；显示转换运算符；继承构造函数；变参数模板；列表初始化；右值引用；Lambda 表达式；override、final；unique_ptr、shared_ptr；initializer_list；array、unordered_map、unordered_set；线程支持库

### STL容器

1. 序列式容器 array、vector、deque、list、forward_list 
2. 关联式容器 map、multimap、set、multiset 
3. 无序关联式容器 unordered_map、unordered_multimap、unordered_set、unordered_multiset 
4. 容器适配器 stack、queue、priority_queue

### new的原理和malloc的区别

new 的实现原理： 如果是简单类型，则直接调用 operator new()，在 operator new() 函数中会调用 malloc() 函数，如果调用 malloc() 失败会调用 _callnewh()，如果 _callnewh() 返回 0 则抛出 bac_alloc 异常，返回非零则继续分配内存。 如果是复杂类型，先调用 operator new()函数，然后在分配的内存上调用构造函数。

区别：

- new 是操作符，而 malloc 是函数； 

- 使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸；
- new 分配失败的时候会直接抛出异常，malloc 分配失败会返回 NULL； 
- 对于非简单类型，new 在分配内存后，会调用构造函数，而 malloc 不会； 
- new 分配成功后会返回对应类型的指针，而 malloc 分配成功后会返回 void * 类型； 
- malloc 可以分配任意字节，new 只能分配实例所占内存的整数倍数大小；
- new 可以被重载，而 malloc 不能被重载；
- 使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充，new 没有这样直观的配套设施来扩充内存。
- new 操作符从自由存储区上分配内存空间，而 malloc 从堆上动态分配内存；

### 指针和引用的区别

1. 定义和性质不同。指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。指针定义格式为：数据类型 *；而引用的定义格式为：数据类型 &
2. 引用不可以为空，当被创建的时候必须初始化，而指针变量可以是空值，在任何时候初始化； 
3. 指针可以有多级，但引用只能是一级； 
4. 引用使用时无需解引用（*），指针需要解引用； 
5. 指针变量的值可以是 NULL，而引用的值不可以为 NULL； 
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了； 
7. sizeof 引用得到的是所指向的变量（对象）的大小，而 sizeof 指针得到的是指针变量本身的大小； 
8. 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本； 

### 红黑树

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

### 四种类型转换

1. static_cast 静态转换：用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int。这种转换的安全性也要开发人员来保证 
2. dynamic_cast 动态转换：dynamic_cast 主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全
3. const_cast 常量转换：该运算符用来修改类型的const属性，常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象。注意:不能直接对非指针和非引用的变量使用 const_cast 操作符 
4. reinterpret_cast 重新解释转换：是最不安全的一种转换机制，最有可能出问。主要用于将一种数据类型从一种类型转换为另一种类型，它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针

### C++程序的内存分布

1、栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的数据结构中的栈，先进后出。

2、堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放

4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放

5、程序代码区(text)—存放函数体的二进制代码。

### C++从代码到可执行程序经历了什么

1. 预编译
2. 编译
3. 汇编
4. 链接

## Java

### 如何保证线程安全

常见的三种，按照资源占用由轻到重

1. **原子类**。JDK1.5开始提供`java.util.concurrent.atomic`包，提供原子操作类。包中一共17个类，可归纳为4种原子更新方式：原子更新基本类型、引用类型、属性、数组。无论哪种类型，都遵循**比较和替换**原则，即要更新的值是否等于期望值，如果是才更新。即CAS思想：CAS有三个参数，当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。
2. **volatile**：volatile是轻量级的synchronized，保证共享变量的可见性。可见性问题由处理器核心的缓存导致，处理器如果从缓存中读取变量，可能获取不到内存中的最新版本。volatile的内存语义为，当写一个volatile变量时，该线程的本地内存会被置为无效，迫使线程从主内存中读取。
3. **synchronized**：以上两种方式只能保证单个共享变量的安全，但是锁可以保证临界区内多个共享变量。synchronized是早期API，没考虑超时机制、非阻塞形式、多个条件变量等，因此JDK1.5加入了**Lock接口**，支持以上。
4. 其他：Semaphore，信号量；CountDownLatch，允许一个或多个线程等待其他线程操作完毕；CyclicBarrier，让一组线程在一个地方同步；ThreadLocal本地存储，不使用共享变量。

### AOP

### HashMap

JDK8之前是数组+链表，之后是数组+链表+红黑树。相同哈希值的元素组成链表，长度超过8会转为红黑树。负载因子达到0.75时扩容。

### 垃圾回收

### 多线程

#### 线程池的意义

1. 创建/销毁线程需要消耗系统资源，线程池可以**复用已创建的线程**。

2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）

3. 可以对线程做统一管理。

## 附录

### HTTP状态码

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

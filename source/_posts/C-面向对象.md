---
title: C++面向对象
date: 2022-02-11 22:00:46
tags: C++
categories: C++
---
<h1>面向对象</h1>



# 复制控制

一般来说，需要析构函数的场景会比需要拷贝构造或拷贝赋值运算符更容易识别。如果一个类需要析构函数，那么它大概率需要拷贝赋值运算符和拷贝构造函数。

如果一个类需要拷贝构造，那么它大概率需要拷贝赋值运算符。反之亦然。

## 构造函数

### 默认构造函数

只有当类没有声明**任何**构造函数时，编译器才会自动生成一个**默认构造函数**，其初始化类成员的规则：

- 优先使用类内初始值
- 
- 没有初始值的成员将被默认初始化（undefined）。这样很危险。

`= default`加在函数列表后，可以要求编译器生成默认构造函数。

### 委托构造函数

一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说把它的一些职责委托给了其他构造函数。

### 转换构造函数

如果构造函数只接收一个实参，则它实际上定义了转换为此类类型的隐式转换机制。

### 拷贝构造函数

一般第一个参数是该类型的const引用，以及一些有默认值的参数，总之保证这个构造函数只需要一个同类对象就可以调用。

由于需要被隐式调用，所以**不能是**`explicit`。

`string s1(s2);`也属于**直接初始化**，即让编译器根据参数类型匹配构造函数。使用赋值符号才是拷贝初始化。
编译器可以（但不是必须）略过拷贝/移动构造函数，直接创建对象（使用直接初始化），但是在这个程序点上，拷贝/移动构造函数必须存在且可以访问。

拷贝初始化发生的时机：

- 用`=`定义变量

- 将一个对象作为实参传递给一个非引用类型的形参。
- 从一个返回类型为费引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素，或一个聚合类中的成员
- 容器初始化，`push`，`insert`时

### 默认拷贝构造函数

与默认构造函数不同，哪怕有其他构造函数，编译器还是会默认生成一份默认拷贝构造。其作用是将对象的成员悉数拷贝。

具体拷贝操作取决的成员的类型：

- 对于`class`成员，调用其拷贝构造函数。
- 内置类型直接拷贝
- 数组：逐一拷贝元素

### 拷贝赋值符号

重载`=`符号，左操作符隐式传为`this`，一般要求返回一个左操作符的引用。

默认生成的拷贝赋值符号，会将所有non-static成员复制，数组成员会被全部复制。

在重载拷贝赋值时，一定要注意处理的顺序，避免在对象自我赋值的时候出错。要先将右操作符复制一份，再释放左操作数。

### swap

如果一个类有自己的·swap·时，调用std::swap可能会出错。

自定义的·swap·可以帮助重载拷贝赋值。将右操作数设置为传值，这样形参会被复制，然后再赋值给左操作符。这样做会很安全，如果在形参复制阶段出现问题，一定发生在swap之前。

### 避免拷贝，=delete

大部分的类需要显式的或者隐式的默认构造，拷贝构造和拷贝赋值运算。但是有一些类，必须被定义为无法拷贝或者赋值，比如`iostream`类。如果需要避免生成默认的以上函数，可以使用`=delete`。

`=default`可以用在类内或者类外，在类外再次使用可以让默认函数不是`inline`。但是`=delete`不同，只能用在首次定义的时候。

`=default`只能用在编译器可以生成默认版本的函数上，但是=delete可以用在任何函数上。

注意：不应该删除析构函数，因为编译器不允许创建一个无法销毁的对象。在第631页有许多关于`=delete`的使用规则，但他们的原则都是基于这个。

早期C++用`private`控制可见性来达到类似效果。

## 析构函数

在构造函数中，在参数列表和函数体中间有一块初始化部分。构造函数会先执行成员的初始化，再执行构造函数体。析构函数则是相反，先执行函数体，再将所有成员析构，后一步是隐式的。

由于释放成员的原理是调用成员的析构函数，因此析构行为取决于成员的类型和他们的析构函数。比如一个内置指针就只会释放本身，不会将指向的内存空间一并释放。

一般来说，一个对象离开了作用域就会被析构，但是对象的指针或者引用失效不会导致本身被析构。

### 默认析构函数

默认析构函数的函数体是**空的**，相当于是直接调用成员的析构，而不做更多操作。



## 移动构造函数

当我们在使用拷贝赋值时，会先把数据复制一份，然后再拷贝，但是这个复制其实是多余的。赋值可以将右操作符的内存直接搬到左操作符上。标准库引入了两种机制，为了避免**不必要的拷贝**。

1. 移动构造函数：具体实现未公开，作用是将资源从给定对象**移动**而不是拷贝到正在创建的对象。标准库保证**移后源**仍是有效的，可析构的状态。目前可以理解为拷贝了指针，而不是拷贝的整块内存。
2. `move`标准库函数：在`utility`头中，在用`allocator`的`construct`时必须调用`move`来表示希望使用移动构造函数，如果漏掉了就会变回拷贝构造函数。其次，通常不会为`move`提供一个`using`声明，**原因待补充**，因此调用时应该使用`std::move`。

在编写自定义的移动构造函数时，要在形参列表和函数体之间加上`noexcept`，因为移动操作不分配新内存，所以不应该抛出异常（移动赋值运算符同理）。如果我们不声明，编译器会为了可能存在的异常做额外的工作。同时，允许函数抛出异常说明如果异常发生时，我希望调用者的状态恢复到调用前的状态，而不是被改变。比如`vector`的`push_back`操作，如果分配新的空间失败，会抛出异常，旧元素还在原地没变，只需要将申请的内存释放即可。但是移动操作会改变对象本身的状态，如果在操作到中途时发生问题，无法回到最初的状态。因此，除非`vector`知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存时就不该使用移动构造函数。如果希望它使用，则必须显式地告诉编译器，我们的移动构造函数是安全的。

移后源对象在函数体中应该将成员指针都设为`nullptr`，否则之后在析构的时候，会把所指向的内存（现在已经被移动到被赋值对象中）也析构掉。

### 默认的移动操作

编译器不会为已经有自己的拷贝构造等大三样的类合成移动操作。只有当一个类没有定义任何**自定义**的拷贝控制成员，且类的美和**非static**成员都**可以移动**时，才会为它合成默认的移动构造函数或移动赋值运算符。`build-in`类型**默认可以移动**。

与拷贝操作不同，移动操作**不会**隐式定义为`delete`。但是，如果显式地要求生成`=default`的移动操作，且编译器不能移动所有成员时，移动操作会被定义为`=delete`。

**注意**：定义了一个移动构造函数或移动赋值运算符的类，必须也定义自己的拷贝操作，否则这些成员默认被定义为是`=delete`的。

### 函数匹配

一个类如果既有拷贝构造又有移动构造，那么具体调用那么符合函数匹配原则，匹配参数最接近的。

如果类仅有拷贝构造，但是试图调用move，由于`Type&&`可以转换为`const Type&`，因此还是会调用拷贝构造函数。一般情况下，拷贝构造代替移动构造是安全的。

成员函数也可以同时定义拷贝和移动两种版本，从而提升性能：

```c++
void push_back(const &X);	//拷贝版本：绑定到任意类型的X
void push_back(X&&;)			//移动版本：只能绑定到类型X的可修改的右值
```

右值引用会精确匹配到第二种函数上，如果无法匹配才会使用第一种性能较差的成员。

### 移动迭代器

这是一种适配器，改变给定迭代器的**解引用运算符**的行为来适配，让解引用得到右值引用。通过标准库的`move_move_iterator`将一个普通迭代器转换为移动迭代器。

注意：一定要在确定原容器的元素不再使用的前提下使用。

### 引用限定符

参数列表后面可以放引用限定符`&`或`&&`，表示该方法或者运算符只能由左值或者右值来调用（`this`必须是左值还是右值）。

引用限定符只能出现在`const`之后。

一个成员函数是否有const是两个不同的重载函数，有无引用限定也是类似。

如果一个函数有引用限定符，那么所有具有相同参数列表的重载版本都要有引用限定符。

## move语义

有些时候，对象在被复制后就马上被销毁了，这种情况下，**移动**它会有更好的性能。还有些情况下，对象不应该被复制，比如IO。

容器，`string`，`shared_ptr支持复制和移动；IO和`unique_ptr`只支持移动。

### 右值引用

右值引用必须绑定在右值上，使用的符号是`&&`而不是`&`。由于右值是马上要被销毁的，所以可以**移动**右值引用。

左值表示的是对象的**身份**，右值表示对象的**值**。左值拥有持久的状态，而右值要么是字面值常量，要么是表达式求值过程中创建的临时独享。

之前学的常规引用可以看做**左值引用**，我们不能把左值引用绑定到要求转换的表达式，字面常量或返回右值的表达式。右值引用则相反，可以绑定到这些表达式上，但是不能直接绑定到左值上。

- 返回左值的表达式：返回左值引用的函数，赋值、下标、解引用和前置递增、递减运算符。

- 返回右值的表达式：返回非引用类型的函数，算术、关系、位以及后置递增、递减运算符。

左值引用不能直接绑定在右值上，但是可以将一个`const`的左值引用绑定到右值上。

由于右值引用只能绑定到临时对象上，可以得出：

- 引用对象马上要销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用对象的资源。

单独的变量作为表达式时，是左值，因此右值引用不能绑定到变量上，也不能绑定到一个右值引用类型的变量上。

注意：右值引用只是说绑定的对象是右值，绑定完后就会消失，但是右值引用本身是一种**左值**，因为它本身不会马上消失，在作用域内可以继续使用。

### std::move

右值引用不能直接绑定在左值上，但是可以使用`utility`中的`move`函数，告诉编译器：我有一个左值，但是我希望像一个右值一样处理它。这相当于成果：除了对该变量的赋值和销毁它之外，我将不再使用它，但是它必须是**可析构**，**有效的** 的状态。该变量在移动过后，可以对它赋值，或者销毁它，但是不能使用它，因为它的值已经不确定了。

标准库中move的定义：

```C++
template <typename T>
typename remove_reference<T>::type&& move(T&& t){
  return static_cast<typename remove_reference<T>::type&&>(t);
}
```

move()的参数`T&&`是一个指向模板类型参数的**右值引用**，通过**引用折叠**，此参数可以与任何类型的实参匹配。

#### 用右值调用move

如果move()的参数是一个**右值**，如`std::move(string("Hello"));`，那么函数运行如下：

- 推断出T的类型为`string`
- 因此，`remove_reference`用`string`进行实例化
- `remove_reference<string>::type`是`string`
- `move`的返回类型是`string&&`

- `move`的函数参数`t`类型为`string&&`

因此，相当于这个调用实例化`move<string>`，即函数`string&& move(string &&t)`。由于t的类型和`static_cast`的类型一直，所以`static_cast`不需要做什么。

#### 用左值调用move

如果move()的参数是一个**左值**，如`std::move(str));`，那么函数运行如下：

- 推断出T的类型为`string&`
- 因此，`remove_reference`用`string&`进行实例化
- `remove_reference<string&>::type`是`string`
- `move`的返回类型是`string&&`

- `move`的函数参数`t`类型为`string& &&`，会折叠为`string&`

因此，这个调用实例化`move<string&>`，即函数`string&& move(string &t)`。这正是我们想要的结果，将一个左值转换为右值，用`static_case<string&&>(t)`将`string&`转换为`string&&`。

通常`static_cast`只能用于其他合法的类型转换，但是允许将左值显式地转换为右值引用是`static_cast`的一个特例。一方面因为这种转换是安全的，另一方面C++通过强制使用`static_cast`来阻止意外地进行这种转换。





## 访问控制

### class和struct的区别

唯一区别就是默认的访问权限：class默认public，struct默认private。

### 用户的身份

在面向对象和继承的场景下，应该考虑2种用户：

- 普通用户：使用类的对象，只能访问类的公有成员。
- 实现者：编写类的成员和友元，这两者能同时访问类的公有和私有部分。
- 派生类：基类把它希望派生类能够使用的部分声明成`protect`的，普通用户不能访问`protect`成员，派生类及其友元**不能访问私有成员**。

### 友元

类可以允许其他类或函数访问它的非`public`成员，只要另其它类或函数成为它的**友元**：

```c++
friend return_type namespace::func();
```

友元只能出现在类定义的内部，但是在类内的具体位置不限。一般来说，最好在类定义开始或结束前的位置集中声明友元，并且一般把友元的声明和类本身放置在同一个头文件中。

友元的声明仅仅指定了访问权限，并不是函数声明。

#### 友元和继承

友元的关系没有传递性，朋友的朋友不是朋友。重载函数必须分别声明友元。

基类的友元在访问派生类时没有特权，反过来，派生类友元也不能随意访问基类成员。但是**每个类负责自己成员的访问权限**，基类的友元哪怕是访问子类中的基类成员，也是可以的。

### 派生访问说明符

派生访问说明符对**派生类的成员**（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与**基类中的访问说明符有关**。

派生访问说明符的目的是控制派生类用户（包括子类的子类）对**基类成员**的访问权限。

- 派生访问说明符影响：子类的对象能否使用父类的成员
- 基类中的访问说明符：子类的成员能否使用父类的成员

可以这么理解，如果派生访问说明符是`private`，那么在代码中可能这样展示：

```C++
struct Priv_Derv : private Base{}
```

这样的意思就是，在子类中如果需要调用父类的成员，那么是通过`Base.member`来调用，但是这时的`Base`是`private`，所以不允许。

### 对自身的访问说明符

基类应该将接口成员声明为`public`，将属于其实现的部分分为2组：

- 可供派生类访问的：应声明为`protect`。
- 只能由基类和基类友元访问的：声明为`private`。

在对自身成员的访问说明符中，`protect`的级别介于`public`和`private`之间，用于希望与派生类分享，但是不给其他公共访问的成员。注意这是一个单向的关系，只是父类分享**自己的**成员给子类，子类自己的`protect`成员基类无法访问。

### 派生类向基类转换的可访问性

派生类向基类的转换能否成功，由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假设D继承自B：

- 只有当D`public`继承B时，**用户代码**才能使用转换；如果D继承B的方式是`protect`或`private`，则用户代码不能使用。
- 不管D以什么方式继承B，D的**成员函数和友元**都能使用转换；派生类向其**直接基类**的类型转换对于派生类的**成员函数和友元**来说**永远**可访问。
- 如果D继承B的方式是`public`或`protect`，D的派生类的**成员和友元**可以使用转换；如果是`private`则不行。

总体上将，对于代码中某个给定节点来说，如果基类的公有成员是可访问的，则派生类想基类的类型转换也是可访问的；反之不行。

# 运算符重载

重载的运算符本质是具有**特殊名字**的函数，名字有关键字`operator`和后面的符号组成。如果重载运算符时成员函数的话，第一个（左侧）运算对象会**隐式**绑定为`this`指针。

作用与内置类型的运算符无法重载。

由于重载运算符本质上是函数调用，所以会是去原有的运算优先级，比如`&&`和`||`会是去**短路**的性质，所以一般来说，不应该重载逗号，取地址，逻辑与和逻辑或运算符。

除了一些别无选择的情况，运算符必须是成员，其他情况下运算符作为普通函数更好：

- 赋值`=`，下标`[]`，调用`()`，和成员访问箭头`->`**必须是**成员。
- 复合运算符一般来说是成员，不必须。
- 改变对象状态的运算符，或者与给定类型密切相关的运算符，如迭代器的递增，递减和解引用，一般是成员。
- 具有**对称性**的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是非成员函数。

通常输出运算符应该负责**打印**而非**控制格式**，不应该打印换行符。

输入运算符必须要处理可能出现的输入异常，但是输出不用。
在数据读入过程中，可能在一步步初始化对象，如果中途出现了输入异常，必须要有相应的处理机制，避免出现`undefined`，比如把剩余的变量值初始化。

如果类同时定义了算术运算符，和对应的复合赋值运算符，通常应该用复合运算符来实现算术运算符。用`+=`来实现`+`。

如果存在唯一一种逻辑合理的`<`，则应该考虑为这个类定义`<`。如果类同时还有`==`，当且仅当`<`的定义和`==`不冲突时才定义。

赋值运算符必须是成员函数，复合赋值运算符通常应该是成员函数，都应该返回左侧运算类型的引用。

下标运算符必须是成员函数。如果一个类应该有下标运算符，那么应该定义2种版本：返回常量引用和非常量引用。

递增和递减运算符必须是成员函数。必须同时定义前置和后置版本。为了区分，后置版本接受额外的（不适用）的`int`形参，没有变量名，编译器会提供一个0作为实参。如果要显式调用，则要自己传入0。

成员访问箭头必须是成员函数，解引用不强制但一般是成员函数。重载箭头时，箭头获取成员一定会发生。

函数调用符`()`必须是成员函数。函数对象可以有自己的成员，以此作为自定义。经常用来作为泛型算法的参数。

## 类型转换运算符

```C++
operator type() const;
```

一个类型转换函数必须是成员函数，没有返回类型，形参列表为空，函数类型通常为`const`，函数名即为想要转换成为的类型。

在实践中，类很少提供转换运算符。在隐式转换发生时，用户往往觉得奇怪而不是被帮助了。尤其是对于内置算术类型的转化，因为内置算术类型之间有很丰富的转换，容易让人迷惑。比如在早期标准中对一个cin使用`cin << 42`，cin会被转换成`bool`然后执行左移。

为了解决上述问题，引入了`explicit`，需要用`static_cast`或者构造转换进行显式转换。`bool`是一个例外，因为经常需要那里作为判断条件，所以还是会隐式转换。

## 歧义

1. A中有接收B类型的转换构造函数，B中有转换为A的转换运算符。
2. 定义了多个转换规则，这些转化涉及到的类型本身可以通过其他类型转换联系起来。最典型的就是算术转换符，对于一个给定的类，最好只定义最多一个与算术类型有关的转换规则。

注意：无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。

函数接收参数的时候可以有一次转换，如果2个重载函数的参数要求的都不是参数传入的，且参数转换的级别一致，也会有二义性。

对于一个运算符来说，成员函数、非成员函数、内置运算符，都有可能被调用。

# 继承

子类可以隐式转换成父类，因为子类其实包含了父类完整的功能。因此，子类对象或引用可以用在需要**父类引用**的地方，子类对象的指针可以用在需要**父类指针**的地方。

注意，对象本身的静态类型**不能改变**，只有**指针**和**引用**才有隐式转换。如果基类中含有虚函数，可以使用`dynamic_cast`请求类型转换，检查安全后执行。如果确定转换是安全的，可以使用`static_cast`来强制覆盖编译器的检查工作。

用一个子类对象作为父类对象初始化或赋值时，只有该子类对象中的基类部分会被拷贝、移动或赋值，子类部分会被忽略。因为这些本质上都是**函数调用**，传入的隐式参数`this的类型决定了调用的是谁的函数，如果参数要求的父类，那么只会调用父类的函数。

总结：

1. 从派生类向基类的类型转换只对指针或者引用有效。
2. 基类向派生类不存在隐式类型转换。
3. 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而不可行。



父类希望每个子类有自己的专属的实现方式。

派生类列表：`class Type: public Base{}`。格式为在类名后面有一个冒号，冒号之后是所有的基类，基类前可以有访问说明符。用上了`public`之后，子类可以完全代替父类。但是注意，派生类声明的时候**不需要**冒号后面的东西。

作为基类，必须已经被定义，不能只是声明。因为子类中需要包含父类，需要知道父类有什么数据和功能。

如果不希望被继承，需要在冒号前加`final`关键字。

每个子类只能初始化他们的直接基类，间接基类由他们对应的直接基类来负责，在构造时行程一个链。

## 虚函数

子类必须在内部对所有重新定义的虚函数进行声明。

与虚函数一起发挥作用的是**动态绑定**，指被调用的虚函数时与绑定到**指针或引用**上的对象的**动态类型**想匹配的那个。强调，运行时决定；只对指针和引用生效，也只有在这种情况下， 对象的动态类型**才有可能**和静态类型不同。为了保持多态性，只有虚函数的返回值是自身类型的指针或者引用时，返回值也具有多态性（只要允许隐式转换）。

### 虚函数的覆盖

继承的虚函数天然就是`virtual`的。派生类可以在它覆盖的函数前也使用`virtual`，表示这个派生类仍然可能被继承，函数可能会被覆盖。

覆盖要求子类的函数与要覆盖的父类虚函数不仅函数名一致，形参列表也要一致，如果不一致就会被编译器认为是一个新的函数。典型错误就是以为覆盖了虚函数，但实际上因参数不一致而并没有覆盖。

C++11允许派生类显式注明它使用某个成员函数覆盖了它继承的虚函数，要在形参列表、`const`关键词、引用限定符`&或&&`后面加上关键词`override`。这样可以增加可读性，方便查错，如果该函数无法覆盖已存在的虚函数，编译器就会报错。

如果把一个函数设为`final`则可以避免被覆盖。

虚函数也可以有默认实参，并且实参的版本取决于多态性，因此实践中尽量基类和派生类中的默认实参一致。

### 虚函数的回避

如果需要指定某个版本的虚函数，则要在函数名前带着类名和`::`。

通常情况下，只有成员函数（或友元）中的代码才需要用作用域运算符来会比虚函数的机制。

最典型的场景：基类虚函数中进行了一些前置操作，子类虚函数需要先调用父类的虚函数（类似于Java中调用`super`的方法），在其基础上完成自己进一步的操作。如果不回避虚函数机制，则因多态性不会调用到基类的方法，而是调用子类的方法，导致**无限递归**。

### 纯虚函数和抽象基类

在函数体的位置写`=0`即可声明为纯虚函数，不需要定义，表示这个函数没有意思，必须要覆盖才可以调用。

含有纯虚函数的类是**抽象基类**，该类型无法实例化，类似于Java中的`interface`。

## 虚析构函数

每个基类都应该有虚析构函数。

一个类如果定义了析构函数，即使是编译器生成的默认版本，编译器也不会为这个类合成移动操作。移动操作会去使用默认的拷贝构造。

## 改变个别成员的可访问性

如果一个派生类是`private`继承，那么所有基类成员到他这里就都变成了私有成员，他的派生类无法访问。可以使用`using`来改变可访问性，用法是将基类的成员再声明一遍：`using Base:: x;`，但是注意，派生类只能这样声明他本身能访问到的基类成员。

## 删除的拷贝控制

如果基类有删除的或者无法访问的拷贝控制函数，那么子类的相关函数（需要调用父类的）会被设置为`delete`。也就是说编译器不会为已经删除的函数再合成，也不会让子类只完成部分的操作。

实际编程中，如果基类没有默认、拷贝或移动构造函数，一般派生类也不会定义。

## 继承构造函数

类不能继承默认、拷贝和移动构造函数，只能由编译器自动生成。

如果想要继承，需要用`using`声明语句，让编译器来给派生类生成与基类一样的构造函数：

```C++
derived(parms) : base(args){}
```

`using`生成的构造函数不会改变访问级别；不能改变`explicit`和`constexpr`；不能继承默认实参，而是会获得多个版本的构造函数，每个构造函数分别省略一个含有默认实参的形参。

继承的构造函数不会作为用户自定义的构造函数，所以编译器还是会生成合成函数。

# 其他

## 成员函数与inline

所有的成员函数会被自动标记为`inline`，但是`inline`只是一种建议，最终决定权在于编译器。

## this

类似于Python中成员函数的第一个参数必须是`self`那样，任何对成员函数的调用都会将对象隐式传入为`this`，并且在成员函数内部使用成员变量时，也隐式使用了`this`。`this`是一个const指针。

## 重载和覆盖

重载是对于在同一作用域声明的函数而言的。内部作用域声明的成员，会直接覆盖而不是重载外部的成员，既是形参列表不一致。

因为在较小的作用域中查找时，编译器能直接找到同名的函数，并认为这就是自己想要的，不再继续向更外层的作用域查找。


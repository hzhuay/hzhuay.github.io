---
title: 内存管理
date: 2022-02-11 22:01:18
tags: C++
categories: C++
---
<h1>内存管理</h1>

- 静态内存：局部静态变量，类静态成员，全局变量
- 栈内存：函数内局部变量
- 堆（自由空间）：动态分配的内存（new和delete）



# 智能指针

## new

`new`会返回一个指针，指向动态分配的内存。

如果`new`后面只跟了类型，如`new int`，那么对象是**default initialized**：内置类型和组合类型的值是**未定义的**，类类型使用**默认构造函数**。

如果需要**value initialized**，需要在类型后加上空括号，如`new int()`。因此，应该**尽量使用**带括号的版本，因为类类型无论如何都会调用默认构造函数，但是让内置类型的值未定义是**危险**的。

对于const，必须要让对象被初始化过，因此内置类型必须有括号。尽管const对象不能修改，但是其本身是可以销毁的。

编译器可以用initializer的类型来推断应该new什么类型：`auto p = new auto(obj);`

如果无法分配内存，new会抛出`bad_alloc`异常。如果想要忽略异常，可以使用`placement new`：`int *p = new (nothrow) int;`。这种表达式相当于传递了参数给`new`，让其在分配失败时返回一个`nullptr`。

### 动态数组

如果想要new很多对象，就要在new时加上中括号：`int *p = new int[get_size()];`。还可以使用别名：

```
typedef int arrT[42];
int *p = new arrT;
```

尽管叫动态数组，但是其实new出来的不是数组类型，仅仅只是指向一块连续内存的头部的指针，而不是像array类型那样，数组大小也是类型的一部分。

动态数组的初始化情况和new一个对象是一样的，如果不带括号的话，内置类型会是未定义。除了带括号和不带括号两种初始化，还可以用列表初始化：

```C++
int *p = new int[10]{0,1,2,3,4,5,6,7,8,9};
```

当列表内的元素不够时，剩下的元素会值初始化；如果元素过多，则new失败，抛出`bad_array_new_length`异常。

动态数组的长度可以为0，不会报错，得到的指针类似于`end`迭代器，本身不应该解引用。

## delete

能用来`delete`的必须是能`new`出来的东西，也就是指向动态分配内存的指针或者`nullptr`。`delete`一个普通的指针，或者把同一个动态分配指针`delete`2次，都是**未定义**操作，编译器不会察觉。

返回动态分配指针的函数，相当于把`delete`的职责交给了调用者。

对于动态数组的`delete`，必须要带上`delete [] p;`，否则只有数组的第一个会被delete。

### 常见错误

几种常见的使用`new`的错误：

1. 忘记`delete`，也就是俗称的“内存泄漏”
2. 在`delete`后仍然使用
3. `delete`同一块内存2次。

这些问题都可以通过使用**智能指针**解决。

### 空悬指针

当`delete`一个指针后，指针已经失效了，但是在很多机器中，指针仍然保存了地址，哪怕那块地址已经被释放了，这样就成了**空悬指针**，这种指针的隐患等同于为**未初始化**的指针。

### 多指针指向同一处的问题

动态内存的一个基本问题就是多个指针指向相同的内存。任意其中一个`delete`之后，其他指针都指向了一片非法的内存。

## shared_ptr

`shared_ptr`的智能之处在于无论是赋值还是复制，每个`shared_ptr`内部都会有个引用计数（计数器），记录了还有多少个其他`shared_ptr`指向相同的对象。当一个对象没有被引用时，`shared_ptr`就会自动销毁该对象（调用该对象的析构函数）。

当一个局部的`shared_ptr`离开作用域时就会被销毁，相应的计数器就会减一。

### 初始化

`shared_ptr`有三种获得方法：

- `make_shared<T>(args)`会使用参数自动创建一个对象，并返回一个指向它的指针。这是最**安全**的方法。
- `shared_ptr<T>p(q)`用另一个`shared_ptr`来构造一个指针
- `p = q` 用另一个`shared_ptr`来赋值

可以用`auto`来简化语句。

`shared_ptr<T> p1;`这样默认初始化得到的智能指针，内部持有的是`nullptr`。**注意**：智能指针内部持有的是`T*`的指针。

与动态内存结合：`shared_ptr<int> p(new int(42));`。我们不能**隐式**地将普通指针变成智能指针，而是必须用初始化。

由于智能指针默认用`delete`来释放管理的对象，因此用来初始化智能指针的指针必须是**动态分配**的。如果我们想要让它指向其他类型的资源，则需要传入自定义的`deleter`来规定资源如何安全释放。



### 不要混用普通指针和智能指针

以下是我的猜测：智能指针如果使用`make_shared`方法创建，那么内部是调用了`new`的。如果是用构造器的话，会判断初始器的类型，从而有不同的操作。

`shared_ptr`生效的前提是不能让引用计数失效。`shared_ptr`能够正确地协调对象的析构，仅限于其自身的拷贝。

之所以推荐使用`make_shared`而不是先new在初始化，就是因为希望将分配内存和绑定操作合并，这样就可以避免无意中将一块内存绑定到多个**独立创建**（不是拷贝）的`shared_ptr`上。如果先new了一块内存，再用它来独立创建2个`shared_ptr`，每个智能指针都有独立的引用计数，且都为1。无论那个先被释放，都会导致第二个非法。

还有种情况，我们分别给一个普通指针和智能指针用new出来的指针赋值（或初始化），然后加入智能指针先失效，那么就会自动释放动态分配内存，导致普通指针称为空悬指针。当我们把一块内存交个智能指针时，等于我们把内存管理的职责分给了智能指针，那么接下来就不要再使用普通指针指向那块区域了。

### 不要用get去创建别的智能指针

`get()`成员可以得到内置指针，指向智能指针管理的成员。如果我们拿着这个内置指针去创建另一个智能指针，然后这个智能指针销毁了，就会把内存释放，最开始的调用get的智能指针就指向了非法空间了。

### 常见错误

1. 不要用相同的内置指针初始化（或reset）多个智能指针
2. 不要`delete` `get()`返回的指针
3. 不要使用`get()`初始化或`reset`另一个智能指针
4. 如果使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变得无效了。
5. 如果你使用智能指针管理的资源不是new分配的内存，记住传递个它一个删除器

删除器简单来说就是一个函数，所谓初始化参数，规定了该如何释放内存。

## unique_ptr

`release`会返回`unique_ptr`保存的指针，并把`unique_ptr`设为`null`。注意，返回的指针相当于把内存管理的任务交给了程序员。

不支持拷贝或赋值，因为要保证唯一性。仅有一个例外：当`unique_ptr`马上要被销毁时。典型的场景是作为函数的局部变量返回的时候，编译器可以得知这个对象马上就要被销毁了，所以允许拷贝。

`auto_ptr`是早期标准库的产物，它只包含部分`unique_ptr`的特性，尤其是无法再容器中保存`auto_ptr`，也无法作为返回值。因此，尽管它还是标准库的内容，编程时应尽量使用`unique_ptr`。

不同于`shared_ptr`，`unique_ptr`的删除器不因要作为构造器的参数，还要在尖括号中写出类型：

```C++
unique_ptr<objT, delT> p(new objT, fcn);
unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
```

注意，删除器的类型是函数指针，所以还加上*。

### 用智能指针管理动态数组

标准库提供了`unique_ptr`的版本来管理动态数组，提供了比其他两种智能指针更方便的使用，可以直接用下标访问：

```C++
unique_ptr<int[]> up(new int[]);
```

其他两种指针需要先解引用，而且必须传入删除器。

## weak_ptr

`weak_ptr`并不控制对象的声明周期，它只是指向`shared_ptr`所管理的对象，且不会改变引用计数。因此，`weak_ptr`在使用时并不知道指向的对象是否还存在，因此在访问时，需要使用`lock`。如果对象存在，则返回一个`shared_ptr`，如果不存在则返回一个null的`shared_ptr`。经典用法：

```C++
if(shared_ptr<int> np = wp.lock()){ ... }//如果对象不存在，无法进入if
```

# 分配器

`new`以及依赖`new`的智能指针总是将内存分配和构造对象的操作绑定在一起。这样是很方便，但是在某些情况下会导致浪费。比如我现在申请了一个数组，但是我希望元素在需要时再构造，而不是直接全部构造。

`allocator`分配的内存是未构造的。它可以按照类型的大小指定内存，并且可以重用析构过的内存，或将内存还给系统。
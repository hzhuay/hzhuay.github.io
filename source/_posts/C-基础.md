---
title: C++基础
date: 2022-02-11 20:08:34
tags: C++
categories: C++
---

<h1>C/C++基础</h1>

# 1. 字面值
## 1.1. 字符串字面值
字符串字面值常量（string literal），是用一堆双引号包围的字符串序列。它应该被视作某种常量，某种匿名对象。  

因为历史原因和为了与C兼容，C++中的字符串字面值不是string类型，因此对于字符串字面量的操作会产生限制。比如在做字符串相加时，加号两侧至少要有一个运算对象是string。两个字符串字面量无法直接相加。



## 1.2. 字面值常量
- 十进制：20
- 八进制：024
- 十六进制：0x14
八进制和十六进制字面值的类型是能容纳其数值的`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中尺寸最小者。  

严格来说，十进制字面值不会是负数，形如-42的负数之所以会被正确识别，是因为现将42作为字面量，再对结果去负值。  
浮点型字面值表现为小数或者科学计数法，其中指数部分用E或e标识。默认的，浮点型字面值是`double`。  

## 1.3. 布尔字面值
当我们写出`val == true`这样的代码时，如果val不是bool类型，那么编译器不会将val转换为bool类型来比较，而是把`true`转换为1来比较。  
因此，进行比较运算时，除非比较的对象是bool类型，否则不要使用布尔字面值true和false作为运算对象。

# 2. 关于string与C-style字符串
在需要使用字符数组的地方可以使用string，因为有隐式转换，但是反过来不行。C风格字符串不会自动转换为string。  
`c_str()`返回的数组不一定会一直有效，如果想要长期使用，建议拷贝一份。

现代C++程序应该尽量使用vector和迭代器而非内置数组和指针；尽量使用string而非字符数组。

# 3. 输入与输出
## 3.1. endl
`endl`是某种操作符，写入`endl`的效果是结束当前行，并将于设备关联的buffer中的内容flush到设备中。因此不应该把`endl`看做与`\n`等价。

## 3.2. 转义序列**
有2类字符程序员不能直接使用，一类是不可打印的字符，二类是在C++中有特殊含义的字符。这两种字符需要使用转义序列。转义序列除了用反斜杠加字符外，还可以使用泛化的转义序列，形式是在`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1或2或3个八进制数字。  
注意，如果反斜线后面跟着的八进制数字超过3个，只有前三个与`\`构成转义序列。 

## 3.3. >>string与getline的区别
在读取时，string对象会自动忽略开头的空白（空格符，换行符，制表符等），从第一个真正的字符开始，直到下一处空白。  
`getline`会把换行符也读入。  

## 3.4. IO类不能是const
IO对象在读写后会改变自身的状态，所以他们不能是const。

## 3.5. 写操作不会立刻执行
对于计算机来说，CPU运算会比调度打印机快很多，出于效率考量，程序不会在调用打印语句时立刻打印，而是将要打印的内容放入buffer，等时机成熟时一次性调用输出设备。以下几种情况会flush buffer:
- 程序正常退出。在执行`main()`的return时，缓冲区会清空。
- buffer满时，会先清空，再放入新数据。
- 使用`endl`或`flush`这样的操作符。
- 使用`unitbuf`操作符，清空缓冲区。
- 输出流对应的输入流要读取时。因此交互系统一定要把输出流和输入流绑定，这样就能保证需要用户输入的时候，该展示的信息都已经输出了。

## 3.6. 输出调试的弊端
由于上述的性质，可知输出调试未必总是管用。如果程序不是正常退出，那么本该输出的内容可能会停留在缓冲区内，给程序员造成了错误的判断，以为该运行到的输出调试语句没有运行（但其实已经运行了）。

## 3.7. 永远要检查打开文件是否成功

## 3.8. 当一个文件流对象被销毁，close会自动调用。


# 4. 项目组织和文件管理
## 4.1. How to include headers？Use <> or "" ?
包含来自标准库的头文件用`#include<>`，对于不属于标准库的头文件使用`#include""`。

## 4.2. 在头文件中进行函数声明
函数应该在头文件中声明，在源文件中定义。

## 4.3. 多行注释的推荐写法
多行注释的推荐写法是注释内的每行都以一个星号开头。

## 4.4. 命名空间的using声明
如果只需要命名空间内的某个名字：`using _namespace_::_name_;`  
位于头文件的代码一般不应该使用using声明。因为头文件的内容会被拷贝到所有引用它的文件中去，如果使用了using声明，那么每个文件中都有了这个声明，可能导致不经意的名字冲突。

## 4.5. 预处理变量
一般把预处理变量的名字全部大写。 

# 5. 算术类型选择指南
- 当明确知道数值不可能为负时，使用`unsigned`类型。
- 使用`int`或者`long long`执行整数运算。`short`常常太小，`long`一般和`int`一样尺寸。
- 在算术表达式中不要使用`char`或`bool`。`char`在不同的机器上，既可以是有符号的，也可以是无符号的。
- 浮点运算选用`double`，`float`常常精度不够，而且两者计算代价差别不大，甚至某些机器上`double`更快。

# 6. 类型转换注意点
- 非bool的算术值赋值给bool时，0 for false, otherwise true.
- When assigning bool to non-bool, false for 0 and true for 1.
- 当把整数赋值给浮点数时，小数部分记为0。如果整数所占空间超过了浮点类型的容量，精度会有损失。
- 赋值给带符号类型一个超出范围的值时，结果是**未定义的**。



# 7. 为什么标准库中有size_type?
当一个算术表达式中既有`unsigned int`又有`int`时，那个`int`的值会被转换成无符号的值。  
对一个为0的`unsigned int`减1，结果为-1所对应的`unsigned int`值，这是一个非常大的`int`。
`size_type`体现了标准库类型与机器无关的特性。标准库中表示size的类型一般是无符号的，尽量用无符号的整数与size进行比较，因为一个负数会被自动转换为一个很大的无符号整数。  



# 8. 变量定义语句的阅读
在同一条定义语句中，执行顺序从左到右，先已定义的变量值可以用来初始化后定义的其他变量。  

# 9. 列表初始化
C++11的新标准中，花括号初始化普及，被称为列表初始化。当其被用于内置类型的初始化时，如果初始值存在丢失信息的风险，编译器将报错。  
​
在初始化容器时使用花括号，编译器会优先使用列表初始化，如果无法执行，则会尝试用列表中的参数进行其他初始化方式。

# 10. 默认初始化
内置类型的变量未被显式初始化，它的值酱油定义的位置决定。定义与任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将**不被初始化**，即它的值为`undefined`。

# 11. 变量声明和定义的关系
为了支持分离式编译，C++将声明和定义区分开。  
声明：使名字被程序所知。  
定义：创建于名字相关的实体。  
变量声明规定了变量的类型和名字。定义在该作用之上，还申请了内存空间，也可能为变量赋一个初始值。  
如果只想声明，不想定义，则需要`extern`关键字。  
`extern int i; //声明i而非定义i`  
`int j; //声明并定义j`  
`extern double pi = 3.14 //定义pi`  
任何包含了**显式初始化的声明**即成为**定义**。能给`extern`标记的变量赋初始值，但是这会抵消掉`extern`的作用，因此包含初始值的`extern`语句就不是声明，而是定义了。

# 12. 标识符
C++的标识符由字母、数字、下划线组成，也就是俗称的**变量名**。

# 13. 如何显式访问全局变量？
如果局部变量覆盖了全局变量，可以显式地访问全局变量：`::var`









# 15. 异常处理
## 15.1. 如果捕获不到异常？
当异常抛出时，首先搜索抛出该异常的函数，如果没有找到匹配的`catch`，那就终止该函数，并向上层函数继续寻找。如果最终还是找不到，程序会转到名为`terminate`的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

## 15.2. stdexcept
在标准库`<stdexcept>`中，定义了一些异常类。其中的`exception`, `bad_alloc`和`bad_cast`对象只能使用默认初始化，其他的类可以接收字符串来初始化。  
异常类型只定义了一个名为`what`的成员函数，没有参数，返回一个指向C风格字符串的`const char*`。



# 16. 运算
## 16.1. 左值和右值
在C语言中，两者区别比较简单：左值可以位于赋值语句的左侧，而右值不行。
在C++中，区别变复杂了。简单归纳：
- 当对象被用作右值的时候，用的是对象的值（内容）
- 当对象被用作左值的时候，用的是对象的身份（在内存中的位置）

运算对象和求值结果都是右值
赋值运算时，无论左侧运算对象是什么类型，初始值列表都可以为空。

## 16.2. 为什么a+=b比a=a+b更快？
`+=`这种复合运算符只求值一次，而普通运算符求值两次，包括一次加法运算和一次赋值运算。

## 16.3. 用i++还是++i?
除非必要，否则不要用递增递减运算符的后置版本。  
前置版本避免了不必要的运算，它直接改变变量本身的值。后置版本需要先将原始值拷贝，再修改值，返回原始值的拷贝。如果我们用不到原始值，那么后置版本就产生了浪费。

## 16.4. 运算对象可按任意顺序求值
`*beg = toupper(*beg++)`  
这样的代码会产生未定义行为。编译器不一定先计算左边还是右边，所以最后可能赋值到`*beg`上，也可能是`*(beg+1)`上。

# 17. 显式类型转换
## 17.1. static_cast
## 17.2. const_cast
## 17.3. reinterpret_cast
## 17.4. dynamic_cast

# 18. 流程控制
## 18.1. 悬垂else
C++规定else与离它最近的尚未匹配的if匹配。

## 18.2. switch语句
- 和`case`关键字对应的是case标签，必须是**整形常量表达式**。
- C++的switch是瀑布流式的，如果没有`break`关键字，会执行匹配到的case之后所有的case。
- 由于需要通过`break`来控制代码指定范围，所以理论上不需要花括号，但是还是建议使用，因为这样可以限定局部变量的作用域。

## 18.3. for语句头中的多重定义
和其他声明一行，for语句中的init-statement只能有一条声明语句。因此，可以同时声明多个变量，但是类型必须相同。

## 18.4. do while
`do while`至少会执行一次循环。

# 19. 位运算
## 19.1. 关于符号位
当左移一个带符号且为负数的整数时，如何处理符号位是取决于机器的，算是未定义。因此建议仅将位运算用于处理`unsigned`类型。

# 20. 复合类型
## 20.1. 引用
引用必须被初始化，即定义的时候必须明确并立刻指出要引用哪个变量，而且引用只能在初始化时绑定一次，不能重复绑定。  
因为引用本身不是对象，所以不能定义引用的引用。  
因为引用本身不是对象，所以不能定义指向引用的指针。

## 20.2. 指针
过去的程序中会用到`NULL`的预处理变量来给指针赋值，这个变量定义在头文件`cstdlib`中，值为0。预处理变量会被预处理器自动替换为实际值，所以用`NULL`初始化指针和用0是一样的。但是，直接把int变量赋值给指针是错误的行为，既是int变量的值恰好等于0也不行。  
在新标准下，推荐使用`nullptr`，同时尽量避免使用`NULL`。  
`void*`指针可以指向任何类型的对象。因此，不应该直接操作`void*`指针指向的对象，因为该对象的类型是未知的，允许的操作也是未知的。  
面对一条复杂的指针或引用的声明语句时，从右往左读比较容易。

## 20.3. const
`const`对象一旦创建后其值就不能再改变了，所以`const`对象必须初始化。  
当以编译时初始化的方式定义一个对象时：  
`const int buf = 512;`  
编译器在编译过程中就会将所有用到该变量的地方全部替换成512。凡是使用了`const`对象的文件都要求能访问到`const`对象，因此在默认状况下，`const`对象仅在文件内有效。多个文件中的同名`const`对象相当于分别定义在不同文件中的独立变量。  
但是有时，我们需要`const`变量的初始值不是一个常量表达式，又有必要在文件间共享，则需要避免编译器为每个文件生成独立的变量。解决方法是对于`const`变量，不管是声明还是定义，都添加`extern`关键字。

## 20.4. const的引用
"常量引用"指对const的引用。  
常量引用只对引用做出了限制，并不限制引用的对象本身。即我们无法通过常量引用来修改引用对象，但是引用对象本身可以修改自己。

## 20.5. 指针和const
指向常量的指针允许指向一个非常量对象。和常量引用一样，所谓的指向常量的引用和指针，只是他们自以为自己指向了常量，限制了自己不去改变本体，但并没有限制本体。  
把*放在`const`之前，表示这个指针是一个常量，指这个指针不能改变自己的值，即**不能更换所指的对象**，但是**可以修改所指的对象的值**。

## 20.6. 顶层const
顶层const：指针本身是一个常量  
底层const：指针所指的对象是一个常量

## 20.7. constexpr和常量表达式
一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。在一个复杂系统中，很可能定义了一个const变量， 但是它的值不是一个常量表达式。C++11中，允许将变量声明为`constexpr`以便由编译器来严重变量是否为一个常量表达式（是否可以在编译阶段就被替换）。  
推荐写法：如果认定某个变量是常量表达式，那么就把它声明为`constexpr`类型。


# 21. 处理类型
## 21.1. 类型别名
传统方法：使用关键字`typedef`  
新标准：使用别名声明，`using alias = original;`  
注意，在阅读使用了`typedef`的代码时，不要把类型别名替换回去，会导致const的层级发生错乱。
## 21.2. auto类型说明符
`auto`能够根据初始值自动推断类型，相应的，auto定义的变量必须有初始值。  
编译器会适当地改变推断类型，而不是和初始值的类型一模一样：

- 用一个引用作为初始值，推断出来的类型不是引用，而是引动的对象的类型。
- auto一般会忽略顶层const，保留底层const。也就是说推断更基于值。
## 21.3. decltype类型指示符
C++11中引入`decltype`，作用是选择并返回操作数的数据类型。  
与auto不同，如果`decltype`使用的表达式是一个变量，那么`decltype`会保留顶层const和引用等类型。  
如果表达式的内容是解引用，则得到引用类型。`decltype(*p)`的结果是`int&`。  
`decltype((var))`的结果永远是引用（注意**双层括号**）。





# 22. 函数
## 22.1. 得到实参的顺序
编译器能以任何可行的顺序对实参求值。

## 22.2. 形参同名问题
任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能和形参同名。  
由此可见，形参的作用域等同与还是最外层作用域。

## 22.3. 函数的返回值类型不能是什么？
函数的返回值类型不能是**数组类型**或者**函数类型**，但是可以是**指向数组或函数的指针。

## 22.4. 局部静态对象
定义在函数体内部的都是局部变量，加上`static`就是局部静态变量，这种变量在第一次执行时初始化，并直到冲虚终止才销毁。

## 22.5. 无返回值的函数
返回类型是void的函数，可以直接写return，还可以返回一个返回void的函数。

## 22.6. 重载与const形参
一个拥有顶层const的形参无法和另一个普通形参区分开来，~~因为一个普通类型的实参可以隐式转换为const版本~~，所以这样的重载不可以。  

    Record lookup(Phone)
    Record lookup(const Phone)
    
    Record lookup(Phone*)
    Record lookup(Phone* const)
但是，如果形参是**指针或引用**，那么通过区分其指向的是常量对象，还是说他本身是const但是指向普通对象，可以实现函数重载。  

    Record lookup(Account&)
    Record lookup(const Account&)
    
    Record lookup(Account*)
    Record lookup(const Account*)

## 22.7. const_cast与重载
假设我们已经有一个函数，参数和返回值都是const，现在需要一个接收非常量并返回非常量的版本，可以在内部用`const_cast`做转换，调用常量版本的函数。

## initializer_list

当函数的参数是若干同类型数据时，可以使用`initializer_list`作为形参，在调用函数的时候使用花括号即可。



# lambda

`lambda`会被编译器自动转换为匿名类的匿名对象，并行为如同函数，`lambda`捕获的局部变量的引用会被直接使用，但是传值捕获的变量会被转化为匿名类的成员。

函数的签名：`返回值类型(参数类型,...)`。

由于每个`lambda`都是不同的匿名类，所以如果需要用容器来保存`lambda`时，无法用模板来表示，需要转换为标准库`functional`中的`function`。

有重载函数的时候，在要存入function的地方会有歧义，可以使用函数指针或者`lambda`。

# 24. 暂未归类
## 24.1. `<<`运算符的顺序  
`<<`运算符没有明确规定何时以及如何对运算对象求值。  
`cout << i << " " << ++i << endl`这样一行代码是未定义的，编译器不一定先求i的值或者++i的值。


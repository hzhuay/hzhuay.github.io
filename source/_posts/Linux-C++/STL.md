---
title: STL
date: 2022-02-11 22:00:20
tags: C++
categories: C++
---
<h1>C++ STL</h1>  

模板本身不是类或函数，而是为编译器生成类或函数而编写的说明书。

# 1. 顺序容器

## 1.1. 共通的知识

### 1.1.1. assign和赋值的区别

用等号赋值的时候，左右两边的类型要完全一致（包括容器的类型和元素的类型）。  

用`assign`的时候，允许元素类型隐式转换，是**拷贝并替换**到被赋值的容器中。

### 1.1.2. swap的本质

`swap(con1, con2)`可以交换两个容器的内容。注意，`swap`的速度**很快**，因为不是交换容器内的所有元素，而是直接交换容器内部的数据结构。  

除了`array`，`swap`并不复制/删除/插入任何元素,并保证会在常数时间内完成。 `array`的`swap`确实会交换元素，运行时间和元素数量成正比。 `swap`之后，迭代器/引用/指针还指向原来的元素，但是元素的值已经变了。  

由于元素本身的位置并未移动，因此除了`string`，容器的迭代器/引用/指针不会失效。但是，在`swap`之后，所有元素已经在对方容器中了。

早期版本只有成员版本的`swap`， 但是现代C++应该尽量使用**非成员**版本的`swap`。

### 1.1.3. 容器的比较

容器之间也可以用`<`和`=`等关系符进行大小比较，但是仅限于容器和元素类型都一致的情况下。

### 1.1.4. 容器元素是拷贝

用来初始化和插入容易的元素，都是实参的拷贝，完成后就和实参无关了。

### 1.1.5. insert操作

`insert`操作在指定位置前插入，返回插入元素的迭代器。

容器在插入操作后，容量如果达到一定程度，会触发扩容机制，届时内部数据结构会搬到一块新的内存，原来定义的迭代器就失效了。 对于`remove`也是类似，在进行任何可能导致迭代器失效的操作之后，都需要注意及时更新迭代器。

在C++11标准下，接收元素个数或范围的`insert`版本会返回指向第一个新加入元素的迭代器。（在旧版本中，返回的是`void`。）利用这个机制，可以在容器中的一个特定位置反复插入元素。

### 1.1.6. emplace

在C++中，`push`都有对应版本的`emplace`，元素类型对应的构造器所需的参数被传入，`emplace`利用这些参数在插入位置直接构造出一个元素，因此性能会比`push`一个临时对象略好，因为后者多了一步拷贝构造。

### 1.1.7. 用index还是at?

程序需要保证下标是合法的，`[]`本身不会检查是否下标越界。如果想要更安全，可以使用`at`成员，在下标越界时会抛出异常。

### 1.1.8. resize

调用`resize()`时，如果当前大小大于要求大小，那么多余部分被截断；如果当前大小小于要求，那么会填充默认元素或者指定元素。

### 1.1.9. 容器的容量

`capacity`返回容器的容量。

`reserve`可以指定容器的容量，只在指定的容量大于当前容量的时候才会生效，而且注意指定的容量表示的是容器**最低容量**，实际上编译器可能会分配**多于要求**的容量。

在C++11中，`shrink_to_fit`可以让`deque`, `vecotr`, `string`归还用不到的容量，但是具体要不要归还，归还多少，都取决于编译器。

### 1.1.10. 顺序容器的依赖关系

顺序容器中，有些容器时基于其他容器的操作接口实现的，是一种适配器模式。

默认情况下，`stack`和`queue`由`deque`实现。这两种数据结构都只会在头尾处增减元素，用`deque`这样的在两端都可以用O(1)增减元素的结构来实现，`vector`在插头时很慢。

`priority_queue`由`vector`实现。理由是因为`priority_queue`基于`heap`，堆是一种完全二叉树，可以用数组来代替树结构，这样的话`vector`就很合适。



##  1.2. 数组

### 1.2.1. 数组维度是类型的一部分

数组的维度必须是常量表达式。维度是数组类型的一部分，用`decltype`推断数组会得到数组的大小。  

数组类型可以用来定义形参的类型，但是由于维度也是类型的一部分，所以这会限制函数的可用性。

### 1.2.2. 其他

不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。  

数组会被`auto`推断为指针，而非数组。

C++11引入了`begin()`和`end()`函数，可以得到数组的首尾指针。  

标准库限定了下标必须是无符号类型，但是内置数组的下标没有这个限制。 

### 1.2.3. 多维数组

列表初始化多维数组时，内部的花括号可有可无。

使用for-each遍历多维数组时，除了最内层的循环之外，其他循环的控制变量都应该是引用类型。

### 1.2.4. 链表

`list`和`forward_list`有很多为链表专用的成员函数，建议使用这些而不是公用算法。

这些链表专用操作，与公用算法不同，是会改变底层容器的。比如`unique`会把重复元素删除，而不是推到容器尾部。

## 1.3. vector

### 1.3.1. vector初始化选择？

C++要求vector能在运行时高效地添加元素，因此除非需要初始化一个有大量重复值的vector，否则尽量先定义一个空的vector，再在运行时添加元素。

### 1.3.2. 扩容策略

每种`vector`的实现可以选择自己的扩容策略，但是原则是只有在必须的时候才扩容。



# 2. 关联容器

## 2.1. Ordered版本

关联容器默认版本基于红黑树，内部是有序的。`unordered`前缀表示基于哈希表，内部是无序的。如果有`multi`则表示允许重复的key。注意，无论是`set`还是`map`，本质上可以看做同一种东西：`set`就是只有key没有value的`map`。

默认情况下，关联容器要求元素重载小于号，以此来定义其他的比较运算，并且能排序。如果不想用重载运算符，可以传入比较函数：

```c++
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn)
```

map保存的键值对是用`pair`，内部有两个公共成员`first`和`second`。`pair`是map的`value_type`，key的类型是`key_type`，值的类型是`mapped_type`。迭代器得到的pair，`key`是const的，不允许改变。在C++11中，创建`pair`不用字使用`make_pair`或者`pair<T1, T2>(v1, v2)`这样的方式，而是直接用列表初始化`{v1, v2}`就可以代表一个匿名的`pair`。

注意，对map的迭代器解引用得到的是`pair`，用下标得到的是`value`。

由于key是const，所以一般不对关联容器使用泛型算法。由于关联容器的内部结构特殊，导致他的成员函数性能一般会比泛型算法好。实践中，我们一般把关联容器用作数据源或者目的地。

**inset**

在向普通关联容器插入元素时，我们需要知道这个key是否已经存在，insert是否成功。`insert`和`emplace`都会返回一个`pair`，`first`是指向新插入的元素的迭代器，`second`是一个bool值，表示插入是否成功。

**erase**

`erase` return s a count of how many elements were removed.

**equal_range**

`equal_range`得到的是一个pair，`first`是`lower_bound`的值，`second`是`upper_bound`的值，这样正好凑成了一个范围可以用来迭代，遍历所有key等于特定值的范围。一个常用的写法：

```c++
for(auto pos = authors.equal_range(search_item); pos.first!=pos.second; ++pos.first)
```

## 2.2. Unordered

unordered版本基于哈希表，拥有更快的查找的插入性能，要求元素重载`==`运算符和拥有哈希函数。如果Key值类型是无序的，或者性能测试说明哈希表可以更好，那么可以使用unordered版本。

哈希表的结构是一系列桶，每个桶对应一个链表。相同哈希值的元素会被分配到同一个桶里，相当于是哈希碰撞了，要在链表里顺序查找，这是就需要重载的`==`来判断是否相同了。因此，哈希函数的设计会直接影响性能。

内置类型一般都有设计好的哈希函数，对于自定义类型，我们一般有两种方法提供自定义的哈希函数：

1. 用对象中的某些unique的属性作为哈希值，类似于用数据表中的主键或者多个属性组合成一个主键。
2. 另外设计一种。

# 3. 迭代器

需要解引用迭代器并调用所指对象的成员时，形式必须是`(*it).method()`，括号必不可少，因为解引用的优先级很低。为了方便使用，C++增加了箭头运算符`->`。

## 3.1. 尽量使用const迭代器

就和形参和变量类型要求尽量使用const那样，迭代器也应遵循类似原则。要尽量避免不经意的修改。


# 4. 算法

根据STL的设计原则，算法不直接操作容器，而是通过迭代器作为中介和接口。算法不会**调用容器的成员函数**，更不会改变**容器的容量**。

## 4.1. 算法的已经接口

STL中的算法大致有几种接口

- 接收一对范围和一个目的地迭代器
- 接收两对范围：
- 接收一对范围和另一个起点迭代器

他们都有基本的假设：程序员给定的范围是可靠的，容量是足够的。

带有后缀`_if`的算法一般可以接受一个`predicate`，来处理符合特定条件的元素。

带有后缀`_copy`的算法是不改变原容器的，而是会多接收一个目的地迭代器，把改变后的值写到那里。

## 4.2. lambda

基本形式`[capture lsit] (parameter list) -> return type { function body }`

参数列表和返回值类型可以省略，但是捕获列表和函数体必须有，也就是最简形式为`auto f = [] { return 0; };`

如果函数体里只有一个`return`语句的话，可以不用写返回值类型，会自动推断返回值类型。但是如果不止一条语句，并不指定返回值类型时，默认`return void`。

当我们定义了一个lambda时，编译器自动生成了一个匿名的类来表示。和类一样，在lambda对象被创建时，需要捕获的局部变量就像成员变量一样被初始化。

### 4.2.1. 捕获列表

如果lambda想要使用所调用函数内的非静态局部变量，那么必须在捕获列表中指出。`local static`变量和函数体外的变量可以直接使用。

捕获的局部变量可以是by-value或者by-reference。但是和函数参数不同的时，捕获变量的值是在lambda被**创建**的时候复制，而不是在**调用**的时候。

如果是传引用，我们需要保证在lambda执行的时候，捕获的局部变量**还存在**。

- 捕获列表默认传值
- `[=]`: 捕获列表都以传值的方式
- `[&]`: 捕获列表都以传引用的方式
- `[=, &a, &b]`: 除了指定的变量用传引用，其他都是传值
- `[&, a, b]`: 除了指定的变量用传值，其他都是传引用

### 4.2.2. mutable

默认情况下，lambda不匀速改变捕获变量的值，如果一定要改变的话，需要加上`mutable`关键字。

### 4.2.3. 与bind结合

`bind`可以给函数绑定参数，构造出一种新的函数。

## 4.3. 一些具体算法

- unique：每个重复的元素之保留一份，返回一个指向unique部分的尾部的迭代器。注意，容器剩余部分不是空的，重复的元素也不是被删除了，而是被塞到了最后。
- stable_sort：不会改变相等元素的原本顺序。
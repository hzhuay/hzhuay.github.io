---
title: interview
date: 2022-03-10 15:41:10
tags: 面试
categories: 笔记
---

用来记录我面试过程中遇到的问题



### 3.10

- http 2.0
- TCP的状态
- 分布式系统如何解决一致性

### 3.16

#### IO多路复用是为了解决什么问题

传统的多进程并发模型 ：每进来一个新的I/O流会分配一个新的进程管理。

但是这样不适合高并发的场景，因此引入多路IO复用：用单个线程，同时记录跟踪多个I/O流(sock)的状态，来同时管理多个I/O流。每个IO流（socket）就是一个客户连接。

|| select     | poll               | epoll                                                          |
| :--------- | :----------------- | :--------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无上限           | 无上限                                            |
| fd拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询：O(n)         | 轮询：O(n)       | 回调：O(1)                                        |

#### 堆和栈：

- 栈：分配专门的寄存器存放栈的地址，压栈和出栈都有专门的指令执行；编译时决定大小；有OS控制
- 堆：由C/C++库函数实现，由算法寻找足够大的内存空间，需要调用函数；运行时决定；由程序员控制
- 栈直接访问数据；堆先获得指针，再访问数据
- 栈被换出内存可能性比堆大

#### 工厂模式

<img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图" style="zoom: 80%;" />

使用时，`getShape()`根据获得的参数来决定生成Circle、Square还是Rectangle，但一定是满足Shape接口的。

### 3.20

#### MVCC如何实现的

InnoDB用事务版本号，行记录中的隐藏列和Undo Log实现。

- **事务版本号**：每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。
- **行记录的隐藏列**
  - row_id :隐藏的行 ID ,用来生成默认的聚集索引。
  - trx_id: 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。
  - roll_ptr:回滚指针，指向这个记录的 Undo Log 信息。
- **Undo Log**：数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找。

#### 数据原子性

主要是利用 Innodb 的**undo log**。 **undo log**名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。

#### 数据持久性

主要是利用Innodb的**redo log**。当做数据修改的时候，不仅在内存中操作，还会在**redo log**中记录这次操作。当事务提交的时候，会将**redo log**日志进行刷盘(**redo log**一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据**undo log**和**binlog**内容决定回滚数据还是提交数据。

#### 采用redo log的好处？

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

#### binlog

MySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，它记录了所有的 **DDL** 和 **DML** 语句（除了数据查询语句select、show等），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是**复制**和恢复。

Binlog日志的两个最重要的使用场景

- MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的
- 数据恢复：通过使用 mysqlbinlog工具来使恢复数据

### 3.21

- C/C++各自的字符串操作

#### 文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出

目前的理解是，先读入内核缓冲区，再读入用户缓冲区。进程发起read的请求，但是用户态无法直接IO，需要切换到内核态。OS不会马上相应IO，而是可能加入队列，一定时间后统一从磁盘读取，先读取到内核缓冲区，用户进程再从内核中获取。

#### HTTP，TCP协议的头部内容

[![qOJkkR.png](https://s1.ax1x.com/2022/04/05/qOJkkR.png)](https://imgtu.com/i/qOJkkR)

[<img src="https://s1.ax1x.com/2022/04/05/qOJe1K.png" alt="qOJe1K.png" style="zoom: 80%;" />](https://imgtu.com/i/qOJe1K)



#### HTTP请求方法

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

#### HTTP状态码

[HTTP 状态码 | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-status-codes.html)

#### TCP状态图

[![qOJKne.png](https://s1.ax1x.com/2022/04/05/qOJKne.png)](https://imgtu.com/i/qOJKne)

### 3.24

#### 用UDP在应用层面实现可靠：RDT

- RDT1.0：建立在理想可靠信道上，发送和接收方都只有等待调用状态
- RDT2.0：考虑了翻转错误，发送方增加了等待ACK或NAK状态。
- RDT2.1：考虑了ACK或NAK出错出错的情况。简单重传会导致重复分组，因此引入序列号，发送方給每个分组增加序列号，接收方丢弃重复分组。序列号目前可以只为0或1，说明每次只发送一个包。
- RDT2.2：取消NAK，在ACK中显式加入被确认分组的序列号，这样重复的ACK即代表NAK。
- RDT3.0：考虑了丢失分组，因此加入超时重传。如果ACK只是延迟了也无妨，因为接收端收到了重复的分组会自动丢弃。收到重复ack会忽略，因为包可能还在路上，所以只用管计时器。

#### unique_ptr如何转交，移动语义和右值引用

`unique_ptr`无法复制，但是可以转移所有权，使用移动语义。

```
std::unique_ptr<T> p1(new T());
std::unique_ptr<T> p2 = std::move(p1);
```

### 3.25

#### 几种O(N^2)的的排序

- 选择排序：每次选择较小的元素放在数组前部
  - 没有最坏情况
- 冒泡排序：通过不断地交换，将较大的数交换到数组末尾。
  - 原本逆序时情况最坏
- 插入排序：数组从左到右扩大有序的范围，将新遍历到的元素插入到有序部分并保持有序，后续元素向后平移
- 希尔排序：优化插入排序，先分组排序，这样总体上看“基本有序”，再将整个数组排序。可以有效减少需要向后平移元素的个数。

#### Linux脚本编程

### 4.2

#### 协程和进程区别

- 创建线程需要OS，程序本身没法创建线程，但是可以创建协程。因为不需要进入内核态创建，因此协程也称为**用户态线程**。
- 一个程序有一个主线程，可以管理多个协程。
- 线程可以真正的**并行**执行，但是线程只能在线程的基础上**并发**执行。因此才说**线程是程序执行的基本单位**。
- 协程适合IO密集的程序。

#### core，越界错误，如何检测

Linux下C程序常常会因为内存访问错误等原因造成segment fault（段错误），此时如果系统core dump功能是打开的，那么将会有内存映像转储到硬盘上来，之后可以用gdb对core文件进行分析，还原系统发生段错误时刻的堆栈情况。这对于我们发现程序bug很有帮助。

#### Go中数组和切片的区别

其实类似于vector和vector内部的data的区别。

Go中的数组时一种类型，包含了数据类型和长度，一旦定以后就不能更改长度。类似于C++中`new`一个数组就需要指定类型和大小。

切片就类似于`vector`，是对数组的**引用**，自身只保存了大小、容量、引用的数组。

### 4.10

#### STL sort

[<img src="https://s1.ax1x.com/2022/04/10/Lkqhrt.png" alt="Lkqhrt.png" style="zoom: 33%;" />](https://imgtu.com/i/Lkqhrt)

#### 智能指针是线程安全的吗

shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

#### 跨站脚本攻击（XSS）

用户在浏览网站、使用[即时通讯软件](https://baike.baidu.com/item/即时通讯软件)、甚至在阅读电子邮件时，通常会点击其中的链接。攻击者通过在链接中插入[恶意代码](https://baike.baidu.com/item/恶意代码)，就能够盗取用户信息。

#### 跨域？

简单来说，就是我在一个站点向另一个站点发送了请求（[ajax](https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020)或者链接），只要这两个站点HTTP协议、域名或是端口中有一个不一样，说明发送了跨域。

#### 跨域请求伪造

CSRF（Cross Site Request Forgery），跨域请求伪造，即是恶意网站引诱用户点击，或直接将恶意代码植入到正常网站中，伪造用户向正常网站的服务器发送伪造的请求。由于请求是从用户的浏览器发出，便能自动带上用户的cookie发送到服务器。

### 4.18

#### validate关键词

volatile 关键字是一种类型修饰符，**用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

当要求使用 volatile 声明的变量的值的时候，**系统总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。

**volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。**

#### 智能指针，循环引用

两个shared_ptr

一般来讲，解除这种循环引用有下面有三种可行的方法(参考)：
1. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。
2. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。
3. 使用弱引用的智能指针打破这种循环引用。
虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。我们一般使用第三种方法：弱引用的智能指针weak_ptr。

#### struct内存对齐

1. 结构体变量的**起始地址**能够被其最宽的成员大小整除
2. [结构体](https://www.zhihu.com/search?q=结构体&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A208895189})每个成员相对于**起始地址的偏移**能够被其**自身大小整除**，如果不能则在**前一个成员后面**补充字节
3. 结构体总体大小能够**被最宽的成员的大小**整除，如不能则在**后面**补充字节

### 8.8

#### 子类和父类的构造和析构顺序

由于子类包含了父类的功能和属性，不妨将父类看做子类的一个成员，子类依赖于父类，子类是在父类的基础上加上了自己的独有部分。这样看来，构造时一定是从下到上，先构造被依赖的父类，再构造子类。析构时则相反。

#### 周转时间

平均周转时间表示，所有进程完成任务所花的所有时间除以进程的个数。因此周转时间要算上进程**等待**时间加上**运行**时间。

#### 装填因子

装填因子：a=n/m  其中n为key个数，m为表长。

加载因子是表示Hsah表中元素的填满的程度。

#### 筛选法建堆

建堆有两种方式：

1. 插入法：O(NlogN)，是比较熟知的方法，适用于事先不知道元素的个数，可以动态建堆。具体方法为以一个完全二叉树为堆（可以用数组代替），每次新元素加入二叉树的末尾（不破坏完全二叉树），然后与父节点比较进行上浮。
2. 筛选法：O(N)，适用于元素已知的情况。从下往上，从左往右的第一个非叶子节点（其实就是数组的`a[a.size / 2 - 1]`）开始，从下往上遍历（从`a[a.size / 2 - 1]`到`a[0]`）,维护该节点为堆的根节点。

#### 哈夫曼树

给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为`最优二叉树`，也称为`哈夫曼树(Huffman Tree)`。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

构造方法：

1. 起初每个节点看做一个单节点的树，然后全部放入优先队列，按照根节点的权重从小到大。
2. 每次取出最小的两个，作为左右子节点，求出的和为父节点，重写加入优先队列。
3. 重复上述过程直至队列只剩一个节点。

**霍夫曼编码**也是类似的原理。字符出现的频率作为权重

#### 双路归并

类似于力扣题：合并两个有序链表

### 8.9

#### 红黑树比其他平衡二叉搜索树优越在哪里？

AVL树高度更低，查询性能更好，但是删除性能差（不稳定）

红黑树牺牲了平衡性，以及用染色的方式，尽量减少旋转操作。

#### B+树与B树

B树规则：

1. 每个内部节点有n个关键码，就不能超过n+1个分支。将上限设为m，也称就是**B树的阶次**。那么下限不能少于m/2，注意是**向上取整**，因此可以理解为`(m+1)/2`。由此，不同结构的B树可以用分支的上下限来区分，比如与红黑树有关的**（2,4）树**。
2. 所有叶节点在同一层

对于B树而言，高度是对于外部节点，而不是叶节点。




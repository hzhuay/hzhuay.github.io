---
title: interview
date: 2022-03-10 15:41:10
tags: 面试
categories: 笔记
---

用来记录我面试过程中遇到的问题



### 3.10

- http 2.0
- TCP的状态
- 分布式系统如何解决一致性

### 3.16

#### IO多路复用是为了解决什么问题

传统的多进程并发模型 ：每进来一个新的I/O流会分配一个新的进程管理。

但是这样不适合高并发的场景，因此引入多路IO复用：用单个线程，同时记录跟踪多个I/O流(sock)的状态，来同时管理多个I/O流。每个IO流（socket）就是一个客户连接。

|| select     | poll               | epoll                                                          |
| :--------- | :----------------- | :--------------- | ------------------------------------------------- |
| 数据结构   | bitmap             | 数组             | 红黑树                                            |
| 最大连接数 | 1024               | 无上限           | 无上限                                            |
| fd拷贝     | 每次调用select拷贝 | 每次调用poll拷贝 | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 工作效率   | 轮询：O(n)         | 轮询：O(n)       | 回调：O(1)                                        |

#### 堆和栈：

- 栈：分配专门的寄存器存放栈的地址，压栈和出栈都有专门的指令执行；编译时决定大小；有OS控制
- 堆：由C/C++库函数实现，由算法寻找足够大的内存空间，需要调用函数；运行时决定；由程序员控制
- 栈直接访问数据；堆先获得指针，再访问数据
- 栈被换出内存可能性比堆大

#### 工厂模式

<img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图" style="zoom: 80%;" />

使用时，`getShape()`根据获得的参数来决定生成Circle、Square还是Rectangle，但一定是满足Shape接口的。

### 3.20

#### MVCC如何实现的

InnoDB用事务版本号，行记录中的隐藏列和Undo Log实现。

- **事务版本号**：每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。
- **行记录的隐藏列**
  - row_id :隐藏的行 ID ,用来生成默认的聚集索引。
  - trx_id: 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。
  - roll_ptr:回滚指针，指向这个记录的 Undo Log 信息。
- **Undo Log**：数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找。

#### 数据原子性

主要是利用 Innodb 的**undo log**。 **undo log**名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。

#### 数据持久性

主要是利用Innodb的**redo log**。当做数据修改的时候，不仅在内存中操作，还会在**redo log**中记录这次操作。当事务提交的时候，会将**redo log**日志进行刷盘(**redo log**一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据**undo log**和**binlog**内容决定回滚数据还是提交数据。

#### 采用redo log的好处？

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

#### binlog

MySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，它记录了所有的 **DDL** 和 **DML** 语句（除了数据查询语句select、show等），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是**复制**和恢复。

Binlog日志的两个最重要的使用场景

- MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的
- 数据恢复：通过使用 mysqlbinlog工具来使恢复数据

### 3.21

- C/C++各自的字符串操作
- 文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出

#### HTTP，TCP协议的头部内容

[![qOJkkR.png](https://s1.ax1x.com/2022/04/05/qOJkkR.png)](https://imgtu.com/i/qOJkkR)

[<img src="https://s1.ax1x.com/2022/04/05/qOJe1K.png" alt="qOJe1K.png" style="zoom: 80%;" />](https://imgtu.com/i/qOJe1K)



#### HTTP请求方法

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

#### HTTP状态码

[HTTP 状态码 | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-status-codes.html)

#### TCP状态图

[![qOJKne.png](https://s1.ax1x.com/2022/04/05/qOJKne.png)](https://imgtu.com/i/qOJKne)

### 3.24

#### 用UDP在应用层面实现可靠：RDT

- RDT1.0：建立在理想可靠信道上，发送和接收方都只有等待调用状态
- RDT2.0：考虑了翻转错误，发送方增加了等待ACK或NAK状态。
- RDT2.1：考虑了ACK或NAK出错出错的情况。简单重传会导致重复分组，因此引入序列号，发送方給每个分组增加序列号，接收方丢弃重复分组。序列号目前可以只为0或1，说明每次只发送一个包。
- RDT2.2：取消NAK，在ACK中显式加入被确认分组的序列号，这样重复的ACK即代表NAK。
- RDT3.0：考虑了丢失分组，因此加入超时重传。如果ACK只是延迟了也无妨，因为接收端收到了重复的分组会自动丢弃。收到重复ack会忽略，因为包可能还在路上，所以只用管计时器。

#### unique_ptr如何转交，移动语义和右值引用

`unique_ptr`无法复制，但是可以转移所有权，使用移动语义。

```
std::unique_ptr<T> p1(new T());
std::unique_ptr<T> p2 = std::move(p1);
```

### 3.25

#### 几种O(N^2)的的排序

- 选择排序：每次选择较小的元素放在数组前部
  - 没有最坏情况
- 冒泡排序：通过不断地交换，将较大的数交换到数组末尾。
  - 原本逆序时情况最坏
- 插入排序：数组从左到右扩大有序的范围，将新遍历到的元素插入到有序部分并保持有序，后续元素向后平移
- 希尔排序：优化插入排序，先分组排序，这样总体上看“基本有序”，再将整个数组排序。可以有效减少需要向后平移元素的个数。

#### Linux脚本编程

### 4.2

#### 协程和进程区别

- 创建线程需要OS，程序本身没法创建线程，但是可以创建协程。因为不需要进入内核态创建，因此协程也称为**用户态线程**。
- 一个程序有一个主线程，可以管理多个协程。
- 线程可以真正的**并行**执行，但是线程只能在线程的基础上**并发**执行。因此才说**线程是程序执行的基本单位**。
- 协程适合IO密集的程序。

#### core，越界错误，如何检测

Linux下C程序常常会因为内存访问错误等原因造成segment fault（段错误），此时如果系统core dump功能是打开的，那么将会有内存映像转储到硬盘上来，之后可以用gdb对core文件进行分析，还原系统发生段错误时刻的堆栈情况。这对于我们发现程序bug很有帮助。

#### Go中数组和切片的区别

其实类似于vector和vector内部的data的区别。

Go中的数组时一种类型，包含了数据类型和长度，一旦定以后就不能更改长度。类似于C++中`new`一个数组就需要指定类型和大小。

切片就类似于`vector`，是对数组的**引用**，自身只保存了大小、容量、引用的数组。

### 4.10

#### STL sort

[<img src="https://s1.ax1x.com/2022/04/10/Lkqhrt.png" alt="Lkqhrt.png" style="zoom:50%;" />](https://imgtu.com/i/Lkqhrt)

#### 智能指针是线程安全的吗

shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

#### 跨站脚本攻击（XSS）

用户在浏览网站、使用[即时通讯软件](https://baike.baidu.com/item/即时通讯软件)、甚至在阅读电子邮件时，通常会点击其中的链接。攻击者通过在链接中插入[恶意代码](https://baike.baidu.com/item/恶意代码)，就能够盗取用户信息。

#### 跨域？

简单来说，就是我在一个站点向另一个站点发送了请求（[ajax](https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020)或者链接），只要这两个站点HTTP协议、域名或是端口中有一个不一样，说明发送了跨域。

#### 跨域请求伪造

CSRF（Cross Site Request Forgery），跨域请求伪造，即是恶意网站引诱用户点击，或直接将恶意代码植入到正常网站中，伪造用户向正常网站的服务器发送伪造的请求。由于请求是从用户的浏览器发出，便能自动带上用户的cookie发送到服务器。

### 4.18

- validate关键词
- 智能指针，循环引用
- struct内存对齐


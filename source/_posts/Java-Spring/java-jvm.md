---
title: java-jvm
date: 2022-08-24 16:41:23
tags: Java
Categories: Java
---

# JVM

## 内存管理

1. JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。

2. JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。

3. class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。
4. 完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 `<clinit>` 方法，编译器会在 `.java` 文件被编译成 `.class` 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 `<clinit>()` 方法。



| 内存区域      | 内存作用范围   |                                                              |
| ------------- | -------------- | ------------------------------------------------------------ |
| 程序计数器    | 线程私有       | 当前线程所执行的字节码的行号指示器。                         |
| Java 虚拟机栈 | 线程私有       | 每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 **局部变量表**、**操作数栈**、**常量池引用** 等信息。每个方法的执行都对应一次入栈出栈。 |
| 本地方法栈    | 线程私有       | 与虚拟机栈的作用相似。区别在于：**虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务**。本地方法并不是用 Java 实现的，而是由 C 语言实现的。`OutOfMemoryError` |
| Java 堆       | 线程共享       | 存放对象实例，几乎所有的对象实例都是在这里分配内存。         |
| 方法区        | 线程共享       | 永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 |
| 运行时常量池  | 线程共享       | 用于存放编译器生成的各种字面量和符号引用，会在类加载后被放入这个区域。 |
| 直接内存      | 非运行时数据区 | 使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。 |

OutOfMemoryError

- 堆空间溢出
    - 内存泄漏
    - 内存溢出
- GC开销超过限制：超过 `98%` 的时间用来做 GC 并且回收了不到 `2%` 的堆内存时会抛出此异常。一般是因为堆太小。
- 永久代空间不足PermGen space
- 元数据空间不足：Java8后永久代被元数据区取代，不在堆中与老年代相连，而是在本地内存中。

- 无法新建本地线程：线程数 = (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)
- 直接内存溢出

## 垃圾回收

如何检测对象是否还存活：

- 因为**循环引用**的存在，JVM不适用引用计数法。
- 可达性分析：通过 **GC Roots** 作为起始点进行搜索，JVM 将能够到达到的对象视为**存活**，不可达的对象视为**死亡**。

引用类型：

- 强引用：被强引用关联的对象不会被垃圾回收器回收。用`new`创建的就是强引用。
- 软引用：只有在内存不够的情况下才会被回收。用`SoftReference<Object>`创建
- 弱引用：在**下次**垃圾回收发生时一定被回收。用 `WeakReference` 类来创建。
    - `WeakHashMap` 的 `Entry` 继承自 `WeakReference`，主要用来实现缓存。使用不用的引用可以实现分代缓存，让不常使用的对象容易被回收。
- 虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



对方法区的回收主要是对**常量池的回收**和对**类的卸载**。

类的卸载需要满足以下三个条件，并且满足了也不一定会被卸载：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

在大量使用反射、动态代理、CGLib等字节码框架这类频繁自定义`ClassLoader`的场景需要JVM有这个功能。

### 垃圾收集算法

性能指标：

- **停顿时间** - 停顿时间是因为 GC 而导致程序不能工作的时间长度。
- **吞吐量** - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。

#### 标记 - 清除（Mark-Sweep）

将需要回收的对象进行标记，然后清理掉被标记的对象。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

#### 标记 - 整理（Mark-Compact）

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

#### 复制

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是**只使用了内存的一半**。

现在的商业虚拟机都**采用这种收集算法来回收年轻代**，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 `-XX:SurvivorRatio` 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

#### 分代收集

一般将 Java 堆分为年轻代和老年代。

- 年轻代使用：**复制** 算法
- 老年代使用：**标记 - 清理** 或者 **标记 - 整理** 算法


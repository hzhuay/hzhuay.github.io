---
title: JVM
date: 2022-08-24 16:41:23
tags: Java
Categories: Java
---

# JVM

## 内存管理

1. JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。

2. JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。

3. class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。
4. 完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 `<clinit>` 方法，编译器会在 `.java` 文件被编译成 `.class` 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 `<clinit>()` 方法。



| 内存区域      | 内存作用范围   |                                                              |
| ------------- | -------------- | ------------------------------------------------------------ |
| 程序计数器    | 线程私有       | 当前线程所执行的字节码的行号指示器。                         |
| Java 虚拟机栈 | 线程私有       | 每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 **局部变量表**、**操作数栈**、**常量池引用** 等信息。每个方法的执行都对应一次入栈出栈。 |
| 本地方法栈    | 线程私有       | 与虚拟机栈的作用相似。区别在于：**虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务**。本地方法并不是用 Java 实现的，而是由 C 语言实现的。`OutOfMemoryError` |
| Java 堆       | 线程共享       | 存放对象实例，几乎所有的对象实例都是在这里分配内存。         |
| 方法区        | 线程共享       | 永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 |
| 运行时常量池  | 线程共享       | 用于存放编译器生成的各种字面量和符号引用，会在类加载后被放入这个区域。 |
| 直接内存      | 非运行时数据区 | 使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。 |

OutOfMemoryError

- 堆空间溢出
    - 内存泄漏
    - 内存溢出
- GC开销超过限制：超过 `98%` 的时间用来做 GC 并且回收了不到 `2%` 的堆内存时会抛出此异常。一般是因为堆太小。
- 永久代空间不足PermGen space
- 元数据空间不足：Java8后永久代被元数据区取代，不在堆中与老年代相连，而是在本地内存中。

- 无法新建本地线程：线程数 = (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)
- 直接内存溢出

## 垃圾回收

如何检测对象是否还存活：

- 因为**循环引用**的存在，JVM不适用引用计数法。
- 可达性分析：通过 **GC Roots** 作为起始点进行搜索，JVM 将能够到达到的对象视为**存活**，不可达的对象视为**死亡**。

引用类型：

- 强引用：被强引用关联的对象不会被垃圾回收器回收。用`new`创建的就是强引用。
- 软引用：只有在内存不够的情况下才会被回收。用`SoftReference<Object>`创建
- 弱引用：在**下次**垃圾回收发生时一定被回收。用 `WeakReference` 类来创建。
    - `WeakHashMap` 的 `Entry` 继承自 `WeakReference`，主要用来实现缓存。使用不用的引用可以实现分代缓存，让不常使用的对象容易被回收。
- 虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



对方法区的回收主要是对**常量池的回收**和对**类的卸载**。

类的卸载需要满足以下三个条件，并且满足了也不一定会被卸载：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

在大量使用反射、动态代理、CGLib等字节码框架这类频繁自定义`ClassLoader`的场景需要JVM有这个功能。

### 垃圾收集算法

性能指标：

- **停顿时间** - 停顿时间是因为 GC 而导致程序不能工作的时间长度。
- **吞吐量** - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。

#### 标记 - 清除（Mark-Sweep）

将需要回收的对象进行标记，然后清理掉被标记的对象。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

#### 标记 - 整理（Mark-Compact）

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

#### 复制

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是**只使用了内存的一半**。

现在的商业虚拟机都**采用这种收集算法来回收年轻代**，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 `-XX:SurvivorRatio` 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

#### 分代收集

一般将 Java 堆分为年轻代和老年代。

- 年轻代使用：**复制** 算法
- 老年代使用：**标记 - 清理** 或者 **标记 - 整理** 算法

<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png" alt="img" style="zoom:67%;" />

##### **新生代**

正如上所说，JVM会把eden中存活的对象和一个Survivor的对象复制到另一个Survivor中，。JVM会记录Survivor区中的对象一共被复制了多少次，如果达到15次 （`-XX:+MaxTenuringThreshold`），那么晋升为**老年代**。如果单个Survivor已经被占用了50%（ `-XX:TargetSurvivorRatio`），那么复制次数较高的对象晋升**老年代**。

##### 老年代

通常是从Survivor拷贝来的对象。如果对象较大，新生代中无法找到连续空闲空间，会直接分配到老年代。

##### 永久代

早期的方法区在这里，JDK8之后不在了。

### 垃圾收集器

<img src="https://s2.loli.net/2022/08/25/2cvd9nKhzNoZXOY.png" alt="img" style="zoom:67%;" />

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。

#### 串行收集器

最基本，最悠久。是 **`client` 模式下的默认收集器配置**，因为该模式下，分配给虚拟机管理的内存一般不会很大。

**串行收集器采用单线程 stop-the-world 的方式进行收集**。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，**采用单线程方式回收空间并整理内存**。

单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。

Serial和Serial Old是分别用于收集新生代和老年代的串行收集器。

#### 并行收集器

> 开启选项：`-XX:+UseParallelGC`
> 打开此开关后，使用 **Parallel Scavenge** + **Serial Old** 收集器组合来进行内存回收。
>
> 开启选项：`-XX:+UseParallelOldGC`
> 打开此开关后，使用 **Parallel Scavenge** + **Parallel Old** 收集器组合来进行内存回收。

其他收集器都是以关注停顿时间为目标，而**并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器**。

- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；
- 而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在**后台运算**而不需要太多交互的任务。

**并行收集器是 server 模式下的默认收集器。**

并行收集器与串行收集器工作模式**相似**，都是 stop-the-world 方式，只是暂停时**并行**地进行垃圾收集。并行收集器**年轻代采用复制算法**，**老年代采用标记-整理**，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。

在**注重吞吐量以及 CPU 资源敏感**的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。

#### 并发标记清除收集器

> 开启选项：`-XX:+UseConcMarkSweepGC`
> 打开此开关后，使用 **CMS** + **ParNew** + **Serial Old** 收集器组合来进行内存回收。

并发标记清除收集器是以**获取最短停顿时间**为目标。

开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 `Concurrent Mode Failure` ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。

##### CMS收集器

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。是一种以获取最短停顿时间为目标的收集器。运行步骤如下：

1. **初始标记**：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
2. **并发标记**：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
3. **重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
4. **并发清除**：回收在标记阶段被鉴定为不可达的对象。不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

![image.png](https://s2.loli.net/2022/08/25/zrjmT4tSKyfe7NR.png)

CMS回收年轻代：如上面所说，将堆空间分割为一个Eden区和两个Survivor区，每次将Eden和一个Survivor中的存活对象复制到另一个Survivor，年龄达到阈值的晋升老年代。

CMS回收老年代：发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。

- 初始标记是一个短暂暂停的、可达对象被标记的阶段。
- 并发标记寻找活跃对象在应用连续执行时。
- 最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。
- 没有被标记的对象被**就地释放**，不进行压缩操作，也就是从内存分布中还是散乱的。

CMS 收集器具有以下缺点：

- 并发收集 - 并发指的是用户线程和 GC 线程同时运行。
- 吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾 - 可能出现`Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。
    - 可以使用 `-XX:CMSInitiatingOccupancyFraction` 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 `Concurrent Mode Failure`，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
    - 可以使用 `-XX:+UseCMSCompactAtFullCollection` ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。
    - 可以使用 `-XX:CMSFullGCsBeforeCompaction` ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。

##### ParNew收集器

开启选项：`-XX:+UseParNewGC`

![img](https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-gc-par-new.jpg)

ParNew其实就是Serial的多线程版本。Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

#### G1收集器

开启选项：`-XX:+UseG1GC`

**G1 是一种兼顾吞吐量和停顿时间的 GC 收集器**。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。

G1 最大的特点是引入**分区**的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。

##### 分区

G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。

<img src="https://s2.loli.net/2022/08/25/5fLhHgIjz6BKlFc.png" alt="image.png" style="zoom:67%;" />

通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

![image.png](https://s2.loli.net/2022/08/25/ykZAdfKsFw9VM8G.png)

1. **初始标记**
2. **并发标记**
3. **最终标记** - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. **筛选回收** - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

收集年轻代：




<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JackZhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="算是在LeetCode之外开一个新坑，毕竟LeetCode是写过一次的，而且不是专项练习。牛客网的101题是有分单元的，而且我没有写过。 链表BM1 反转链表1234567891011ListNode* ReverseList(ListNode* pHead) &amp;#123;    ListNode* last &#x3D; nullptr;    ListNode* next &#x3D; pHead-&gt;nex">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客网TOP101">
<meta property="og:url" content="http://example.com/algorithm/nowcoder/index.html">
<meta property="og:site_name" content="JackZhu&#39;s Blog">
<meta property="og:description" content="算是在LeetCode之外开一个新坑，毕竟LeetCode是写过一次的，而且不是专项练习。牛客网的101题是有分单元的，而且我没有写过。 链表BM1 反转链表1234567891011ListNode* ReverseList(ListNode* pHead) &amp;#123;    ListNode* last &#x3D; nullptr;    ListNode* next &#x3D; pHead-&gt;nex">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/02/b8JUI0.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/02/b8D73n.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/24/jjJsSS.png">
<meta property="article:published_time" content="2022-02-23T06:21:25.000Z">
<meta property="article:modified_time" content="2022-09-04T15:37:07.534Z">
<meta property="article:author" content="JackZhu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s4.ax1x.com/2022/03/02/b8JUI0.png">
  
  
  <title>牛客网TOP101 - JackZhu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"PWUY6L4sCMxvtPwVBSD0BIvw-MdYXbMMI","app_key":"XY7eP0VTgdPSguOqoldnhp5e","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jack Zhu</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/wallhaven-57jlo1_1280x720.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="牛客网TOP101">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-23 14:21" pubdate>
        2022年2月23日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      48k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      405 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">牛客网TOP101</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年9月4日 晚上
                
              </p>
            
            <div class="markdown-body">
              <p>算是在LeetCode之外开一个新坑，毕竟LeetCode是写过一次的，而且不是专项练习。牛客网的101题是有分单元的，而且我没有写过。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 反转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    ListNode* last = <span class="hljs-literal">nullptr</span>;<br>    ListNode* next = pHead-&gt;next;<br>    <span class="hljs-keyword">while</span>(pHead)&#123;<br>        next = pHead-&gt;next;<br>        pHead-&gt;next = last;<br>        last = pHead;<br>        pHead = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 链表内指定区间反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy-&gt;next = head;<br>    ListNode *pre = dummy, *cur = head; <br>    <span class="hljs-comment">//获取反转区间的起点和起点前的点pre</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        pre = cur;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 这个循环相当于把每次遍历到的节点提前至反转区间的头部</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++)&#123;<br>        ListNode *tmp = cur-&gt;next;<br>        cur-&gt;next = tmp-&gt;next;<br>        tmp-&gt;next = pre-&gt;next;<br>        pre-&gt;next = tmp;			<span class="hljs-comment">//每次都更新反转区间与链表头部的连接的节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相当于每次都将<code>cur-&gt;next</code>移动到<code>pre-&gt;next</code>，然后<code>cur</code>前进一格。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b8JUI0"><img src="https://s4.ax1x.com/2022/03/02/b8JUI0.png" srcset="/img/loading.gif" lazyload alt="b8JUI0.png" style="zoom:50%;" /></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b8D73n"><img src="https://s4.ax1x.com/2022/03/02/b8D73n.png" srcset="/img/loading.gif" lazyload alt="b8D73n.png" style="zoom:50%;" /></a></p>
<h3 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 链表中的节点每k个一组翻转</h3><p>和上一题一样的思路，采用递归写法，先判断节点数量是否需要反转。如果需要，那么执行<code>k-1</code>次，每次都是把<code>cur-&gt;next</code>移动到<code>pre-&gt;next</code>，然后<code>cur</code>前进一格。执行完后<code>cur</code>正好处在反转区间的尾部，<code>cur-&gt;next</code>就是下一个反转区间的开头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!head || k &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode *pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), *cur = head, *next = <span class="hljs-literal">nullptr</span>;<br>    pre-&gt;next = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span> head;	<span class="hljs-comment">//节点数不到k个</span><br>        cur = cur-&gt;next;		<span class="hljs-comment">//寻找反转区间的右边界，开区间</span><br>    &#125;<br>    cur = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++)&#123;	<span class="hljs-comment">//只需要执行k-1次</span><br>        next = cur-&gt;next;<br>        cur-&gt;next = next-&gt;next;<br>        next-&gt;next = pre-&gt;next;<br>        pre-&gt;next = next;<br>    &#125;<br>    cur-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(cur-&gt;next, k);<br>    <span class="hljs-keyword">return</span> pre-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 合并两个排序的链表</h3><p>递推版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    ListNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* dummy = cur;<br>    <span class="hljs-keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;<br>       <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;<br>            cur-&gt;next = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur-&gt;next = pHead1 ? pHead1 : pHead2;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pHead1)<span class="hljs-keyword">return</span> pHead2;<br>    <span class="hljs-keyword">if</span>(!pHead2)<span class="hljs-keyword">return</span> pHead1;<br>    <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;<br>        pHead1-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1-&gt;next, pHead2);<br>        <span class="hljs-keyword">return</span> pHead1;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pHead2-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1, pHead2-&gt;next);<br>        <span class="hljs-keyword">return</span> pHead2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 合并k个已排序的链表</h3><p>只要利用了优先队列这样的数据结构，这题就很容易了，让优先队列自动帮我们维护排序即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> ListNode* l, <span class="hljs-type">const</span> ListNode* r)</span></span><br><span class="hljs-function">    	</span>&#123;<span class="hljs-keyword">return</span> l-&gt;val &gt; r-&gt;val;&#125;<br>&#125;;<br><span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;<br>    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l: lists)<br>        <span class="hljs-keyword">if</span>(l) q.<span class="hljs-built_in">push</span>(l);<br>    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode *cur = dummy;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        cur-&gt;next = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next) q.<span class="hljs-built_in">push</span>(cur-&gt;next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 判断链表中是否有环</h3><p>快慢指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a>BM7 链表中环的入口结点</h3><p>快慢指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    <span class="hljs-comment">// 先检查有没有环</span><br>    ListNode *fast = pHead, *slow = pHead;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        <span class="hljs-comment">// 确定有环，再来寻找环的入口</span><br>        fast = pHead;	<span class="hljs-comment">//这一步很关键，有数学证明这样可以使快慢指针在入口相遇</span><br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM8-链表中倒数最后k个结点"><a href="#BM8-链表中倒数最后k个结点" class="headerlink" title="BM8 链表中倒数最后k个结点"></a>BM8 链表中倒数最后k个结点</h3><p>第一种思路比较符合直觉：先遍历一遍获得链表长度，然后再遍历一次找到截取的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    ListNode* cur = pHead;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        cur = cur-&gt;next;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k &gt; len)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    cur = pHead;<br>    <span class="hljs-type">int</span> n = len - k;<br>    <span class="hljs-keyword">while</span>(n--)cur = cur-&gt;next;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一种写法是快慢指针，其实性能应该是差不多的，但是看起来高端一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ListNode *fast = pHead, *slow = pHead;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-keyword">if</span>(!fast)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 删除链表的倒数第n个节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        fast = fast-&gt;next;<br>    <span class="hljs-comment">//如果此时快指针已经到达尾后，说要删除的就是链表头</span><br>    <span class="hljs-keyword">if</span>(!fast) <span class="hljs-keyword">return</span> head-&gt;next;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<span class="hljs-comment">//直到fast到达结尾</span><br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//此时慢指针停在该被删除的节点之前，修改其next跳过被删除的节点</span><br>    slow-&gt;next = slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 两个链表的第一个公共结点</h3><p>既然保证输入数据肯定是正确的，那么只要不断遍历，两个节点一定会相遇。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pHead1 || !pHead2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode *p1 = pHead1, *p2 = pHead2;<br>    <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>        p1 = p1 ? p1-&gt;next : pHead1;<br>        p2 = p2 ? p2-&gt;next : pHead2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM11-两个链表生成相加链表"><a href="#BM11-两个链表生成相加链表" class="headerlink" title="BM11 两个链表生成相加链表"></a>BM11 两个链表生成相加链表</h3><p>结合力扣第2题和牛客第1题，先将两个链表反转，相加后再将结果反转后返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">addInList</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReverseList</span>(<span class="hljs-built_in">addTwoNumbers</span>(<span class="hljs-built_in">ReverseList</span>(head1), <span class="hljs-built_in">ReverseList</span>(head2)));<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* cur = head;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 || l2 || tmp)&#123;<br>        <span class="hljs-type">int</span> sum = tmp;<br>        sum += l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>        sum += l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>        tmp = sum / <span class="hljs-number">10</span>;<br>        sum %= <span class="hljs-number">10</span>;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(l1)l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l2)l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    ListNode* last = <span class="hljs-literal">nullptr</span>;<br>    ListNode* next = pHead-&gt;next;<br>    <span class="hljs-keyword">while</span>(pHead)&#123;<br>        next = pHead-&gt;next;<br>        pHead-&gt;next = last;<br>        last = pHead;<br>        pHead = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM12-单链表的排序"><a href="#BM12-单链表的排序" class="headerlink" title="BM12 单链表的排序"></a>BM12 单链表的排序</h3><p>要求：空间复杂度 O*(*n)，时间复杂度 O(nlogn)，那我为何不直接塞到数组里，然后对数组排序，再重建列表呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> ListNode* a, <span class="hljs-type">const</span> ListNode* b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a-&gt;val &lt; b-&gt;val;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">sortInList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    vector&lt;ListNode*&gt; arr;<br>    ListNode* tmp = head;<br>    <span class="hljs-keyword">while</span>(tmp)&#123;<br>        arr.<span class="hljs-built_in">push_back</span>(tmp);<br>        tmp = tmp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>        arr[i]-&gt;next = arr[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    arr[arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM13-判断一个链表是否为回文结构"><a href="#BM13-判断一个链表是否为回文结构" class="headerlink" title="BM13 判断一个链表是否为回文结构"></a>BM13 判断一个链表是否为回文结构</h3><p>这里也复用了BM1的代码。用快慢指针找到链表中间的部分，然后反转后半链表。</p>
<p>将数据都读到数组里也是一种做法，这题并没有限制空间，但是反转链表的方式可以节省内存，但是会改变链表本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPail</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//从slow开始讲后半部分的链表反转</span><br>    ListNode *l1 = <span class="hljs-built_in">ReverseList</span>(slow), *l2 = head;<br>    <span class="hljs-keyword">while</span>(l1)&#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val != l2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        l1 = l1-&gt;next;<br>        l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a>BM14 链表的奇偶重排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    ListNode *even_head = head-&gt;next, *odd = head, *even = head-&gt;next;<br>    <span class="hljs-comment">//如果是奇数个节点，因为even本身起点就比head多1，所以即使只剩一个节点</span><br>    <span class="hljs-keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;<br>        odd-&gt;next = odd-&gt;next-&gt;next;<br>        odd = odd-&gt;next;<br>        even-&gt;next = even-&gt;next-&gt;next;<br>        even = even-&gt;next;<br>    &#125;<br>    odd-&gt;next = even_head;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 删除有序链表中重复的元素-I</h3><p>每次遍历到该节点和下一个节点一样的，就让该节点跳过下一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *cur = head;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a>BM16 删除有序链表中重复的元素-II</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode *cur = head, *pre = dummy;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;<br>            <span class="hljs-comment">//跳过除了自己之外的所有重复节点</span><br>            <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            &#125;<br>            pre-&gt;next = cur-&gt;next;	<span class="hljs-comment">//pre-&gt;next跳过重复节点cur</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二分查找-x2F-排序"><a href="#二分查找-x2F-排序" class="headerlink" title="二分查找&#x2F;排序"></a>二分查找&#x2F;排序</h2><h3 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 二分查找-I</h3><p>二分查找的思路本身没什么好说的，但是细节部分很值得深究，比如每次重新赋值<code>left</code>和<code>right</code>要不要对<code>mid</code>加一或者减一；循环判断条件用<code>&lt;=</code>还是<code>&lt;</code>，这些会影响到查找的效果。我会在<a href="/%E7%AC%94%E8%AE%B0/binary-search/">这篇笔记</a>中单独讲这个问题。</p>
<p>这里先提供一个最基本的二分查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-type">int</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>            l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h3><p>从矩阵的右上角开始查找，如果偏大了就向左走，偏小了就向右走。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> R = array.<span class="hljs-built_in">size</span>(), C = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = C - <span class="hljs-number">1</span>;<span class="hljs-comment">//起点是右上角</span><br>    <span class="hljs-keyword">while</span>(r &lt; R &amp;&amp; c &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//坐标还在合理范围内</span><br>        <span class="hljs-keyword">if</span>(array[r][c] &lt; target) r++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[r][c] &gt; target) c--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 寻找峰值</h3><p>二分法，判断当前点<code>mid</code>是上坡还是下坡，向上坡方向靠拢。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//由于right=mid，所以right是有可能被返回的</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<span class="hljs-comment">//退出条件left==right</span><br>        <span class="hljs-type">int</span> mid = (right + left) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>])<span class="hljs-comment">//这是上坡，右侧可能有峰值</span><br>            left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//mid+1是因为mid不可能是峰值</span><br>        <span class="hljs-keyword">else</span> right = mid;<span class="hljs-comment">//mid可能是峰值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 数组中的逆序对</h3><p>在归并排序中可以顺便统计逆序对。在合并阶段，左区间的所有节点应该小于右区间的所有节点，所以在比较左右区间中的点时，只要遇到了右区间的元素比左区间小的情况，那么该右区间元素与左区间的所有元素都形成了逆序对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> M = <span class="hljs-number">1000000007</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(data.size())</span></span>;<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;data, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, l, mid, ans);<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, mid +<span class="hljs-number">1</span> , r, ans);<br>    <span class="hljs-built_in">merge</span>(data, tmp, l, mid, r, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;data, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ans)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(data[i] &gt; data[j])&#123;<span class="hljs-comment">//右区间的元素小于左区间，会产生逆序对</span><br>            tmp[k++] = data[j++];<br>            <span class="hljs-comment">//data[i, mid]中所有元素都与data[j]产生逆序对</span><br>            ans = (ans + (mid - i + <span class="hljs-number">1</span>)) % M;<br>        &#125;<span class="hljs-keyword">else</span> tmp[k++] = data[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)<br>        tmp[k++] = data[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r)<br>        tmp[k++] = data[j++];<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; l &lt;= r; l++, k++)<br>        data[l] = tmp[k];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 旋转数组的最小数字</h3><p>二分查找，判断<code>arr[mid]</code>和<code>arr[left]</code>的关系。但是这道题要小心<code>[1,0,1,1,1]</code>这样的数据，因为<code>mid</code>第一次迭代时就是中间的1，如果只是在<code>arr[mid] == arr[left]</code>的情况下<code>left++</code>的话，mid将永远访问不到0所在的位置。因此需要加上<code>if(rotateArray[left] &lt; rotateArray[right])</code>的特判。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; rotateArray)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = rotateArray.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    	<span class="hljs-keyword">while</span>(left &lt; right)&#123;	<span class="hljs-comment">//最后剩下的元素一定是答案</span><br>        <span class="hljs-keyword">if</span>(rotateArray[left] &lt; rotateArray[right])<br>            <span class="hljs-keyword">return</span> rotateArray[left];<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(rotateArray[mid] &gt; rotateArray[left])<br>            left = mid + <span class="hljs-number">1</span>;	<span class="hljs-comment">//mid不可能为答案</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotateArray[mid] &lt; rotateArray[left])<br>            right = mid;	<span class="hljs-comment">//mid可能为答案</span><br>        <span class="hljs-keyword">else</span> left++;		<span class="hljs-comment">//无法判断，保守策略</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> rotateArray[left];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 比较版本号</h3><p>双指针，每次提取一个数字来比较。如果遇到不相等就提前结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, len1 = version1.<span class="hljs-built_in">size</span>(), len2 = version2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> num1, num2;<br>    <span class="hljs-keyword">while</span>(i &lt; len1 || j &lt; len2)&#123;<br>        num1 = <span class="hljs-built_in">consume</span>(i, version1);<br>        num2 = <span class="hljs-built_in">consume</span>(j, version2);<br>        <span class="hljs-keyword">if</span>(num1 &gt; num2)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num1 &lt; num2)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p, string&amp; s)</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[p] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>        ret = ret * <span class="hljs-number">10</span> + s[p++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    p++;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 二叉树的前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-built_in">dfs</span>(root, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 二叉树的中序遍历</h3><p>和上题差不多，只需要改<code>dfs</code>部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 二叉树的后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 求二叉树的层序遍历</h3><p>可能bfs会直观一点，不过dfs也不难写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>    <span class="hljs-built_in">dfs</span>(root, ans, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;ans, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() &lt;= depth)<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    ans[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 按之字形顺序打印二叉树</h3><p>理论上可以借用上题的代码获取数据，然后把偶数行给<code>reverse</code>，但是这样效率不高，不如在递归的时候就把数据按顺序排好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>    <span class="hljs-built_in">dfs</span>(pRoot, ans, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;ans, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() &lt;= depth)<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    ans[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-keyword">if</span>(depth % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 二叉树的最大深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a>BM29 二叉树中和为某一值的路径(一)</h3><p>注意空树直接返回<code>false</code>的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum -= root-&gt;val;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 二叉搜索树与双向链表</h3><p>先中序遍历，把排好序的数都保存到数组上，再遍历一遍创建列表，这是一种直观的思路。递归的写法其实在时间复杂度和空间复杂度上没有明显优势。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">TreeNode *dummy, *pre;<br><span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRootOfTree) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>    pre = dummy;<br>    <span class="hljs-built_in">dfs</span>(pRootOfTree);<br>    dummy-&gt;right-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> dummy-&gt;right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(!dummy) dummy-&gt;right = node;<br>    pre-&gt;right = node;<br>    node-&gt;left = pre;<br>    pre = node;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a>BM31 对称的二叉树</h3><p>题解中很多写法声称每个节点只会访问一次，其实是不对的，这样写才能保证一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!pRoot-&gt;left || !pRoot-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(pRoot-&gt;left-&gt;val != pRoot-&gt;right-&gt;val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(pRoot-&gt;left, pRoot-&gt;right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* l, TreeNode* r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!l &amp;&amp; !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!l || !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(l-&gt;val != r-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="hljs-built_in">isSame</span>(l-&gt;right, r-&gt;left);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 合并二叉树</h3><p>在确保<code>t1</code>和<code>t2</code>非空的情况下，把<code>t2</code>合并到<code>t1</code>上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span>(!t1 || !t2) <span class="hljs-keyword">return</span> t1 ? t1 : t2;<br>    <span class="hljs-comment">//到这里说明t1和t2都存在</span><br>    t1-&gt;val += t2-&gt;val;<br>    t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>    t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>    <span class="hljs-keyword">return</span> t1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 二叉树的镜像</h3><p>关键在于使用<strong>后序遍历</strong>，从底层开始逐层向上翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>    <span class="hljs-built_in">swap</span>(pRoot-&gt;left, pRoot-&gt;right);<br>    <span class="hljs-keyword">return</span> pRoot;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 判断是不是二叉搜索树</h3><p>中序遍历下二叉搜索树应该是有序的，因此使用<code>pre</code>记录前一个节点的值，每次遍历到的节点值都应该大于<code>pre</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">long</span> pre;<br><span class="hljs-type">bool</span> ans;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    pre = LONG_LONG_MIN;<br>    ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node || !ans) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(pre &lt; node-&gt;val)&#123;<br>        pre = node-&gt;val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a>BM35 判断是不是完全二叉树</h3><p>用BFS逐层遍历，用<code>flag</code>变量记住是否遇到过空节点。如果已经遇到过空节点后，再遇到正常节点，那么就是不完全二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    queue&lt;TreeNode*&gt; q;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode *node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!node)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//flag为true说明在此节点前已经遇到空节点了</span><br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a>BM36 判断是不是平衡二叉树</h3><p>如果写一个计算高度的函数，然后从上往下遍历，那么会在计算高度的时候重复计算。可以在计算高度时从下往上判断，如果不合法则返回-1，合法则返回高度。遇到-1之后就不需要继续计算了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(pRoot) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode *node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(node-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//如果不合法则返回-1，合法则返回高度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a>BM37 二叉搜索树的最近公共祖先</h3><p>根节点一定是祖先，因此从根往下找。如果<code>root</code>比p和q都大，那么说明p和q都在root的左子树上，反之则在右子树上。当p和q分别位于<code>root</code>的左右两边时，说明<code>root</code>是最近公共祖先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(root)&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; p &amp;&amp; root-&gt;val &gt; q)<br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; p &amp;&amp; root-&gt;val &lt; q)<br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM38-在二叉树中找到两个节点的最近公共祖先（重要）"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先（重要）" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先（重要）"></a>BM38 在二叉树中找到两个节点的最近公共祖先（重要）</h3><ol>
<li><p>如果该节点不是O1也不是O2，那么O1与O2必然分别在该节点的左子树和右子树中</p>
</li>
<li><p>如果该节点就是O1或者O2，那么另一个节点在它的左子树或右子树中</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, o1, o2)-&gt;val;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root || root-&gt;val == o1 || root-&gt;val == o2)<br>        <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">dfs</span>(root-&gt;left, o1, o2);<br>    TreeNode* right = <span class="hljs-built_in">dfs</span>(root-&gt;right, o1, o2);<br>    <span class="hljs-comment">//如果不在左子树，就肯定在右子树；反正依然</span><br>    <span class="hljs-keyword">if</span>(!left) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span>(!right) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-comment">//如果左右子树都不为空，那么说明该点就是最近公共祖先</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a>BM39 序列化二叉树</h3><p>采用先序遍历的方式序列化和反序列化。序列化时遇到空节点则设置为<code>#</code>，反序列化时遇到空节点则设置为不可能的值。采用队列来保存节点值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;    <br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(root, ans); <br>    <span class="hljs-type">char</span>* ret = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ans.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(ret, ans.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; vals;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>            vals.<span class="hljs-built_in">push</span>(tmp);<br>            tmp = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            tmp = <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp = tmp * <span class="hljs-number">10</span> + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(vals);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, string&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node)&#123;<br>        ans += <span class="hljs-string">&quot;#,&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ans += <span class="hljs-built_in">to_string</span>(node-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right, ans);<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(queue&lt;<span class="hljs-type">int</span>&gt;&amp; vals)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(vals.<span class="hljs-built_in">front</span>() == <span class="hljs-number">-1</span>)&#123;<br>        vals.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vals.<span class="hljs-built_in">front</span>());<br>    vals.<span class="hljs-built_in">pop</span>();<br>    node-&gt;left = <span class="hljs-built_in">build</span>(vals);<br>    node-&gt;right = <span class="hljs-built_in">build</span>(vals);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a>BM40 重建二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">auto</span> mid = <span class="hljs-built_in">find</span>(vin.<span class="hljs-built_in">begin</span>(), vin.<span class="hljs-built_in">end</span>(), root-&gt;val);<br>    <span class="hljs-type">int</span> left = mid - vin.<span class="hljs-built_in">begin</span>(), right = vin.<span class="hljs-built_in">end</span>() - mid;<br>    root-&gt;left = <span class="hljs-built_in">reConstructBinaryTree</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+left), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(vin.<span class="hljs-built_in">begin</span>(), mid));<br>    root-&gt;right = <span class="hljs-built_in">reConstructBinaryTree</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+left, pre.<span class="hljs-built_in">end</span>()), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(mid+<span class="hljs-number">1</span>, vin.<span class="hljs-built_in">end</span>()));<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a>BM41 输出二叉树的右视图</h3><p>先使用上一题的代码重建二叉树，再层序遍历，每层取最后一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; xianxu, vector&lt;<span class="hljs-type">int</span>&gt;&amp; zhongxu)</span> </span>&#123;<br>    TreeNode *root = <span class="hljs-built_in">reConstructBinaryTree</span>(xianxu, zhongxu);<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        TreeNode *last = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            last = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(last-&gt;left)q.<span class="hljs-built_in">push</span>(last-&gt;left);<br>            <span class="hljs-keyword">if</span>(last-&gt;right)q.<span class="hljs-built_in">push</span>(last-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(last-&gt;val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">d<br></code></pre></td></tr></table></figure>

<h2 id="堆-x2F-栈-x2F-队列"><a href="#堆-x2F-栈-x2F-队列" class="headerlink" title="堆&#x2F;栈&#x2F;队列"></a>堆&#x2F;栈&#x2F;队列</h2><h3 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 用两个栈实现队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> tmp = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br></code></pre></td></tr></table></figure>

<h3 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a>BM43 包含min函数的栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        s.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(min_s.<span class="hljs-built_in">empty</span>())<br>            min_s.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> min_s.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">min</span>(value, min_s.<span class="hljs-built_in">top</span>()));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        s.<span class="hljs-built_in">pop</span>();<br>        min_s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_s;<br></code></pre></td></tr></table></figure>

<h3 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a>BM44 有效括号序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; left;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s)&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;[&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>            left.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            left.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a>BM45 滑动窗口的最大值</h3><p>本来应该是用优先队列来维护窗口内的最大值，但是C++的<code>priority_queue</code>无法提供快速的查找功能，这样在串口移动的时候无法删除失效的元素。因此可以改用<code>multiset</code>，内部也是有序的，可以直接获取最大值，而且可以O(logN)查找失效元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>  multiset&lt;<span class="hljs-type">int</span>&gt; m;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    m.<span class="hljs-built_in">insert</span>(nums[i]);<br>    <span class="hljs-keyword">if</span>(i &gt;= size) m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">find</span>(nums[i - size]));<br>    <span class="hljs-keyword">if</span>(i &gt;= size - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(*m.<span class="hljs-built_in">rbegin</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM46-最小的K个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46 最小的K个数"></a>BM46 最小的K个数</h3><p>用一个大根堆，从大到小维护目前遍历过的元素中最小的k个。每次遍历一个新的数，就和堆顶比较，如果比堆顶小，就入堆，并控制堆大小为k；如果比堆顶还大，就跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : input)&#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &lt; k)<br>            pq.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>() &gt; i)&#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>());<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47 寻找第K大"></a>BM47 寻找第K大</h3><p>两种思路。第一种，构造一个小顶堆，控制堆的size不超过k。在size达到k的时候，新元素和堆顶比较，如果比堆顶更大则可以入堆。最后返回堆顶就是第k大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &lt; K) pq.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>() &lt; i)&#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二种思路是分治，利用快排的思想。每次只对第k大的元素可能在的半边排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(a, l, r);<br>    <span class="hljs-keyword">if</span>(pivot == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a[pivot];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pivot &gt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, l, pivot - <span class="hljs-number">1</span>, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, pivot + <span class="hljs-number">1</span>, r, k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> tmp = a[l];<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; tmp &gt;= a[r]) r--;<br>        a[l] = a[r];<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; tmp &lt;= a[l]) l++;<br>        a[r] = a[l];<br>    &#125;<br>    a[l] = tmp;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 数据流中的中位数</h3><p>维护一个大顶堆和一个小顶堆。大顶堆保存数据流中较小的数据，小顶堆保存较大的数据。插入时尽量插入小顶堆，并且控制小顶堆比大顶堆多1个或者相等。然后如果需要取中位数的时候，奇数情况下从小顶堆取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue&lt;<span class="hljs-type">int</span>&gt; big_heap;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; small_heap;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!big_heap.<span class="hljs-built_in">empty</span>() &amp;&amp; num &lt; big_heap.<span class="hljs-built_in">top</span>())<br>        big_heap.<span class="hljs-built_in">push</span>(num);<br>    <span class="hljs-keyword">else</span> <br>        small_heap.<span class="hljs-built_in">push</span>(num);<br>    <span class="hljs-keyword">if</span>(small_heap.<span class="hljs-built_in">size</span>() == big_heap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span>)&#123;<br>        big_heap.<span class="hljs-built_in">push</span>(small_heap.<span class="hljs-built_in">top</span>());<br>        small_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(small_heap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> == big_heap.<span class="hljs-built_in">size</span>())&#123;<br>        small_heap.<span class="hljs-built_in">push</span>(big_heap.<span class="hljs-built_in">top</span>());<br>        big_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">if</span>((small_heap.<span class="hljs-built_in">size</span>() + big_heap.<span class="hljs-built_in">size</span>()) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (small_heap.<span class="hljs-built_in">top</span>() + big_heap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> small_heap.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a>BM49 表达式求值</h3><p>首先提供的是直接求值的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-built_in">cal</span>(ops, nums);<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">priority</span>(ops.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">priority</span>(c))<br>                <span class="hljs-built_in">cal</span>(ops, nums);<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                tmp = tmp * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            i--;<br>            nums.<span class="hljs-built_in">push</span>(tmp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())<span class="hljs-built_in">cal</span>(ops, nums);<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops, stack&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> b = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">char</span> op = ops.<span class="hljs-built_in">top</span>(); ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %d\n&quot;</span>, a, op, b);<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a + b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a - b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a * b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后提供的版本由2个函数组成。先由<code>getSuffixExpr()</code>将中缀表达式转换为后缀表达式，注意这一步已经将运算符优先级处理完毕。第二部由<code>parseSuffixExpr()</code>将后缀表达式转换为计算结果，只一步不需要考虑运算符优先级，只需要按照规则逐个运算符计算即可。</p>
<p>如何处理运算符优先级：每次运算符入栈时，先将栈内优先级大于等于新运算符的出栈，表示这些应当被优先计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; exp = <span class="hljs-built_in">getSuffixExpr</span>(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseSuffixExpr</span>(exp);<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getSuffixExpr</span><span class="hljs-params">(string s)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    vector&lt;string&gt; exp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isDigit</span>(c))&#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isDigit</span>(s[i]))&#123;<br>                tmp = tmp * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            i--;<br>            exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(tmp));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">priority</span>(ops.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">priority</span>(c))<br>                exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>    <span class="hljs-keyword">return</span> exp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parseSuffixExpr</span><span class="hljs-params">(vector&lt;string&gt;&amp; exp)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span>(string&amp; s : exp)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isDigit</span>(s[<span class="hljs-number">0</span>]))<br>            nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">cal</span>(s[<span class="hljs-number">0</span>], nums);<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">pop</span><span class="hljs-params">(stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops)</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">1</span>, ops.top())</span></span>;<br>    ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">char</span> op, stack&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> b = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a + b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a - b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a * b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;/&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a / b);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a>BM50 两数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(m[target - numbers[i]] != <span class="hljs-number">0</span>)&#123;<br>            ans[<span class="hljs-number">0</span>] = m[target - numbers[i]];<br>            ans[<span class="hljs-number">1</span>] = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            m[numbers[i]] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a>BM51 数组中出现次数超过一半的数字</h3><p>投票法。记录当前遇到的出现最多的数字和次数，如果遍历到一样的就增加次数，不一样则减少次数；次数如果减到-1则换一个数字来记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : numbers)&#123;<br>        <span class="hljs-keyword">if</span>(ans == i)&#123;<br>            cnt++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>                ans = i;<br>                cnt++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a>BM52 <em>数组中只出现一次的两个数字</em></h3><p>首先需要做过一道前置题目：数组中只出现一次的数字。那道题中将所有的数组元素异或即可，因为出现两次的数字异或后会抵消，最后只留下出现一次的数字。</p>
<p>这道题中有2个数字只出现一次，如果按照同样的方式，只能得到这两个数字的异或值。已知这两个数肯定不同，那么异或的结果必然不同，至少有一位为1。那么就找到这一位，将数组中的数按照这一位是否为1来分成2类，分别将两类数异或后即是所求的答案。可以理解为每一类数各contribute to其中一个答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : array) a ^= i;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span>((a &amp; p) == <span class="hljs-number">0</span>) p &lt;&lt;= <span class="hljs-number">1</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-comment">// p在最先遇到a为1的那位上为1</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : array)&#123;<br>        <span class="hljs-keyword">if</span>(i &amp; p) n ^= i;<br>        <span class="hljs-keyword">else</span> m ^= i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; m) <span class="hljs-built_in">swap</span>(n, m);<br>    <span class="hljs-keyword">return</span> &#123;n,m&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 <em>缺失的第一个正整数</em></h3><p>在恢复后，数组应当有 <code>[1, 2, ..., N]</code> 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。我们遍历，如果遍历到的<code>x=nums[i]</code>在<code>[1,N]</code>内，就把这个数交换到他应该在的位置：<code>nums[x-1]</code>。持续交换直到<code>x</code>是一个<code>[1,N]</code>以外的数，或者就是这个位置应该所在的数：<code>x-1==i</code>。</p>
<p>由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 N，整个方法的时间复杂度为 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberDisappeared</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 如果nums[i]不是该在的位置上应有的数，则继续循环。注意避免死循环</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt; nums[i] &amp;&amp; nums[i] &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>] != nums[i])<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="❓BM54-三数之和"><a href="#❓BM54-三数之和" class="headerlink" title="❓BM54 三数之和"></a>❓BM54 三数之和</h3><p>我们进行循环选择第一个数<strong>x</strong>，然后创建两个指针<strong>i</strong>和<strong>j</strong>，指针<strong>i</strong>指向下一个数，指针<strong>j</strong>指向最后一个数。</p>
<ul>
<li>若指针<strong>i</strong> 加指针<strong>j</strong> 大于当前数 <strong>x</strong>则指针<strong>j</strong> –，</li>
<li>若指针<strong>i</strong> 加指针<strong>j</strong> 小于当前数 <strong>x</strong>则指针<strong>i</strong>++，</li>
<li>若指针<strong>i</strong> 加指针<strong>j</strong> 等于当前数<strong>x</strong> 则答案为<strong>x</strong> 和指针<strong>i</strong> 与<strong>j</strong> 的三元组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; num[i] == num[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(num[i] + num[l] + num[r] == <span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;num[i], num[l], num[r]&#125;);<br>                <span class="hljs-comment">// 跳过一样的</span><br>                <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r &amp;&amp; num[l] == num[l+<span class="hljs-number">1</span>]) l++;<br>                <span class="hljs-keyword">while</span>(r - <span class="hljs-number">1</span> &gt; l &amp;&amp; num[r] == num[r<span class="hljs-number">-1</span>]) r--;<br>                l++; r--; <span class="hljs-comment">// 掉过当前数字，到下一个数字</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i] + num[l] + num[r] &gt; <span class="hljs-number">0</span>) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a>BM55 没有重复项数字的全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num) &#123;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    ans.<span class="hljs-built_in">clear</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-built_in">dfs</span>(num, tmp);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == num.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[num[i]])&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(num[i]);<br>            vis[num[i]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(num, tmp);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>            vis[num[i]] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a>BM56 有重复项数字的全排列</h3><p>通过<code>last</code>来控制，在同一层递归的循环中，不重复使用相同数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-built_in">dfs</span>(nums, tmp, ans);<br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; tmp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> last = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i] || last == nums[i])<br>            <span class="hljs-keyword">continue</span>;<br>        last = nums[i];<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">dfs</span>(nums, tmp, ans);<br>        vis[i] = <span class="hljs-literal">false</span>;<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a>BM57 岛屿数量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                ans++;<br>                <span class="hljs-built_in">dfs</span>(i, j, grid);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> mr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> mc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span></span>&#123;<br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>        <span class="hljs-type">int</span> nr = r + mr[i];<br>        <span class="hljs-type">int</span> nc = c + mc[i];<br>        <span class="hljs-keyword">if</span>(nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[nr][nc] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(nr, nc, grid);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a>BM58 字符串的排列</h3><p>直接用set保存所有遇到过的字符串排列会使得空间复杂度达到O(n!)，通过先将字符串排序，然后每层递归都判断自己这个字符是否是第一次使用，这样可以将空间复杂度减少到O(n)。还有一种next_permutation算法，基于交换，对每一个排列找到需要交换的元素，得到下一个字典序的排列，可以将空间复杂度减少到O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; ans;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>string tmp;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>    vis.<span class="hljs-built_in">resize</span>(str.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">dfs</span>(str);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; vis[i<span class="hljs-number">-1</span>] &amp;&amp; str[i<span class="hljs-number">-1</span>] == str[i])<span class="hljs-keyword">continue</span>;<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(str[i]);<br>        <span class="hljs-built_in">dfs</span>(str);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>        vis[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="❓BM59-N皇后"><a href="#❓BM59-N皇后" class="headerlink" title="❓BM59 N皇后"></a>❓BM59 N皇后</h3><p>注释语句可以输出皇后的摆法。这种写法不需要借助vis数组来记录第几行，第几列，低级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Nqueen</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">search</span>(<span class="hljs-number">0</span>, n, C, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, <span class="hljs-type">int</span>&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur == n)&#123;<br>        ans++;<br>        <span class="hljs-comment">// for(int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">//     printf(&quot;%d%c&quot;, C[i]+1,&quot; \n&quot;[i==n-1]);</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        C[cur] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cur; j++)<br>            <span class="hljs-keyword">if</span>(C[cur] == C[j] || cur - C[cur] == j - C[j] || cur + C[cur] == j + C[j])&#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(ok)<br>            <span class="hljs-built_in">search</span>(cur + <span class="hljs-number">1</span>, n, C, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(cur==n)&#123;<br>		tot++;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,C[i]+<span class="hljs-number">1</span>,<span class="hljs-string">&quot; \n&quot;</span>[i==n<span class="hljs-number">-1</span>]);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!vis[<span class="hljs-number">0</span>][i]&amp;&amp;!vis[<span class="hljs-number">1</span>][cur+i]&amp;&amp;!vis[<span class="hljs-number">2</span>][cur-i+n])&#123;<br>			C[cur]=i;<br>			vis[<span class="hljs-number">0</span>][i]=vis[<span class="hljs-number">1</span>][cur+i]=vis[<span class="hljs-number">2</span>][cur-i+n]=<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">search</span>(cur+<span class="hljs-number">1</span>);<br>			vis[<span class="hljs-number">0</span>][i]=vis[<span class="hljs-number">1</span>][cur+i]=vis[<span class="hljs-number">2</span>][cur-i+n]=<span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a>BM60 括号生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    string tmp;<br>    <span class="hljs-built_in">dfs</span>(ans, tmp, n, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; ans, string&amp; cur, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> l)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> * n)&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt; n)&#123;<br>        string tmp = cur + <span class="hljs-string">&quot;(&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(ans, tmp, n, l+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l == n || l &gt; cur.<span class="hljs-built_in">size</span>() - l)&#123;<br>        string tmp = cur + <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(ans, tmp, n, l);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a>BM61 矩阵最长递增路径</h3><p>一种新的写法，不同于我习惯的循环向四个方向扩展。注意这是递归，会先探到死路在逐层返回，所以每个节点都已经充分访问过其可能路径，之后不需要再访问，可直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m; j++)&#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(matrix, dp, i, j, <span class="hljs-number">-1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; dp, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> pre)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix[r][c] &lt;= pre)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(dp[r][c] != <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[r][c];<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; n) tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r+<span class="hljs-number">1</span>, c, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r<span class="hljs-number">-1</span>, c, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(c + <span class="hljs-number">1</span> &lt; m) tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r, c+<span class="hljs-number">1</span>, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(c - <span class="hljs-number">1</span> &gt;= m)tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r, c<span class="hljs-number">-1</span>, matrix[r][c]));<br>    dp[r][c] = tmp + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> tmp + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a>BM62 斐波那契数列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a>BM63 跳台阶</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">jumpFloor</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">jumpFloor</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 最小花费爬楼梯</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>] + cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + cost[i<span class="hljs-number">-2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❗BM65-最长公共子序列-二"><a href="#❗BM65-最长公共子序列-二" class="headerlink" title="❗BM65 最长公共子序列(二)"></a>❗BM65 最长公共子序列(二)</h3><p>如果是只用求最长公共子序列的长度，只需要前半部分的代码。如果需要求具体的字串是什么，需要根据长度反推，从后往前推。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jjJsSS"><img src="https://s1.ax1x.com/2022/07/24/jjJsSS.png" srcset="/img/loading.gif" lazyload alt="jjJsSS.png"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i][j]表示s[:i]和s[:j]之间的最长公共字串长度</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 得到了最长公共字串的长度，接下来求对应子串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[s1.<span class="hljs-built_in">size</span>()][s2.<span class="hljs-built_in">size</span>()]);<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>(), j = s2.<span class="hljs-built_in">size</span>(); dp[i][j] &gt;= <span class="hljs-number">1</span>; )&#123;<br>        <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-comment">// dp[i][j]来自dp[i-1][j-1]</span><br>            ans += s1[i<span class="hljs-number">-1</span>];<br>            i--; j--;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>]) i--; <span class="hljs-comment">// 哪边大就来自哪边</span><br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;-1&quot;</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❗BM66-最长公共子串"><a href="#❗BM66-最长公共子串" class="headerlink" title="❗BM66 最长公共子串"></a>❗BM66 最长公共子串</h3><p>全部清零后，直接二重遍历，如果遇到更长的字串就记录长度和结束位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>];<br>    <span class="hljs-comment">// 最长公共字串的长度，以及结束位置</span><br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1[i<span class="hljs-number">-1</span>] == str2[j<span class="hljs-number">-1</span>])&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; maxLen)&#123;<br>                    maxLen = dp[i][j];<br>                    last = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(last - maxLen, maxLen);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM67-不同路径的数目-一"><a href="#BM67-不同路径的数目-一" class="headerlink" title="BM67 不同路径的数目(一)"></a>BM67 不同路径的数目(一)</h3><p>能到达<code>dp[i][j]</code>的路径只能来自<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a>BM68 矩阵的最小路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j] + dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = matrix[i][j] + <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a>BM69 把数字翻译成字符串</h3><p>由于每次解析要么用1位数，要么用2位数，所以<code>dp[i]</code>的状态由<code>dp[i-1]</code>和<code>dp[i-2]</code>推出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: 到nums[:i]为止有几种解析方式</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 如果当前数字是0，那么无法作为1位数解析</span><br>        dp[i] = nums[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : dp[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> twoDigits = nums[i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">10</span> * (nums[i<span class="hljs-number">-2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">// 十位数不能是0，并且值要在范围内</span><br>            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-2</span>] != <span class="hljs-number">0</span> &amp;&amp; twoDigits &gt;= <span class="hljs-number">10</span> &amp;&amp; twoDigits &lt;= <span class="hljs-number">26</span>)&#123;<br>                dp[i] += dp[i<span class="hljs-number">-2</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM70-兑换零钱-一"><a href="#BM70-兑换零钱-一" class="headerlink" title="BM70 兑换零钱(一)"></a>BM70 兑换零钱(一)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoney</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: 达到i金额，最少需要d[i]张纸币</span><br>    <span class="hljs-comment">// MAX: 不可能达到的最大值</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>], MAX = aim + <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(aim == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= aim; i++) dp[i] = MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= aim; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : arr)&#123;<br>            <span class="hljs-comment">// 目前检查的金额i大于钞票v，说明状态dp[i]可以由dp[i-v]达到</span><br>            <span class="hljs-keyword">if</span>(i &gt;= v)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-v] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[aim] == MAX ? <span class="hljs-number">-1</span> : dp[aim];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM71-最长上升子序列-一"><a href="#BM71-最长上升子序列-一" class="headerlink" title="BM71 最长上升子序列(一)"></a>BM71 最长上升子序列(一)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: arr[:i]以内的最长上升子序列</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-comment">// 这一步很关键，因为每一个元素都可以作为子序列的起点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) dp[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[i])&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 答案不一定是dp[arr.size()-1]</span><br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a>BM72 连续子数组的最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        array[i] = <span class="hljs-built_in">max</span>(array[i], array[i] + array[i<span class="hljs-number">-1</span>]);<br>        ans = <span class="hljs-built_in">max</span>(ans, array[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a>BM73 最长回文子串</h3><p>中心扩散法和动态规划法的时间复杂度都是O(N^2^)， 但是中心扩散法的空间复杂度是O(1)，动态规划是O(N^2^)。还有一种时间复杂度O(N)的马拉车算法，暂时还没学会。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLongestPalindrome</span><span class="hljs-params">(string A)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">getLen</span>(A, i, i));<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">getLen</span>(A, i, i + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">(string&amp; A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; A.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(A[l] == A[r])&#123;<br>            l--;<br>            r++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 此时A[l] ！= A[r]，需要减2</span><br>    <span class="hljs-keyword">return</span> r - l + <span class="hljs-number">1</span> - <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a>BM74 数字字符串转化成IP地址</h3><p>比牛客的官解稍微简洁一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-built_in">solve</span>(s, ans, <span class="hljs-built_in">vector</span>&lt;string&gt;(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; ans, vector&lt;string&gt; tmp, <span class="hljs-type">int</span> beg)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(beg == s.<span class="hljs-built_in">size</span>() &amp;&amp; tmp.<span class="hljs-built_in">size</span>() != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(beg &gt;= s.<span class="hljs-built_in">size</span>() &amp;&amp; tmp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-comment">// 拼接答案</span><br>        string s1 = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(string&amp; i : tmp)<br>            s1 += i + <span class="hljs-string">&#x27;.&#x27;</span>;<br>        ans.<span class="hljs-built_in">push_back</span>(s1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span> &amp;&amp; beg + len &lt;= s.<span class="hljs-built_in">size</span>(); len++)&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(beg, len));<br>        <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span> || (len &gt; <span class="hljs-number">1</span> &amp;&amp; s[beg] == <span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-keyword">break</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(beg, len));<br>        <span class="hljs-built_in">solve</span>(s, ans, tmp, beg + len);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❓BM75-编辑距离-一"><a href="#❓BM75-编辑距离-一" class="headerlink" title="❓BM75 编辑距离(一)"></a>❓BM75 编辑距离(一)</h3><p>用<code>dp[i][j]</code>表示从两个字符串首部各自到<code>str1[i]</code>和<code>str2[j]</code>为止的子串需要的编辑距离，那很明显<code>dp[str1.length][str2.length]</code>就是我们要求的编辑距离。</p>
<p>初始状态可以看做，空字符串想要变成另一个字符串，只能通过增加字符。</p>
<p>对于<code>dp[i+1][j+1] = min(dp[i][j], min(dp[i+1][j], dp[i][j+1])) + 1;</code>这句关键代码的解释：</p>
<p>希望<code>str1[:i+1]</code>和<code>str2[:j+1]</code>相同，已知<code>str1[i] != str2[j]</code>，那么<code>dp[i+1][j+1]</code>可以由以下转移：</p>
<ul>
<li><code>dp[i][j]</code>：<code>str1[:i]</code>和<code>str2[:j]</code>已经相同，修改<code>str1[i]</code></li>
<li><code>dp[i+1][j]</code>：<code>str1[:i+1]</code>和<code>str2[:j]</code>已经相同，删除字符<code>str1[i+1]</code></li>
<li><code>dp[i][j+1]</code>：<code>str1[:i]</code>和<code>str2[:j+1]</code>已经相同，增加字符<code>str2[j]</code>到str1[:i]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">editDistance</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = str1.<span class="hljs-built_in">size</span>(), len2 = str2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-comment">// 初始化边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)<br>        dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++)<br>        dp[<span class="hljs-number">0</span>][i+<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 遍历str1的每个位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)&#123;<br>        <span class="hljs-comment">// 遍历str2对应的每个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1[i] == str2[j]) <span class="hljs-comment">// 字符相同，不需要编辑，直接从dp[i][j]转移</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 需要从这3个来源选最小的，增加1个编辑距离</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❓BM76-正则表达式匹配"><a href="#❓BM76-正则表达式匹配" class="headerlink" title="❓BM76 正则表达式匹配"></a>❓BM76 正则表达式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure>
<h3 id="BM77-最长的括号子串"><a href="#BM77-最长的括号子串" class="headerlink" title="BM77 最长的括号子串"></a>BM77 最长的括号子串</h3><p>始终保持栈底元素为当前已经遍历过的元素中<strong>最后一个没有被匹配的右括号的下标</strong>，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p>
<ol>
<li>对于遇到的每个<code>(</code> ，将它的下标放入栈中</li>
<li>对于遇到的每个<code>)</code>，先弹出栈顶元素表示匹配了当前右括号：<ol>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，将其下标放入栈中来更新我们之前提到的<strong>最后一个没有被匹配的右括号的下标</strong></li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为<strong>以该右括号为结尾的最长有效括号的长度</strong></li>
</ol>
</li>
<li>从前往后遍历字符串并更新答案即可。</li>
</ol>
<p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的<strong>最后一个没有被匹配的右括号的下标</strong>，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。(注意，这样栈里无论如何都<strong>至少有一个元素</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>(); <br>                ans = <span class="hljs-built_in">max</span>(i - st.<span class="hljs-built_in">top</span>(), ans);<br>            &#125;  <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM78-打家劫舍-一"><a href="#BM78-打家劫舍-一" class="headerlink" title="BM78 打家劫舍(一)"></a>BM78 打家劫舍(一)</h3><p><code>dp[i]</code>表示<code>nums[:i]</code>部分（左闭右开）能取得的最大值。对于每一个i，要么不偷，那么<code>dp[i+1]=dp[i]</code>；要么偷，那么<code>dp[i+1]=dp[i-1]+nums[i]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        dp[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i], dp[i<span class="hljs-number">-1</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM79-打家劫舍-二"><a href="#BM79-打家劫舍-二" class="headerlink" title="BM79 打家劫舍(二)"></a>BM79 打家劫舍(二)</h3><p>使用两个dp数组，分别忽略第一个和最后一个房子进行dp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 最开始的房不偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// 最后一个房不偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp2</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        dp1[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp1[i], dp1[i<span class="hljs-number">-1</span>] + nums[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>        dp2[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp2[i], dp2[i<span class="hljs-number">-1</span>] + nums[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp1[nums.<span class="hljs-built_in">size</span>()], dp2[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM80-买卖股票的最好时机-一"><a href="#BM80-买卖股票的最好时机-一" class="headerlink" title="BM80 买卖股票的最好时机(一)"></a>BM80 买卖股票的最好时机(一)</h3><p>不需要用到动态规划，只用遍历数组，维护目前遇到的最小值和最大利润，遍历时更新这两个值即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : prices)&#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, i - minPrice);<br>        minPrice = <span class="hljs-built_in">min</span>(minPrice, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM81-买卖股票的最好时机-二"><a href="#BM81-买卖股票的最好时机-二" class="headerlink" title="BM81 买卖股票的最好时机(二)"></a>BM81 买卖股票的最好时机(二)</h3><p>一个合理的买卖股票过程就是寻找数组中的一段连续上升子序列。只要找出所有的连续上升子序列，就可以得到总利润。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, last = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(prices[i] &lt; prices[i<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-comment">// 连续上升子序列断了，结算之前的利润，更新起点为当前价格</span><br>            ans += prices[i<span class="hljs-number">-1</span>] - last;<br>            last = prices[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(*prices.<span class="hljs-built_in">rbegin</span>() &gt; last)<br>        ans += *prices.<span class="hljs-built_in">rbegin</span>() - last;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="❓BM82-买卖股票的最好时机-三"><a href="#❓BM82-买卖股票的最好时机-三" class="headerlink" title="❓BM82 买卖股票的最好时机(三)"></a>❓BM82 买卖股票的最好时机(三)</h3><ul>
<li><code>dp[i][0]</code>表示到第i天为止没有买过股票的最大收益</li>
<li><code>dp[i][1]</code>表示到第i天为止买过一次股票还没有卖出的最大收益</li>
<li><code>dp[i][2]</code>表示到第i天为止买过一次也卖出过一次股票的最大收益</li>
<li><code>dp[i][3]</code>表示到第i天为止买过两次只卖出过一次股票的最大收益</li>
<li><code>dp[i][4]</code>表示到第i天为止买过两次同时也买出过两次股票的最大收益</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, last = prices[<span class="hljs-number">0</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">-1e9</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 没有操作过，所以和前一天一样</span><br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 第一次买入，从没操作过转移</span><br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        <span class="hljs-comment">// 第一次卖出，从第一次买入</span><br>        dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>        <span class="hljs-comment">// 第二次买入，从没操作过转移</span><br>        dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>        <span class="hljs-comment">// 第二次卖出，从第一次买入</span><br>        dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="BM83-字符串变形"><a href="#BM83-字符串变形" class="headerlink" title="BM83 字符串变形"></a>BM83 字符串变形</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">trans</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;string&gt; tmp;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) s[i] -= <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) s[i] += <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(last, i - last));<br>            last = i + <span class="hljs-number">1</span>;<br><br>        &#125;<br>    &#125;<br>    string ans = s.<span class="hljs-built_in">substr</span>(last, s.<span class="hljs-built_in">size</span>() - last);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = tmp.<span class="hljs-built_in">rbegin</span>(); it != tmp.<span class="hljs-built_in">rend</span>(); ++it)&#123;<br>        ans += <span class="hljs-string">&quot; &quot;</span> + (*it);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM84-最长公共前缀"><a href="#BM84-最长公共前缀" class="headerlink" title="BM84 最长公共前缀"></a>BM84 最长公共前缀</h3><p>牛客上只有O(N*M)的复杂度，N是字符串数量，M是字符串平均长度。但是牛客的进阶要求是O(N)，题解随便翻翻没有翻到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> len = strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-type">char</span> c = strs[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span>(strs[j].<span class="hljs-built_in">size</span>() == i || strs[j][i] != c)&#123;<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="BM85-验证IP地址"><a href="#BM85-验证IP地址" class="headerlink" title="BM85 验证IP地址"></a>BM85 验证IP地址</h3><p>稍微复杂的模拟，注意代码的结构即可。注意<code>(i = s.find(spliter))</code>这里必须要括号，因为<code>=</code>的优先级很低，如果不带括号就是<code>i = (s.find(spliter) &amp;&amp; i != s.npos)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(IP.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIPv4</span>(IP))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv4&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIPv6</span>(IP))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv6&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string s, string spliter)</span></span>&#123;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">while</span>((i = s.<span class="hljs-built_in">find</span>(spliter)) &amp;&amp; i != s.npos)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>        s = s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>);<br>    &#125;<br>    res.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv4</span><span class="hljs-params">(string ip)</span></span>&#123;<br>    vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(ip, <span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-comment">// 必须有4个数</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>        cout &lt;&lt; s[i] &lt;&lt; endl;<br>        <span class="hljs-comment">// 不允许缺省</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 不允许前导0</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> &amp;&amp; s[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 必须每一位都是数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s[i])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(s[i]);<br>        <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv6</span><span class="hljs-params">(string ip)</span></span>&#123;<br>    vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(ip, <span class="hljs-string">&quot;:&quot;</span>);<br>    <span class="hljs-comment">// 必须有8组</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-comment">//位数必须是1-4</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s[i])<br>            <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">isdigit</span>(c) || (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) || (<span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM86-大数加法"><a href="#BM86-大数加法" class="headerlink" title="BM86 大数加法"></a>BM86 大数加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>, a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() || i &lt; t.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        a = i &lt; s.<span class="hljs-built_in">size</span>() ? s[i] : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        b = i &lt; t.<span class="hljs-built_in">size</span>() ? t[i] : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        tmp += a + b - (<span class="hljs-string">&#x27;0&#x27;</span> * <span class="hljs-number">2</span>);<br>        ans += (tmp % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        tmp /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp) ans += <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="BM87-合并两个有序的数组"><a href="#BM87-合并两个有序的数组" class="headerlink" title="BM87 合并两个有序的数组"></a>BM87 合并两个有序的数组</h3><p><code>A[m:]</code>部分是空的，所以不能思维定式从小到大处理，而是从大到小处理，优先填补<code>A[m:]</code>这部分空数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = m - <span class="hljs-number">1</span>, b = n - <span class="hljs-number">1</span>, i = m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(a &gt;= <span class="hljs-number">0</span> || b &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span>) A[i--] = B[b--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b &lt; <span class="hljs-number">0</span>) A[i--] = A[a--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[a] &gt; B[b]) A[i--] = A[a--];<br>        <span class="hljs-keyword">else</span> A[i--] = B[b--];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM88-判断是否为回文字符串"><a href="#BM88-判断是否为回文字符串" class="headerlink" title="BM88 判断是否为回文字符串"></a>BM88 判断是否为回文字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; l &lt; r; l++, r--)&#123;<br>        <span class="hljs-keyword">if</span>(str[l] != str[r])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM89-合并区间"><a href="#BM89-合并区间" class="headerlink" title="BM89 合并区间"></a>BM89 合并区间</h3><p>先按照区间的左边界排序，然后逐一判断合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;Interval&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;<br>    vector&lt;Interval&gt; ans;<br>    <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    ans.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : intervals)&#123;<br>        <span class="hljs-keyword">auto</span> tmp = ans.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span>(tmp.start &lt;= i.start &amp;&amp; tmp.end &gt;= i.start)&#123;<br>            ans[ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>].end = <span class="hljs-built_in">max</span>(tmp.end, i.end);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Interval&amp; a, <span class="hljs-type">const</span> Interval&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.start != b.start ? a.start &lt; b.start : a.end &lt; b.end;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM90-最小覆盖子串"><a href="#BM90-最小覆盖子串" class="headerlink" title="BM90 最小覆盖子串"></a>BM90 最小覆盖子串</h3><p>设置两个指针left，right。表示S的子串tmp可由left和right表示，当需要添加元素时候，就将right++，pop元素就left++。</p>
<p>我们用哈希表判断left到right是否完全包含T，动态维护窗口中所有字符以及个数。具体过程如下：</p>
<p>如果新加入的字符是被需要的（指在T里面），那么这个字符加入到窗口中，当窗口中的字符数目和被需要的数目相等时候，匹配度加一。right右移，这里匹配度是window里面的字符与need里面字符相等的数目。</p>
<p>如果新加入的字符不被需要（指不在T里面），right右移</p>
<p>当匹配度等于被需要的字符种类数，说明left-right覆盖到了T的所有字符，并且记录当前的left和right位置，然后就开始向右移动left</p>
<p>如果left位置的字符是被T所需要的，windo所统计的left字符要减一，当窗口中left处的字符数目小于need的字符数目，匹配度减一</p>
<p>如果left位置的字符不是被T所需要的，直接右移即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string S, string T)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> need[<span class="hljs-number">128</span>], cnt[<span class="hljs-number">128</span>], target = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(need, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(need));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: T) &#123;<br>        <span class="hljs-comment">// 记录T中出现多少种字符</span><br>        <span class="hljs-keyword">if</span>(need[c] == <span class="hljs-number">0</span>)target++;<br>        need[c]++;<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, minlen = INT_MAX;<br>    <span class="hljs-comment">// match记录窗口匹配多少个字符</span><br>    <span class="hljs-type">int</span> match = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; r &lt; S.<span class="hljs-built_in">size</span>(); r++)&#123;<br>        <span class="hljs-type">char</span> c = S[r];<br>        <span class="hljs-keyword">if</span>(need[c] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果这个字符有需求</span><br>            cnt[c]++;<br>            <span class="hljs-comment">// 如果这个字符的出现次数满足要求了</span><br>            <span class="hljs-keyword">if</span>(cnt[c] == need[c]) match++;<br>        &#125;<br>        <span class="hljs-comment">// 当目前字串符合要求时，尽量尝试缩小左边界，直到窗口不符合要求</span><br>        <span class="hljs-keyword">while</span>(match == target)&#123;<br>            <span class="hljs-keyword">if</span>(minlen &gt; r - l + <span class="hljs-number">1</span>)&#123;<br>                minlen = r - l + <span class="hljs-number">1</span>;<br>                start = l;<br>            &#125;<br>            c = S[l];<br>            <span class="hljs-keyword">if</span>(need[c] &gt; <span class="hljs-number">0</span>)&#123;<br>                cnt[c]--;<br>                <span class="hljs-keyword">if</span>(cnt[c] &lt; need[c]) match--;<br>            &#125;<br>            l++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minlen == INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : S.<span class="hljs-built_in">substr</span>(start, minlen);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM91-反转字符串"><a href="#BM91-反转字符串" class="headerlink" title="BM91 反转字符串"></a>BM91 反转字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-built_in">swap</span>(str[i], str[str.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM92-最长无重复子数组"><a href="#BM92-最长无重复子数组" class="headerlink" title="BM92 最长无重复子数组"></a>BM92 最长无重复子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> loc[<span class="hljs-number">100005</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span>; i++)<br>        loc[i] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; r &lt; arr.<span class="hljs-built_in">size</span>(); r++)&#123;<br>        <span class="hljs-keyword">if</span>(loc[arr[r]] != <span class="hljs-number">-1</span>)&#123;<br>            l = <span class="hljs-built_in">max</span>(l, loc[arr[r]]);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, r - l);<br>        loc[arr[r]] = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❓❗BM93-盛水最多的容器"><a href="#❓❗BM93-盛水最多的容器" class="headerlink" title="❓❗BM93 盛水最多的容器"></a>❓❗BM93 盛水最多的容器</h3><p>双指针+贪心。双指针分别指向数组的两端，表示从最宽的地方开始计算，每次舍弃掉容器较短的那边，向内部移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> cap = <span class="hljs-built_in">min</span>(height[left], height[right]) * (right - left);<br>        ans = <span class="hljs-built_in">max</span>(ans, cap);<br>        <span class="hljs-comment">//哪边小就舍弃哪边</span><br>        <span class="hljs-keyword">if</span>(height[left] &lt; height[right])<br>            left++;<br>        <span class="hljs-keyword">else</span><br>            right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❓❗BM94-接雨水问题"><a href="#❓❗BM94-接雨水问题" class="headerlink" title="❓❗BM94 接雨水问题"></a>❓❗BM94 接雨水问题</h3><ul>
<li>step 1：检查数组是否为空的特殊情况</li>
<li>step 2：准备双指针，分别指向数组首尾元素，代表最初的两个边界</li>
<li>step 3：指针往中间遍历，遇到更低柱子就是底，用较短的边界减去底就是这一列的接水量，遇到更高的柱子就是新的边界，更新边界大小。</li>
</ul>
<p>两边的双指针框定了木桶的两边，具体能接多少水取决于短板，遍历时计算每一列能存多少水。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxWater</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> maxL = <span class="hljs-number">0</span>, maxR = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        maxL = <span class="hljs-built_in">max</span>(maxL, arr[l]);<br>        maxR = <span class="hljs-built_in">max</span>(maxR, arr[r]);<br>        <span class="hljs-keyword">if</span>(maxL &gt; maxR)<br>            ans += maxR - arr[r--];<br>        <span class="hljs-keyword">else</span><br>            ans += maxL - arr[l++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure>
<h3 id="BM98-螺旋矩阵"><a href="#BM98-螺旋矩阵" class="headerlink" title="BM98 螺旋矩阵"></a>BM98 螺旋矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> mc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">while</span> (cnt &lt; n * m) &#123;<br>        <span class="hljs-type">int</span> nr = r + mr[p];<br>        <span class="hljs-type">int</span> nc = c + mc[p];<br>        <span class="hljs-keyword">if</span> (nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; n &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; m &amp;&amp; !vis[nr][nc]) &#123;<br>            <span class="hljs-comment">// 什么也不做</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p = (p + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            nr = r + mr[p];<br>            nc = c + mc[p];<br>        &#125;<br>        vis[nr][nc] = <span class="hljs-literal">true</span>;<br>        cnt++;<br>        ans.<span class="hljs-built_in">push_back</span>(matrix[nr][nc]);<br>        r = nr;<br>        c = nc;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="❓BM99-顺时针旋转矩阵"><a href="#❓BM99-顺时针旋转矩阵" class="headerlink" title="❓BM99 顺时针旋转矩阵"></a>❓BM99 顺时针旋转矩阵</h3><p>这个做法需要背住，不然想不到。先沿着左对角线做反转，然后在根据中轴线做轴对称，结果就是顺时针旋转90度的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">rotateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; mat, <span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-built_in">swap</span>(mat[i][j], mat[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">reverse</span>(mat[i].<span class="hljs-built_in">begin</span>(), mat[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> mat;<br>&#125;<br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/college/blobkchain/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">区块链学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Linux-C++/%E5%B9%B6%E8%A1%8C%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">并行公开课笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

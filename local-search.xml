<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/Java-Spring/java-jvm/"/>
    <url>/Java-Spring/java-jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li><p>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</p></li><li><p>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p></li><li><p>class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。</p></li><li><p>完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <code>&lt;clinit&gt;</code> 方法，编译器会在 <code>.java</code> 文件被编译成 <code>.class</code> 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;()</code> 方法。</p></li></ol><table><thead><tr><th>内存区域</th><th>内存作用范围</th><th></th></tr></thead><tbody><tr><td>程序计数器</td><td>线程私有</td><td>当前线程所执行的字节码的行号指示器。</td></tr><tr><td>Java 虚拟机栈</td><td>线程私有</td><td>每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 <strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong> 等信息。每个方法的执行都对应一次入栈出栈。</td></tr><tr><td>本地方法栈</td><td>线程私有</td><td>与虚拟机栈的作用相似。区别在于：<strong>虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务</strong>。本地方法并不是用 Java 实现的，而是由 C 语言实现的。<code>OutOfMemoryError</code></td></tr><tr><td>Java 堆</td><td>线程共享</td><td>存放对象实例，几乎所有的对象实例都是在这里分配内存。</td></tr><tr><td>方法区</td><td>线程共享</td><td>永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</td></tr><tr><td>运行时常量池</td><td>线程共享</td><td>用于存放编译器生成的各种字面量和符号引用，会在类加载后被放入这个区域。</td></tr><tr><td>直接内存</td><td>非运行时数据区</td><td>使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。</td></tr></tbody></table><p>OutOfMemoryError</p><ul><li><p>堆空间溢出</p><ul><li>内存泄漏</li><li>内存溢出</li></ul></li><li><p>GC开销超过限制：超过 <code>98%</code> 的时间用来做 GC 并且回收了不到 <code>2%</code> 的堆内存时会抛出此异常。一般是因为堆太小。</p></li><li><p>永久代空间不足PermGen space</p></li><li><p>元数据空间不足：Java8后永久代被元数据区取代，不在堆中与老年代相连，而是在本地内存中。</p></li><li><p>无法新建本地线程：线程数 &#x3D; (MaxProcessMemory - JVMMemory - ReservedOsMemory) &#x2F; (ThreadStackSize)</p></li><li><p>直接内存溢出</p></li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如何检测对象是否还存活：</p><ul><li>因为<strong>循环引用</strong>的存在，JVM不适用引用计数法。</li><li>可达性分析：通过 <strong>GC Roots</strong> 作为起始点进行搜索，JVM 将能够到达到的对象视为<strong>存活</strong>，不可达的对象视为<strong>死亡</strong>。</li></ul><p>引用类型：</p><ul><li>强引用：被强引用关联的对象不会被垃圾回收器回收。用<code>new</code>创建的就是强引用。</li><li>软引用：只有在内存不够的情况下才会被回收。用<code>SoftReference&lt;Object&gt;</code>创建</li><li>弱引用：在<strong>下次</strong>垃圾回收发生时一定被回收。用 <code>WeakReference</code> 类来创建。<ul><li><code>WeakHashMap</code> 的 <code>Entry</code> 继承自 <code>WeakReference</code>，主要用来实现缓存。使用不用的引用可以实现分代缓存，让不常使用的对象容易被回收。</li></ul></li><li>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><p>对方法区的回收主要是对<strong>常量池的回收</strong>和对<strong>类的卸载</strong>。</p><p>类的卸载需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>在大量使用反射、动态代理、CGLib等字节码框架这类频繁自定义<code>ClassLoader</code>的场景需要JVM有这个功能。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>性能指标：</p><ul><li><strong>停顿时间</strong> - 停顿时间是因为 GC 而导致程序不能工作的时间长度。</li><li><strong>吞吐量</strong> - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。</li></ul><h4 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记 - 清除（Mark-Sweep）"></a>标记 - 清除（Mark-Sweep）</h4><p>将需要回收的对象进行标记，然后清理掉被标记的对象。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h4 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记 - 整理（Mark-Compact）"></a>标记 - 整理（Mark-Compact）</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是<strong>只使用了内存的一半</strong>。</p><p>现在的商业虚拟机都<strong>采用这种收集算法来回收年轻代</strong>，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 <code>-XX:SurvivorRatio</code> 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>一般将 Java 堆分为年轻代和老年代。</p><ul><li>年轻代使用：<strong>复制</strong> 算法</li><li>老年代使用：<strong>标记 - 清理</strong> 或者 <strong>标记 - 整理</strong> 算法</li></ul><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png" alt="img" style="zoom:67%;" /><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a><strong>新生代</strong></h5><p>正如上所说，JVM会把eden中存活的对象和一个Survivor的对象复制到另一个Survivor中，。JVM会记录Survivor区中的对象一共被复制了多少次，如果达到15次 （<code>-XX:+MaxTenuringThreshold</code>），那么晋升为<strong>老年代</strong>。如果单个Survivor已经被占用了50%（ <code>-XX:TargetSurvivorRatio</code>），那么复制次数较高的对象晋升<strong>老年代</strong>。</p><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>通常是从Survivor拷贝来的对象。如果对象较大，新生代中无法找到连续空闲空间，会直接分配到老年代。</p><h5 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h5><p>早期的方法区在这里，JDK8之后不在了。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><img src="https://s2.loli.net/2022/08/25/2cvd9nKhzNoZXOY.png" alt="img" style="zoom:67%;" /><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><p>注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。</p><h4 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h4><p>最基本，最悠久。是 <strong><code>client</code> 模式下的默认收集器配置</strong>，因为该模式下，分配给虚拟机管理的内存一般不会很大。</p><p><strong>串行收集器采用单线程 stop-the-world 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。</p><p>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。</p><p>Serial和Serial Old是分别用于收集新生代和老年代的串行收集器。</p><h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><blockquote><p>开启选项：<code>-XX:+UseParallelGC</code><br>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p><p>开启选项：<code>-XX:+UseParallelOldGC</code><br>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Parallel Old</strong> 收集器组合来进行内存回收。</p></blockquote><p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器</strong>。</p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li><li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在<strong>后台运算</strong>而不需要太多交互的任务。</li></ul><p><strong>并行收集器是 server 模式下的默认收集器。</strong></p><p>并行收集器与串行收集器工作模式<strong>相似</strong>，都是 stop-the-world 方式，只是暂停时<strong>并行</strong>地进行垃圾收集。并行收集器<strong>年轻代采用复制算法</strong>，<strong>老年代采用标记-整理</strong>，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p><p>在<strong>注重吞吐量以及 CPU 资源敏感</strong>的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</p><h4 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h4><blockquote><p>开启选项：<code>-XX:+UseConcMarkSweepGC</code><br>打开此开关后，使用 <strong>CMS</strong> + <strong>ParNew</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p></blockquote><p>并发标记清除收集器是以<strong>获取最短停顿时间</strong>为目标。</p><p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 <code>Concurrent Mode Failure</code> ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。是一种以获取最短停顿时间为目标的收集器。运行步骤如下：</p><ol><li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li><strong>并发清除</strong>：回收在标记阶段被鉴定为不可达的对象。不需要停顿。</li></ol><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p><img src="https://s2.loli.net/2022/08/25/zrjmT4tSKyfe7NR.png" alt="image.png"></p><p>CMS回收年轻代：如上面所说，将堆空间分割为一个Eden区和两个Survivor区，每次将Eden和一个Survivor中的存活对象复制到另一个Survivor，年龄达到阈值的晋升老年代。</p><p>CMS回收老年代：发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。</p><ul><li>初始标记是一个短暂暂停的、可达对象被标记的阶段。</li><li>并发标记寻找活跃对象在应用连续执行时。</li><li>最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。</li><li>没有被标记的对象被<strong>就地释放</strong>，不进行压缩操作，也就是从内存分布中还是散乱的。</li></ul><p>CMS 收集器具有以下缺点：</p><ul><li>并发收集 - 并发指的是用户线程和 GC 线程同时运行。</li><li>吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾 - 可能出现<code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。<ul><li>可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。</li></ul></li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。<ul><li>可以使用 <code>-XX:+UseCMSCompactAtFullCollection</code> ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。</li><li>可以使用 <code>-XX:CMSFullGCsBeforeCompaction</code> ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。</li></ul></li></ul><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>开启选项：<code>-XX:+UseParNewGC</code></p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/jvm/jvm-gc-par-new.jpg" alt="img"></p><p>ParNew其实就是Serial的多线程版本。Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>开启选项：<code>-XX:+UseG1GC</code></p><p><strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 最大的特点是引入<strong>分区</strong>的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。</p><h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。</p><img src="https://s2.loli.net/2022/08/25/5fLhHgIjz6BKlFc.png" alt="image.png" style="zoom:67%;" /><p>通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p><img src="https://s2.loli.net/2022/08/25/ykZAdfKsFw9VM8G.png" alt="image.png"></p><ol><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong> - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong> - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><p>特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><p>收集年轻代：</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/Java-Spring/java-multithread/"/>
    <url>/Java-Spring/java-multithread/</url>
    
    <content type="html"><![CDATA[<p>创建多线程的方式：</p><ol><li>继承Thread类，重写run()，调用start()启动。</li><li>实现Runnable接口（JDK8+），函数式接口可以用lambda来简化。</li><li>Callable</li><li>FutureTask</li></ol><p>以上两种方法都是调用run方法，是没有返回值的。用Callable接口和Future类可以解决，也就是异步模型。</p><p>Callable接口与Runnable类似，但是是有返回值的，而且支持<strong>泛型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Callable</code>一般是配合线程池工具<code>ExecutorService</code>来使用的。<code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果，如果还没返回值则阻塞。</p><p><code>Future</code>接口只有几个比较简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> paramBoolean)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> paramLong, TimeUnit paramTimeUnit)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不需要返回值，可以声明 <code>Future&lt;?&gt;</code>形式类型、并返回 <code>null</code>作为底层任务的结果。</p><p>FutureTask实现RunableFuture，RunableFuture继承Runnable和Future接口。FutureTask提供了Future接口中方法的默认实现。</p><p>与Callable的区别在于，submit之后Callable回得到一个Future，再用get获取结果。FutureTask在submit后没有返回值，直接用GET获取。在高并发环境下，Callable和FutureTask可能被多次创建，但FutureTask保证任务只执行一次。</p><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类的几个常用的方法：</p><ul><li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li><li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li><li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li><li>sleep()：静态方法，使当前正在运行的线程睡眠一段时间；</li><li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li></ul><p>ThreadGroup线程组。每个Thread一定属于一个线程组，如果new时没有指定，默认加入父线程线程组。线程组也可以包含其他线程组。</p><p>Java中线程可以指定优先级，从1-10，默认为5，但只是参考值，操作系统不一定支持10档划分，真正决定的是操作系统的线程调度算法。通常高优先级线程会有更高几率得到执行。</p><p>守护线程（Daemon）默认的优先级比较低。如果所有非守护线程结束，那么守护线程自动结束。应用场景为：当所有非守护线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。</p><p>线程优先级不会超过所在<strong>线程组的最大优先级</strong>。</p><p>Java线程定义了6个状态:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Thread.State 源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    NEW,<span class="hljs-comment">//还没调用start()。Thread内部有一个成员记录是否start，所以不能start两次</span><br>    RUNNABLE,<span class="hljs-comment">//其实包含了运行和就绪两种状态</span><br>    BLOCKED,<span class="hljs-comment">//等待锁</span><br>    WAITING,<br>    TIMED_WAITING,<span class="hljs-comment">//超时等待，比起waiting多了超时自动唤醒</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用如下3个方法会使线程进入waiting状态：</p><ul><li>Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li><li>Thread.join()：等待调用的线程执行完毕，底层调用的是Object实例的wait方法；</li><li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。</li></ul><p>调用如下方法会使线程进入timed_waiting状态：</p><ul><li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li><li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()&#x2F;notifyAll()唤醒；</li><li>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li></ul><p>注意：只有获得锁的进程才能进入2种waiting状态。</p><p>join()方法是Thread类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。比如我在B线程的代码中加入了A.join()，意思就是B需要等待A执行完再继续执行。应用场景：子线程进行耗时运算，而父线程需要等待运算结果进行后续处理，就可以在父线程中调用子线程的join。</p><p>Java线程间通信：</p><ol><li>锁，用synchronized给对象或者类上锁</li><li>等待和通知机制。wait和notify是Object的方法，wait会让调用者释放对象锁，notify会唤醒等待对象锁的线程。由于需要操作对象锁，所以必须放在同步代码块或者同步方法中。</li><li>信号量</li><li>管道。管道是基于“管道流”的通信方式。JDK提供了<code>PipedWriter</code>、 <code>PipedReader</code>、 <code>PipedOutputStream</code>、 <code>PipedInputStream</code>。其中，前面两个是基于字符的，后面两个是基于字节流的。</li></ol><p>ThreadLocal是一个本地线程副本变量工具类。内部是一个<strong>弱引用</strong>的Map来维护。在new Thread传入同一个ThreadLocal对象，但是各线程内的ThreadLocal实际上互相独立。</p><p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接。</p><p>InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值。</p><p><img src="https://s2.loli.net/2022/08/20/63kOvCfoNeEXYdw.png" alt="img"></p><p>Java中使用的是<strong>共享内存并发模型</strong>。</p><p>尽管堆是共享的，但是堆中还是会有内存不可见的问题，因为现代计算机往往会在高速缓存中缓存共享变量。</p><p>Java中每个线程有一个私有的本地内存，保存了该线程已读写的共享变量的副本，这是一个抽象的概念，并不真实存在。</p><p>Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。</p><p>注意，根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p><p>volatile关键字保证多线程操作共享变量的<strong>可见性</strong>以及<strong>禁止指令重排序</strong>，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>编译器和处理器为了提高效率，往往会对指令做重排序。指令重排一般分三种情况：</p><ul><li><strong>编译器优化重排</strong>：编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li><li><strong>内存系统重排</strong>：由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li></ul><p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>顺序一致性模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li></ul><p>JMM没有保证顺序一致性，当一个线程吧数据写入本地内存，还没有刷到主内存时，这个写操作只对自己可见，其他线程看到的执行顺序时不一样对的。</p><p>在JMM中，临界区内（同步块或同步方法中）的代码可以发生重排序（但不允许临界区内的代码“逃逸”到临界区之外，因为会破坏锁的内存语义）。由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门。</p><p>对于未同步的多线程程序，JMM只提供<strong>最小安全性</strong>：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。为了实现这个安全性，JVM在堆上分配对象时，首先会对<strong>内存空间清零</strong>，然后才会在上面分配对象（这两个操作是同步的）。</p><p><strong>JMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。</strong></p><ol><li>顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果） </li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）</li><li>JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读写操作都具有原子性。</li></ol><p>JMM的规定是：对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong>因此对程序员提供了<strong>happens-before规则</strong>：如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/concurrent/java-concurrent-basic-mechanism.png" alt="img" style="zoom:67%;" /><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：</p><ul><li>保证变量的<strong>内存可见性</strong></li><li>禁止volatile变量与普通变量<strong>重排序</strong>（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）</li></ul><p>JVM保证了volatile变量的可见性，但是普通变量可能还是有问题。</p><p>JVM通过<strong>内存屏障</strong>来限制处理器重排。内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li></ol><h3 id="synchronized和锁"><a href="#synchronized和锁" class="headerlink" title="synchronized和锁"></a>synchronized和锁</h3><p>Java中的锁都是基于对象的。类锁也是一种对象锁。上锁一般三种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 关键字在实例方法上，锁为当前实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在静态方法上，锁为当前Class对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">classLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// code</span><br>&#125;<br><br><span class="hljs-comment">// 关键字在代码块上，锁为括号里面的对象。这种与上一种等价</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.getClass()) &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 关键字在代码块上，锁为括号里面的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">blockLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java6之后为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p>这里有一段锁升级和降级的知识</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>Java锁基于对象，那么对象里肯定有地方保存了锁的信息。每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。子宽取决于操作系统位数，内容为：</p><ul><li>Mark World：存储对象的hashCode或锁信息等</li><li>Class Metadata Adddress：存储到对象类型数据的指针</li><li>Array Length：数组长度（只有数组类型才有）</li></ul><p>Mark World格式：</p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200629191250.png" alt="img" style="zoom:67%;" /><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Hotspot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><p>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁&#x2F;解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p><p><strong>实现原理</strong>：一个线程在第一次进入同步块时，会在对象头和栈帧中的<strong>锁记录</strong>里存储锁的偏向的<strong>线程ID</strong>。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p><ul><li>成功，表示之前的线程不存在了， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，<strong>开销很大</strong>。如果应用程序里所有的锁通常出于竞争状态，那么偏向锁就会是一种累赘，可以选择一开始就把偏向锁这个默认功能给关闭。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。</p><p>JVM会为每个线程在当前线程的栈帧中创建用于<strong>存储锁记录的空</strong>间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>synchronized 无法通过<strong>破坏不可抢占条件</strong>来避免死锁。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>与内置锁 <code>synchronized</code> 不同的是，**<code>Lock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作**，所有获取锁、释放锁的操作都是显式的操作。</p><p>接口：</p><ul><li><code>lock()</code> - 获取锁。</li><li><code>unlock()</code> - 释放锁。</li><li><code>tryLock()</code> - 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</li><li><code>tryLock(long time, TimeUnit unit)</code> - 和 <code>tryLock()</code> 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</li><li><code>lockInterruptibly()</code> - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</li><li><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition 实现了管程模型里面的条件变量。</p><p>内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code> ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<span class="hljs-comment">//类似wait</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<span class="hljs-comment">//类似notify</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<span class="hljs-comment">//类似notifyAll</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>获取锁操作 <code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。</p><p>与无条件获取锁相比，tryLock 有更完善的容错机制。</p><ul><li><code>tryLock()</code> - <strong>可轮询获取锁</strong>。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法<strong>无论成败都会立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</li><li><code>tryLock(long, TimeUnit)</code> - <strong>可定时获取锁</strong>。和 <code>tryLock()</code> 类似，区别仅在于这个方法在<strong>获取不到锁时会等待一定的时间</strong>，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。</li><li><code>lockInterruptibly()</code> - <strong>可中断获取锁</strong>。可中断获取锁可以在获得锁的同时保持对中断的响应。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS: Compare and Swap</p><blockquote><p>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p></blockquote><p>在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。Java实现CAS使用<code>Unsafe</code>类，里面有一些native方法（对于int，long，object等类型的CAS操作，即多线程安全的赋值），是C++实现的，它的具体实现和操作系统、CPU都有关系。</p><p>JDK提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。JDK17中有17个类，类名都是AtomicXXX，主要是四中类型：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段（属性）</li></ul><p>比如JDK1.8之后<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法是调用<code>Unsafe</code>类的方法来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>CAS有三大问题：</p><ol><li><p>ABA问题。就是一个值原来是A，变成了B，又变回了A。解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从JDK 1.5开始，JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>类来解决ABA问题。这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p></li><li><p>循环时间长开销大。CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。解决思路是让JVM支持处理器提供的<strong>pause指令</strong>。pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多。</p></li><li><p>只能保证一个共享变量的原子操作：使用JDK 1.5开始就提供的<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；使用锁。锁内的临界区代码可以保证只有当前线程能操作。</p></li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即<code>抽象队列同步器</code>。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。我们只需要实现几个protected方法也可以实现自定义的同步器。</p><p>AQS内部使用了一个volatile的变量state来作为资源的标识。还有几个protected方法来获取和修改state，基于Unsafe的CAS实现的。AQS类本身实现的是一些<strong>排队和阻塞</strong>的机制，比如具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）。它内部使用了一个<strong>先进先出（FIFO）的双端队列</strong>，并使用了两个指针head和tail用于标识队列的头部和尾部。其数据结构如图：</p><img src="https://3803541485-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJQjOPACL_iNG1yE%2FAQS数据结构.png?generation=1551665548550906&alt=media" alt="img" style="zoom:67%;" /><p>队列中并不直接储存线程，而是储存<strong>拥有线程的Node节点</strong>。</p><h4 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h4><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li><li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore&#x2F;CountDownLatch。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池顶层接口是<code>Executor</code>，<code>ThreadPoolExecutor</code>是这个接口的实现类。构造函数有四种，最少5个参数，最多7个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//核心线程数最大值</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程总数最大值（核心线程+非核心线程）</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//非核心线程闲置超时时长。</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用于统一管理创建线程的配置</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><span class="hljs-comment">//拒绝处理策略</span><br></code></pre></td></tr></table></figure><p>线程池中有两类线程，核心线程和非核心线程。</p><ul><li>核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗）</li><li>非核心线程如果长时间的闲置，就会被销毁（临时工）。</li></ul><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p><p>常用的几个阻塞队列：</p><ol><li><strong>LinkedBlockingQueue</strong>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</li><li><strong>ArrayBlockingQueue</strong>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</li><li><strong>SynchronousQueue</strong>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</li><li><strong>DelayQueue</strong>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</li></ol><p>线程数量大于最大线程数就会采用<strong>拒绝处理策略</strong>，四种拒绝处理的策略为 ：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>线程池本身有一个调度线程，负责创建、销毁、管理任务队列等。</p><p>线程池有自己的状态，<code>ThreadPoolExecutor</code>类中定义了一个<code>volatile int</code>变量<strong>runState</strong>来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TIDYING 、TERMINATED。</p><ul><li>线程池创建后处于<strong>RUNNING</strong>状态。</li><li>调用shutdown()方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker,会等待阻塞队列的任务完成。</li><li>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0。</li><li>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()函数。ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。</li><li>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</li></ul><h4 id="线程如何复用"><a href="#线程如何复用" class="headerlink" title="线程如何复用"></a>线程如何复用</h4><p>ThreadPoolExecutor在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p><p>比起普通队列的插入和删除方法，阻塞队列提供了抛出异常、返回特殊值、阻塞、超时退出4中版本。</p><p>实现类：</p><ul><li>ArrayBlockingQueue：由数组形成的有界阻塞的队列。初始化队列大小后不可改变，构造方法中的fair决定内部锁是否采用公平锁，默认非公平。</li><li>LinkedBlockingQueue：链表结构的有界阻塞队列。默认大小Integer.MAX_VALUE</li><li>DelayQueue：该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</li><li>PriorityBlockingQueue</li><li>SynchronousQueue：没有任何内部内容，对列没有容量，每个put必须等待一个take</li></ul><p>阻塞队列的原理是利用的Lock锁的多条件阻塞控制。</p><p>在构造时，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器（Condition），分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull，标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul><li><p><strong>可重入锁和非可重入锁</strong>：是否允许线程对一个资源重复加锁。synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。不然就会导致<strong>死锁</strong>。</p></li><li><p><strong>公平锁和非公平锁</strong>：获取锁的顺序是否FIFO。一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁</p><p>  ReentrantLock支持非公平锁和公平锁两种。</p></li><li><p><strong>读写锁和排他锁</strong>：Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p><p>  synchronized和ReentrantLock都是排他锁。</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”。</p><p>Lock接口中有一个方法是可以获得一个<code>Condition</code>。每个对象都可以用继承自<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待&#x2F;通知模式。</p><p>Condition和Object的wait&#x2F;notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal&#x2F;signalAll</strong>方法则对应Object的notify&#x2F;notifyAll()。但Condition类似于Object的等待&#x2F;通知机制的加强版。</p><p>ReentrantReadWriteLock实现了读写锁，但是在写操作时是独占的，可能导致“写饥饿”。</p><p><code>StampedLock</code>类是Java8加入的，没有实现Lock接口和ReadWriteLock接口，但是实现了读写锁的功能，而且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p><p>StampedLock可以避免“写饥饿”，核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p><p>乐观读锁的意思就是先假定在这个锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个悲观读锁，这里的悲观读锁和ReentrantReadWriteLock中的读锁类似，也是个共享锁。</p><p>Vector和HashTable是线程安全的容器，但是同步方法是<strong>对方法加锁</strong>，性能不好。</p><ul><li>ConcurrentMap接口</li></ul><p>ConcurrentHashMap类提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫<strong>分段锁</strong>(Lock Striping)。</p><ul><li>ConcurrentLinkedDeque和ConcurrentLinkedQueue。没有并发List。</li><li>ConcurrentSkipListSet</li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。这样在并发场景对读操作不需要加锁，从而达到<strong>读写分离</strong>。</p><p>JDK1.5加入了CopyOnWriteArrayList和CopyOnWriteArraySet </p><p>CopyOnWrite容器有<strong>数据一致性</strong>的问题，它只能保证<strong>最终数据一致性</strong>。读操作可能读到旧数据。</p><p><strong>工作窃取算法</strong>指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的<strong>头部</strong>拿任务执行，而窃取其他任务的线程从双端队列的<strong>尾部</strong>执行任务。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-plus</title>
    <link href="/Java-Spring/mybatis-plus/"/>
    <url>/Java-Spring/mybatis-plus/</url>
    
    <content type="html"><![CDATA[<p>Mybatis-plus自带一个实体父类<code>Model</code></p><p>该类的作用是能通过实体直接进行CRUD操作，不需要调用DAO，前提是必须存在对应的原始Mapper并继承BaseMapper并且可以使用的前提下。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-plus</title>
    <link href="/Spring-family/mybatis-plus/"/>
    <url>/Spring-family/mybatis-plus/</url>
    
    <content type="html"><![CDATA[<p>Mybatis-plus自带一个实体父类<code>Model</code></p><p>该类的作用是能通过实体直接进行CRUD操作，不需要调用DAO，前提是必须存在对应的原始Mapper并继承BaseMapper并且可以使用的前提下。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实现</title>
    <link href="/Java-Spring/redis-data/"/>
    <url>/Java-Spring/redis-data/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在redis中，所有的键一定是字符串。redis虽然是用C语言编写的，但是没有直接使用C语言风格字符串（C-style String），而是实现了一种名为<strong>简单动态字符串</strong>（simple dynamic string, SDS）作为字符串的默认实现。C-style String只会用于<strong>字符串字面量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>  <span class="hljs-comment">// 记录字符串长度</span><br>  <span class="hljs-type">int</span> len;<br>  <span class="hljs-comment">// 记录buf中未使用的字节数</span><br>  <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>  <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><p>SDS遵循C-style String的风格，在末尾自动添加<code>\0</code>，也会自动申请额外1字节的空间，这些操作都是SDS自动维护，对用户是透明的，这也使得SDS可以直接使用C语言中的字符串操作函数。</p><p>为什么SDS比C-style String更适合redis：</p><ol><li>常数复杂度获取字符串长度</li><li>杜绝内存溢出，预检查buf空间</li><li>减少修改字符串时带来的内存重新分配次数。小于1MB时预分配和len一样的free空间；超过1MB时每次多分配1MB额外空间。</li><li>C-style String必须符合某种编码，并且只能在末尾出现空字符，使得其只能保存文本数据，不能存储二进制文件。</li><li>可以重用部分<code>string.h</code>中的函数</li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">void</span> *value;<br>&#125;listNode<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>  listNode *head;<br>  listNode *tail;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>  <span class="hljs-comment">// 节点值复制函数</span><br>  <span class="hljs-type">void</span> *(*dup) (<span class="hljs-type">void</span> *ptr);<br>  <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-type">void</span> *ptr);<br>  <span class="hljs-type">int</span> (*match) (<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>&#125;<span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>redis的字典基于哈希表实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>  <span class="hljs-comment">// 哈希表数组的指针</span><br>dictEntry **table;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sie;<br>  <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值，总是等于size-1</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht:<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>  <span class="hljs-type">void</span> *key;<br> <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>    <span class="hljs-type">void</span> *val;<br>    <span class="hljs-type">uint64_t</span> u64;<br>    <span class="hljs-type">int64_t</span> s64;<br>  &#125; v;<br>  <span class="hljs-comment">// 指向下一个哈希表节点，形成链表</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>  dictType *type;<br>  <span class="hljs-type">void</span> *privdadta;<br>  dictht ht[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> rehashidx;<br>&#125; dict;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span>;<br>  <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br>  <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);<br>  <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);<br>  <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);<br>  <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *obj);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><p><code>ht[0]</code>和<code>ht[1]</code>都是哈希表，一般情况下，字典只使用 <code>ht[0]</code>，只有在需要进行rehash的时候才会使用<code>ht[1]</code>。当不进行rehash的时候，<code>rehashidx</code>始终为-1。当负载因子不在合理范围时，需要rehash来调整表大小：</p><ol><li>给<code>ht[1]</code>分配空间，如果是扩展则为<code>ht[0].used*2</code>的下一个2^n^,  如果是收缩则为<code>ht[0].used</code>的下一个2^n^</li><li>将所有的<code>ht[0]</code>rehash到<code>ht[1]</code>上</li><li>全部迁移之后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，为<code>ht[1]</code>创建一个新的空表。</li></ol><p>如果服务器没有正在执行BGSAVE或者BGREWRITEAOF命令，name负载因子大于等于1时触发。如果正在执行，name大于等于5时触发。考量是在执行以上2种命令时，redis会创建子进程，根据<strong>写时复制</strong>的优化机制，需要尽可能减少对服务器内存IO的压力，因此调大负载因子的阈值。</p><p>注意，rehash是渐进式的，不是一口气完成的。因为如果哈希表很大，服务器需要马上处理完的话可能负担过重，因此是每次对字典执行操作时顺带做一点，每搬运一个Entry就将rehashidx增加1，全部完成后置为-1。在rehash期间，redis会现在<code>ht[0]</code>上查找数据，找不到则在<code>ht[1]</code>上再找。另外，插入操作会在<code>ht[1]</code>上进行，包装<code>ht[0]</code>上的数据只减不增。                                                                         </p><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。每个dictType结构保存了一组用于操作特定类型键值对的函数。</p><p>redis的哈希算法使用MurmurHash2。</p><p>由于dictEntry组成的链表没有尾部节点的指针，所以遇到冲突时，新节点会插入表头位置。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>有序数据结构，每个阶段维持多个其他节点的指针，支持平均O(logN)，最坏O(N)的节点查找。</p><p>在redis中跳跃表用的不多，只用于实现有序集合键和在集群节点中作为内部数据结构。</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>当一个集合只包含整数，且数量不多时，就会使用整数集合作为底层实现。<code>contents</code>中的数字从小到大有序，没有重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">intset</span> &#123;</span><br>  <span class="hljs-comment">// 编码方式</span><br><span class="hljs-type">uint32_t</span> encoding;<br>  <span class="hljs-comment">// 元素数量</span><br><span class="hljs-type">uint32_t</span> length;<br>  <span class="hljs-comment">// 保存元素的数组</span><br><span class="hljs-type">int8_t</span> contents[];<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然<code>contents</code>被声明为<code>int8_t</code>，但是真正的类型取决于<code>encoding</code>如何规定每个整数的位数。</p><p>当新元素的类型比整数集合内所有元素都长时，整数集合需要<strong>升级</strong>：根据新元素的类型，扩展<code>contents</code>的大小，重新分配空间；将原有的元素转换成新类型后，<strong>从后往前</strong>重新添加到<code>contents</code>。</p><p>注意：引发升级的新元素的长度总是比整数集合内所有现有元素长，所以这个新元素要么比现有元素都小，要么都大。因此插入位置只会在<code>contents</code>的开头或者末尾。</p><ol><li>升级机制提升了整数集合的灵活性，为C语言这种静态语言提供了用一个结构保存不同类型整数对的方法。</li><li>节约了内存。</li></ol><p>注意：<strong>不支持降级</strong>操作。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>列表键和哈希键的底层实现之一。当列表键只包含少量列表项，并且列表项是小整数或短字符串时，就会采用压缩列表。</p><p>压缩列表在内存中由几个连续的组成部分：</p><ol><li>zlbytes：记录压缩列表占用字节数，在重新分配内存和计算zlend时使用</li><li>zltail，记录尾节点距离起始位置的偏移量，可以直接确定尾节点的位置</li><li>zllen：记录节点数量。当这个值等于UINT16_MAX时，说明达到上限，真实数量需要遍历后获得</li><li>entryX：列表节点，长度不定</li><li>zlend：特殊值0xFF，标记压缩列表的末端</li></ol><p>列表节点：</p><ol><li>previous_entry_length：1字节或5字节，取决于前一个节点的字节数是否超过254。有这个就可以得知前一个节点的起始位置，从而实现列表的倒序遍历。</li><li>encoding：记录了content保存数据类型和长度。要么是1、2、5字节长度，以00、01、10开头的字节数组编码（用来表示不同的长度），要么是1字节长度，以11开头的整数编码。</li><li>content</li></ol><p>连锁更新：压缩列表内恰好有多个连续的，长度介意250到253字节的节点，在前面新增节点会导致它们的previous_entry_length不够用1字节，需要扩容，从而导致后续节点连锁反应。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>redis没有用以上数据结构直接实现键值对数据库，而是基于这些数据结构创建了对象系统，包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象。还基于<strong>引用计数</strong>实现<strong>内存回收</strong>机制和<strong>对象共享</strong>。redis对象还带有访问时间记录，在服务器启用maxmemory时，空转较久的键可能被优先删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// 类型，5个常量</span><br><span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>  <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>  <span class="hljs-comment">// 指向底层实现数据结构的指针</span><br>  <span class="hljs-type">void</span> *ptr;<br>  <span class="hljs-comment">// ...</span><br>&#125; orbj;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/jzkNDO"><img src="https://s1.ax1x.com/2022/07/26/jzkNDO.png" alt="jzkNDO.png" style="zoom:50%;" /></a></p><p>encoding有以上这些类型。每种对象至少基于2中底层实现，见下表：</p><p><a href="https://imgtu.com/i/jzASR1"><img src="https://s1.ax1x.com/2022/07/26/jzASR1.png" alt="jzASR1.png" style="zoom:50%;" /></a></p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是：</p><ol><li><code>int</code>：如果字符串是整数值并且可以用<code>long</code>类型表示，<code>ptr</code>属性会保存整数值，<code>void*</code>会转成<code>long</code>。</li><li><code>raw</code>：如果是字符串值，且长度大于32字节</li><li><code>embstr</code>：如果是字符串值，且长度≤32字节。这是专门用于保存短字符串的一种优化编码方式。虽然和<code>raw</code>编码一样，需要用<code>redisObject</code>和<code>sdshdr</code>两个结构来表达字符串，但是<code>raw</code>会调用两次内存分配函数，<code>embstr</code>只会调用一次，分配一块连续内存给这2个结构。这样释放内存时也只用调用一次，而且2个结构再内存中紧挨着可以利用缓存优势。</li></ol><p>对于<code>int</code>编码的字符串，如果对这个“整数”进行了属于字符串的操作，则会改变编码为<code>raw</code>。</p><p>redis只实现了对<code>int</code>和<code>raw</code>的修改，因此<code>embstr</code>实际上是只读的，对其的修改都会令编码改变为<code>raw</code>。</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>当同时满足以下条件时，列表对象使用<code>ziplist</code>编码：</p><ol><li>保存的所有字符串元素的长度都小于64字节</li><li>元素数量少于512个</li></ol><p>否则使用<code>linkedlist</code>编码。</p><p>注意：这两个上限值都可以在配置文件中修改。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>底层是<code>ziplist</code>或者<code>hashtable</code>。</p><p>使用压缩列表时，每次插入键值对都是紧挨着插入队尾。</p><p>当同时满足以下条件时，哈希对象使用<code>ziplist</code>编码：</p><ol><li>保存的所有键和值的字符串元素的长度都小于64字节</li><li>元素数量少于512个</li></ol><p>否则使用<code>hashtable</code>编码。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>底层是<code>intset</code>或者<code>hashtable</code>。</p><p>使用<code>intset</code>时，要求所有元素为整数，且不超过512个。</p><p>当使用哈希表时，只使用键，值全部为NULL。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>底层是<code>ziplist</code>或者<code>skiplist</code>。</p><p>使用<code>ziplist</code>时，每个元素使用2个紧挨的压缩列表节点来保存，第一个保存元素的成员，的第二个保存元素的分值。</p><p>使用<code>skiplist</code>时，一个<code>zset</code>结构同时包含一个字典和一个跳跃表。跳跃表节点的object属性保存元素的成员，score属性保存分数。通过跳跃表，可以对有序集合进行<strong>范围性操作</strong>。字典创建了成员到分值的映射，可以实现O(1)的分值查询。</p><p>字典和跳跃表在底层是共用元素的成员和分值的，不会产生浪费。</p><p>当元素数量小于128个，所有元素成员的长度小于64字节时，使用<code>ziplist</code>编码。</p><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><p>Redis中有些命令可以对任意类型执行，但是有些只能用于特定类型，说明其中有类型检查的操作。类型检查通过<code>redisObject</code>的<code>type</code>属性实现的。</p><p>同种对象有不同的底层实现，命令需要根据底层实现的不同，或者是作用的键类型不同，选择正确的API来执行，这就是<strong>多态命令</strong>。</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">int</span> refcount;<br>&#125; orbj;<br></code></pre></td></tr></table></figure><p>C语言本身没有内存回收功能，因此Redis自己实现了基于引用计数的内存回收机制，由<code>redisObject</code>的<code>refcount</code>属性来记录。</p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>引用计数机制允许实现对象共享，有利于节约内存。Redis在初始化服务器时会创建0到9999共一万个字符串对象，因为它们大概率会被用来共享。</p><p>用<code>object refcount</code>命令可以查看引用计数。</p><p>注意：只支持整数值的共享，字符串对象和包含多个值的对象验证相同的复杂度太高。</p><h4 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">unsigned</span> lru:<span class="hljs-number">22</span>;<br>&#125; orbj;<br></code></pre></td></tr></table></figure><p>该属性记录了对象最后一次被命令程序访问的时间。<code>object idletime</code>可以查看给定键的空转时长。这个命令实现是特殊的，在访问键的值对象时，不会修改值对象的lru属性。</p><p>如果服务器开了maxmemory选项，并且服务器的回收内存算法为<code>volatile-lru</code>或者<code>allkeys-lru</code>，那内存超过上限时优先释放空转时长较高的键。</p><h2 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 保存服务器中所有数据库的数组</span><br>redisDb *db;<br><span class="hljs-comment">// 服务器中数据库数量</span><br><span class="hljs-type">int</span> dbnum;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Redis中所有服务器都要保存在服务器状态<code>redis.h/redisServer</code>结构对的db数组中，类型为<code>redis.h/redisDb</code>。<code>dbnum</code>默认为16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 记录客户端当前正在使用的数据库</span><br>redisDb *db;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis是键值对数据库，每个数据库的所有键值对都保存在<strong>键空间</strong>里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 数据库键空间，保存数据库中所有的键值对</span><br>dict *dict;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对数据库的读写还会附带一些维护操作：</p><ol><li>更新服务器键空间的命中或不命中次数</li><li>更新LRU</li><li>如果发现键以过期，要删除键后再进行剩余操作</li><li>如果有使用WITCH命令监视该键，则修改后要将键标记为dirty，从而让事务注意到这个键已被修改</li><li>服务器每修改一个劲键，都会对脏键计数器加1，这个计数器会触发服务器的持久化和复制操作</li><li>如果服务器开启了数据库通知功能，那么在对键修改后要按照配置发送相应的数据库通知。</li></ol><p><code>expire</code>命令可以设置某个键的生存时间，在多少秒后删除。</p><p><code>expireat</code>命令可以设置某个键的过期时间，在某个时间戳来临时删除。</p><p><code>ttl</code>命令查看一个键的生存时间或者过期时间。</p><p>以上单位都是秒。<code>pexpire</code>、<code>pexpireat</code>、<code>pttl</code>以毫秒为单位。</p><p>以上的设置命令，最后都会经过转换，然后执行<code>pexpireat</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 过期字典，保存键的过期时间</span><br>dict *expires;<br>&#125;;<br></code></pre></td></tr></table></figure><p>过期时间保存在<code>redisDb</code>中的过期字典中。虽然过期字典和键空间内都保存了键，但是指向的键对象是共享的，所以没有浪费内存。</p><p><code>persist</code>命令可以移除一个键的过期时间。</p><p>检查一个键是否过期，有一个函数，大致操作是获取过期时间，和当前UNIX时间戳比较。另一种方法是用<code>ttl</code>或<code>pttl</code>命令查看过期时间是否大于0，但是实际上Redis还是使用与函数操作类似的操作，因为直接访问过期字典比执行一个命令要快。</p><h4 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>在设置过期时间的同时创建定时器，到点删除。该策略保证过期的键会被尽快删除。这是对内存最友好，对CPU最不友好的策略。对于内存不紧张但是CPU紧张的服务器来说不合适。</p><p>而且，定时器需要用到时间事件，当前的实现是无序链表，查询一个事件的复杂度是O(N)，不能高效处理大量事件。</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>对过期键放任不管，只有每次从键空间中取键时，都检查是否过期。对CPU最友好，对内存不友好。过期的键可能长期霸占内存，如果永远不被访问的话，几乎可以视作<strong>内存泄漏</strong>。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>折中方案。难点在于确定删除操作的时长和频率。</p><h4 id="Redis的过期删除策略"><a href="#Redis的过期删除策略" class="headerlink" title="Redis的过期删除策略"></a>Redis的过期删除策略</h4><p>Redis实际采用的是惰性删除和定期删除两种策略配合，说明Redis更看重的是CPU性能。</p><p>惰性删除策略由<code>db.c/expireIfNeeded</code>函数实现，所以读写数据库的命令都会在执行前调用该函数检查键是否过期。因此，由于每个被访问的键都可以在执行具体操作前因过期被函数，所以每个命令的实现函数<strong>必须能处理键不存在的情况</strong>。</p><p>定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现。每当Redis的<strong>周期性操作</strong><code>redis.c/serverCron</code>函数执行时，<code>activeExpireCycle</code>都会被调用，它在<strong>规定时间内分多次</strong>遍历服务器中各数据库，从数据库的<code>expires</code>字典中<strong>随机检查</strong>一部分键对的过期时间。</p><h5 id="对RDB的影响"><a href="#对RDB的影响" class="headerlink" title="对RDB的影响"></a>对RDB的影响</h5><p>执行<code>save</code>和<code>bgsave</code>的命令创建一个新的RDB文件。在创建时，只会保存未过期的键。</p><p>在启动Redis服务器时，如果开启了RDB功能，那么会载入RDB文件：</p><ol><li>如果以主服务器运行，会检查键的过期时间，只载入未过期的键。</li><li>如果以从服务器启动，<strong>无论是否过期的键都会被载入</strong>。在主从服务器进行数据同步的时候，从服务器的数据库会被清空，所以一般来讲不检验也没事。</li></ol><h5 id="对AOF的影响"><a href="#对AOF的影响" class="headerlink" title="对AOF的影响"></a>对AOF的影响</h5><p>当服务器使用AOF持久化时，如果某个键已经过期但还未被删除，不会影响到AOF文件。当它被删除后，AOF会追加一条DEL命令，<strong>显式记录</strong>该键已经删除。</p><p>在执行AOF重写时，已经过期的键不会保存到重写后的AOF文件里。</p><h5 id="对复制的影响"><a href="#对复制的影响" class="headerlink" title="对复制的影响"></a>对复制的影响</h5><p>当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制，以此保证<strong>主从一致</strong>。</p><p>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令。</p><p>从服务器在执行客户端的读命令时，即使碰到过期键也不会删除，而是当做未过期的处理。只有收到主服务器的DEL命令后才会删除过期键。</p><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>2.8版本新增功能，可以让客户端通过订阅给定的频道或模式，来获知键的变化和命令执行情况。</p><p>比如<code>subscribe __keyspace@0__:message</code>命令可以订阅0号数据库的message键的执行了什么命令。这类关注<strong>某个键执行了什么命令</strong>的通知称为<strong>键空间通知</strong>。</p><p>比如<code>subscribe __keyspace@0__:del</code>命令可以订阅0号数据库的del命令作用于哪些键。这类关注<strong>某个命令被什么键执行了</strong>的通知称为<strong>键时间通知</strong>。</p><p>服务器配置的<code>notify-keyspace-events</code>选项决定了服务器所发送的通知类型。</p><p>发送通知</p><p>发送通知由<code>notify.c/notifyKeyspaceEvent</code>函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">notifyKeyspaceEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">char</span> *event, robj *key, <span class="hljs-type">int</span> dbid)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>type：想要发送的通知类型，程序根据这个值判断通知是否为服务器配置<code>notify-keyspace-events</code>选项想要的通知类型，由此决定是否发送通知。</p></li><li><p>event：时间名称</p></li><li><p>keys：产生事件的键</p></li><li><p>dbid：产生事件的数据库号</p></li></ul><p>在函数内部，会通过按位与的方式检查通知类型，是否允许发送键空间通知，是否允许发送键事件通知。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB既可以手动执行，也可以定时执行。RDB文件是经过压缩的二进制文件。</p><p><code>SAVE</code>命令会阻塞服务器进程，直到RDB文件创建完毕为止。</p><p><code>BGSAVE</code>命令会派生子进程来创建RDB文件，不会阻塞服务器，但是在BGSAVE执行期间，客户端的<code>SAVE</code>和<code>BGSAVE</code>命令会被拒绝。<code>BGSAVE</code>和<code>BGREWRITEAOF</code>也不能同时执行：</p><ul><li>如果<code>BGSAVE</code>正在执行，那么<code>BGREWRITEAOF</code>会被延迟到<code>BGSAVE</code>执行完成后执行。</li><li>如果<code>BGREWRITEAOF</code>正在执行，那么<code>BGSAVE</code>会被拒绝。</li></ul><blockquote><p>复习：fork()在父进程中的返回值是子进程的pid，在子进程的返回值是0</p></blockquote><p>实际创建工作由<code>rdb.c/rdbSave</code>函数完成，SAVE命令和BGSAVE最终都会调用这个函数。</p><p>RDB文件的载入是在服务器启动是自动执行的，因此没有专门的载入命令。只要检测到RDB文件存在，就会自动载入。实际工作由<code>rdb.c/rdbLoad</code>函数完成。载入期间服务器阻塞。</p><p>由于AOF文件的更新频率通常比RDB高，所以如果开启了AOF功能，那么<strong>优先使用</strong>AOF来还原数据。</p><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p><code>BGSAVE</code>允许Redis实现后台自动保存，通过<code>SAVE</code>设置多个规则，只要其中任意一个条件满足，就会触发<code>BGSAVE</code>。比如<code>save 300 10</code>，意思是如果在300秒内对数据库进行至少10次修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 记录了保存条件的数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> *<span class="hljs-title">saveparams</span>;</span><br>  <span class="hljs-comment">// 修改计数器</span><br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> dirty;<br>  <span class="hljs-comment">// 上次保存时间</span><br>  <span class="hljs-type">time_t</span> lastsave;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> &#123;</span><br>  <span class="hljs-comment">// 秒数</span><br>  <span class="hljs-type">time_t</span> seconds;<br>  <span class="hljs-comment">// 修改数</span><br>  <span class="hljs-type">int</span> changes;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>SAVE</code>设置的保存条件会被保存到<code>redisServer</code>结构的<code>saveparams</code>属性。除了这个数组，服务器还维持dirty计数器和上次修改时间。dirty计数器记录了距离上次成功执行<code>SAVE</code>或者<code>BGSAVE</code>后，服务器对数据库状态（所有数据库）进行多少次修改。<code>lastsave</code>记录上次成功执行<code>SAVE</code>或者<code>BGSAVE</code>的UNIX时间戳。</p><p>Reidis的服务器周期性操作<code>serverCron</code>函数默认每个<strong>100毫秒</strong>执行一次，该函数的工作之一就是检查保存条件是否满足。如果时间超过并且修改次数超过，就触发保存。</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>一个完整的RDB包含以下部分</p><ul><li>REDIS：5字节，保存“REDIS“5个字符，程序可以在载入时以此检测是否为RDB文件。</li><li>db_version：4字节，一个用字符串表示的整数，记录RDB的版本号，比如”0006“。该书只介绍第6版的文件结构。</li><li>database：包含0个或多个数据库</li><li>EOF常量：1字节，标志RDB正文结束。</li><li>check_num：8字节的无符号整数，校验和，通过前四部分计算得出。</li></ul><p>每个非空的database可以保存为：</p><ul><li>SELECTDB：1字节常量，程序读到这个值，表示接下来读入的是一个数据库号码</li><li>db_number：数据库号码，根据号码大小不同可以是1&#x2F;2&#x2F;5字节。当读到号码后，服务器会调用<code>SELECT</code>命令切换到对应数据库，使得之后读入的键值对可以载入到对应数据库。</li><li>kay_value_pairs：保存了数据库中所有的键值对。如果键有过期时间，该信息也会保存。如果没有过期信息则没有前两项<ul><li>EXPIRETIME_MS：1字节常量，告知程序接下来要读入的是以毫秒为单位的过期时间。</li><li>ms：8字节的带符号整数，以毫秒为单位的UNIX时间戳，表示过期时间。</li><li>TYPE：1字节，记录value的类型。每一个TYPE常量都对应一种对象类型或者底层编码。决定如何读入和解释value数据。</li><li>key：总是一个字符串的对象，编码方式和<code>REDIS_RDB_TYPE_STRING</code>类型的value一样。</li><li>value：这里书中有大量的详尽分析，这里不赘述。</li></ul></li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与RDB记录数据库状态不同，AOF记录的是写命令。AOF保存的命令都是以Redis的命令请求协议格式保存，而Redis的命令请求协议是纯文本格式，所哟AOF是人类可读的。</p><p>AOF持久化的实现分为命令追加、文件写入、文件同步三个步骤。</p><p>当AOF功能开启时，服务器每执行完一个写命令，会以协议格式将命令追加到服务器状态的<code>aof_buf</code>缓冲区末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br>sds aof_buf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis的服务器进程就是一个<strong>事件循环</strong>，文件事件负责接收命令和发送命令，时间事件负责执行像<code>serverCron</code>这样的定时运行函数。服务器每结束一个事件循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否需要将<code>aof_buf</code>对的内容写入AOF中。</p><p><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>决定：</p><ul><li>always：将缓冲区内容写入并同步</li><li>everysec：将缓冲区内容写入，如果距离上次同步超过1秒，那么再次同步，并且同步线程由另一个线程执行。这是<strong>默认选项</strong>。</li><li>no：将缓冲区内容写入，但是不同步，有操作系统决定。</li></ul><blockquote><p>为了提高文件写入效率，现代操作系统中，用户调用write时，操作系统通常将数据暂存到一个内存缓冲区中，等缓冲区被填满、或超过指定时限后，才真正将缓冲区写入到磁盘。这在提高效率的同时也带来安全问题，因此系统还提供了fsync和fdatasync两个同步函数，可以强制让操作系统将缓冲区写入硬盘，确保数据安全。</p></blockquote><p>因此，always是安全性最高，但是效率最差的配置，即使出现停机故障，也最多地都市一个事件循环中产生的命令数据。everysec足够快，并且最多丢失1秒的数据，因此作为默认项。no的写入速度最快，但是由于会在系统缓存中累计一段时间的写入数据，所以单词同步时长是最长的，故障时丢失上次同步后的所有数据。</p><h4 id="载入和还原"><a href="#载入和还原" class="headerlink" title="载入和还原"></a>载入和还原</h4><ol><li>创建一个不带网络连接对的伪客户端，因为Redis的命令只能在客户端的上下文中执行。</li><li>从AOF文件中分析并读取一条写命令</li><li>使用伪客户端执行写命令</li><li>重复2、3步骤，直到所有写命令被处理完</li></ol><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着时间流逝，AOF文件中内容会增多，文件体积变大。比如分别使用多次RPUSH命令向列表添加1个元素，其实效果和一次添加多个元素效果是一样的，这里就有改进空间。为了解决AOF体积膨胀问题，Redis提供了<strong>AOF文件重写</strong>功能，可以生成一个效果一样的新AOF文件，同时体积更小。</p><p>AOF重写不需要对现有的AOF进行任何读取、分析或写入操作，而是通过<strong>读取数据库状态</strong>实现的。比如用了多条命令对一个列表进行增删改，其实等价于一条插入命令来描述其最终状态。</p><p>为了避免执行命令时造成客户端输入缓冲区溢出，在重写列表、哈希表、集合、有序集合这四种可能带有多个元素的键时，会先检查键锁包含的元素数量，如果超过了<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>常量，则会使用多条命令来记录键。此书版本中为64。</p><p>但是，AOF重写需要的大量的写入，如果要阻塞服务器的话就无法处理请求，因此Redis将AOF重写放到子进程执行。这样父进程可以继续处理请求，而且子进程带有服务器进程的数据副本（子进程会复制父进程的内存空间），使用子进程而不是线程，可以在不使用锁的情况下保证数据安全。</p><p>为了解决在子进程进行AOF重写的过程中，父进程处理请求使数据库状态更新，导致的数据不一致问题，服务器设置了一个<strong>AOF重写缓冲区</strong>。该缓冲区在创建子进程后开始使用，Redis每执行完一个写命令，就会同时发送给AOF缓冲区和AOF重写缓冲区。</p><p>当子进程完成重写后，会向父进程发送一个信号，父进程接到后会调用信号处理函数，进行如下操作：</p><ol><li>将AOF重写缓冲区的内从写入新AOF文件中，此时新AOF文件所描述的数据库状态与服务器的达成一致。</li><li>对新AOF文件进行改名，<strong>原子</strong>地覆盖旧AOF文件。</li></ol><p>整个AOF后台重写过程中，只有<strong>信号处理函数</strong>执行时会阻塞服务器进程，大大降低了AOF重写对性能的影响。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis中的事件分2种类型：文件事件和时间事件。</p><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>基于Reactor模式开发的网络事件处理器。</p><p>文件事件处理器使用<strong>I&#x2F;O多路复用</strong>来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同对的事件处理器。当被监听的套接字准备好执行连接（accept）、读取（read）、写入（write）、关闭（close）等操作时，对应的文件事件就会产生，此时文件事件处理器会调用关联好的事件处理器来处理这些事件。</p><p>虽然文件事件处理器以<strong>单线程</strong>运行，但是通过使用I&#x2F;O多路复用同时监听多个套接字，既实现了高性能对的网络通信模型，又很好地与Redis服务器中其他同样以单线程运行的模块进行对接，保持Redis内部单线程设计的简单性。</p><img src="https://s2.loli.net/2022/08/01/OlL1nE9qBHiP8sv.png" style="zoom:40%;" /><p>文件事件处理器由这四部分组成。文件事件是对套接字操作的抽象。文件事件可能会并发的出现，但是事件会被放在队列里，以有序的、同步的、每次一个套接字传送到分派器。处理器就是一个个函数，分派器会调用根据事件类型调用它们。</p><p>Redis中的I&#x2F;O多路复用的功能来自于包装常见的select、epoll、evport、kqueue这些I&#x2F;O多路复用函数库实现的，每个在源码中对应一个文件，都实现了相同的API，所以多路复用的底层实现是可以<strong>互换</strong>的。在源码中有<code>#include</code>宏定义了相关规则，程序在编译是自动选择系统中性能最高的函数库作为底层实现。</p><p>从代码来看，evport &gt; epoll &gt; kqueue &gt; select。select是Linux系统中一定会有的，性能也最差，作为最后选择。</p><p>事件分<code>AE_READABLE</code>和<code>AE_WRITABLE</code>两种。</p><ol><li>连接应答处理器：<code>networking.c/acceptTcpHandler</code>函数对连接服务器监听套接字的客户端进行应答，具体实现为<code>sys/socket.h/connect</code>的包装。绑定了服务端socket的读事件。</li><li>命令请求处理器：<code>networking.c/readQueryFromClient</code>函数包装了<code>unistd.h/read</code>，客户端连接成功后，服务器就会将客户端套接字的读事件与该处理器关联。</li><li>命令回复处理器：<code>networking.c/sendReplyToClient</code>包装了<code>unistd.h/write</code>，关联了写事件。</li></ol><h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>一个时间事件主要有三个属性：</p><ul><li>id：全局唯一，自增，新事件的id比老事件大</li><li>when：毫秒精度的UNIX时间戳，记录事件的到达事件</li><li>timeProc：时间事件处理器，一个函数。</li></ul><p>时间事件分为定时事件和周期事件。具体取决于时间事件处理器的返回值：如果返回<code>ae.h/AE_NOMORE</code>则为定时事件，如果是其他整数值，则为周期事件，返回值是对<code>when</code>属性的更新。</p><p>服务器中所有时间事件都在一个<strong>无序链表</strong>中，新的事件总是插在表头。</p><p>在本书版本中，正常模式下Redis只使用<code>serverCron</code>一个时间事件，链表几乎退化为指针。在事件不多的情况下对性能没有影响。</p><p>在调度上，会循环调用事件处理函数，但是在函数内部会先计算最近到期的事件，然后根据该时长设置最大阻塞时间，这样既可以避免服务器频繁轮训，也可以确保<code>aeApiPoll</code>不会阻塞过长时间。服务器总是先等待和处理文件事件，再检查时间事件。由于时间事件总是在文件事件之后，因此时间事件看起来会“迟到”。</p><p><img src="https://s2.loli.net/2022/08/05/LFdKc2TmiGNUseg.png" alt="截屏2022-08-05 17.03.47"></p><p>对文件事件和时间事件的处理都是同步、有序、原子的。事件不会主动抢占，而是会为了减少总体阻塞时间适当让出执行权。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在服务器端，每个客户状态表达为<code>redis.h/redisClient</code>的结构。在服务器状态结构里，这些客户端状态被保存在一个链表中。</p><p>客户端结构中包含以下属性：</p><ul><li>fd：套接字描述符。伪客户端的fd为-1。</li><li>name：名字，默认情况下没有。</li><li>flags：角色，以及客户端所处的状态。</li><li>querybuf：输入缓冲区用于保存客户端发送的命令</li><li>argc, **argv：命令参数和参数数量。argv[0]是命令，之后的是参数。命令保存到缓冲区后，服务器会解析命令，命令参数和个数保存到这里。</li><li>struct redisCommand *cmd：服务器根据argv[0]一个字典中找到这个命令对应的实现函数，交给cmd指针。这个结构保存了命令的实现函数、标志、传参个数、总执行次数等信息。</li><li>输出缓冲区：<ul><li>bufpos和buf[]：固定大小缓冲区。用于保存长度较小的回复。bufpos记录已经使用缓冲字节数。buf数组默认16KB。</li><li>list *reply：固定缓冲区用尽或者太小时会启用可变大小缓冲区。是一个链表，可以保存各种类型的对象。</li></ul></li><li>authenticated：用0或1表达是否通过认证</li><li>ctime：客户端创建时间，可以用来计算客户端已经与服务器连接了多少秒。</li><li>lastinteraction：客户端最后一次与服务器进行互动的时间。可以计算客户端空转时间。，记录在<code>CLIENT list</code>命令的idle域。</li><li>obuf_soft_limit_reached_time：输出缓冲区第一次到达软限制的时间。</li></ul><p>有一种客户端关闭的情况是输出缓冲区过大。如果超过硬性限制会直接关闭；如果超过软限制，会先记录时间，如果缓冲区大小一直超过软限制，并且持续一段时间（时长可以配置），那么会关闭。一段时间内不再超过，则不关闭，并且计时器清零。</p><ul><li>lua_client：服务器在初始化时创建负责执行Lua脚本的伪客户端。</li><li>载入AOF文件时创建的伪客户端。</li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>命令请求的执行过程：</p><ol><li>用户端将用户输入的命令转换成协议格式，发送给服务器</li><li>套接字因为客户端的写动作而变得可读，服务器读取命令后保存到输入缓冲区，解析提取命令和参数保存到argv和argc，然后调用命令执行器<ol><li>现根据<code>argv[0]</code>保存的命令，在<strong>命令表</strong>中查找，保存到客户端的cmd属性。每个命令是一个<code>redisCommand</code>结构，其中比较重要的属性有：proc，函数指针，指向该命令对应的执行函数；arity，命令参数的个数，如果是负数则表示参数数量大于等于该值的正数；flags，通过一系列bit表达命令的属性，比如是读还是写，是否需要内存检查等。</li><li>执行预备操作，进行各种检查：检查cmd是否为空指针，检查参数个数，检查身份验证，如果打开了maxmenory则要检查内存占用情况。。。书中还列举的很多。</li><li>执行命令</li><li>后续工作</li></ol></li><li>发送回客户端</li></ol><h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h4><ol><li>Redis中需要经常获取系统当前时间，因此<code>unixtime</code>和<code>mstime</code>这redisServer的属性会被缓存，每100毫秒更新，因此精度不高，只会用于对精度要求不高的任务。</li><li><code>lruclock</code>默认每10秒更新一次，当服务器要计算一个数据库键的空转时间时，就会用<code>lruclock</code>减去对象的<code>lru</code>属性。</li><li><code>trackOperationsPerSecond</code>函数会每100毫秒执行一次，以抽样计算的方式估算并记录服务器在最近一秒处理多大的请求数量。</li><li><code>stat_peak_memory</code>属性记录服务器的内存峰值大小。每次serverCron执行时都会更新。</li><li>处理SIGTERM信号。Redis收到信号不会立刻结束，而是要先拦截下来，做好关闭前的准备动作（比如持久化）然后再关闭。</li><li>管理客户端：调用<code>clientsCron</code>函数，做两个检查：连接超时和输入缓冲区。</li><li>管理数据库：<code>databasesCron</code>函数，对一部分数据库检查，删除过期键，必要时收缩字典。</li><li>执行被延迟的<code>BGREWRITEAOF</code>命令。在执行<code>BGSAVE</code>是收到的<code>BGREWRITEAOF</code>会被延迟执行。</li><li>检查持久化操作的运行状态。服务器状态用<code>rdb_child_pid</code>和<code>aof_child_pid</code>属性记录执行BGSAVE和BGREWRITEAOF的子进程pid，用这两个属性可以检查命令是否正在执行。</li><li>将AOF缓冲区的内容写入AOF文件</li><li>关闭异步客户端：关闭输出缓冲区大小超出限制对的客户端</li><li>增加<code>cronloops</code>计数器，这个属性记录了该函数执行次数。目前唯一的作用是在复制模块中实现没执行<code>serverCron</code>函数N次就执行一次指定代码的功能。</li></ol><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><ol><li>创建一个<code>redisServer</code>类型的实例server作为服务器的状态。设置一些默认值，以整数、浮点数、字符串属性为主。</li><li>载入配置选项</li><li>初始化服务器数据结构</li><li>还原数据库状态</li><li>执行事件循环</li></ol><h2 id="多机服务器实现"><a href="#多机服务器实现" class="headerlink" title="多机服务器实现"></a>多机服务器实现</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实现</title>
    <link href="/Spring-family/redis-data/"/>
    <url>/Spring-family/redis-data/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在redis中，所有的键一定是字符串。redis虽然是用C语言编写的，但是没有直接使用C语言风格字符串（C-style String），而是实现了一种名为<strong>简单动态字符串</strong>（simple dynamic string, SDS）作为字符串的默认实现。C-style String只会用于<strong>字符串字面量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>  <span class="hljs-comment">// 记录字符串长度</span><br>  <span class="hljs-type">int</span> len;<br>  <span class="hljs-comment">// 记录buf中未使用的字节数</span><br>  <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>  <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><p>SDS遵循C-style String的风格，在末尾自动添加<code>\0</code>，也会自动申请额外1字节的空间，这些操作都是SDS自动维护，对用户是透明的，这也使得SDS可以直接使用C语言中的字符串操作函数。</p><p>为什么SDS比C-style String更适合redis：</p><ol><li>常数复杂度获取字符串长度</li><li>杜绝内存溢出，预检查buf空间</li><li>减少修改字符串时带来的内存重新分配次数。小于1MB时预分配和len一样的free空间；超过1MB时每次多分配1MB额外空间。</li><li>C-style String必须符合某种编码，并且只能在末尾出现空字符，使得其只能保存文本数据，不能存储二进制文件。</li><li>可以重用部分<code>string.h</code>中的函数</li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">void</span> *value;<br>&#125;listNode<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>  listNode *head;<br>  listNode *tail;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>  <span class="hljs-comment">// 节点值复制函数</span><br>  <span class="hljs-type">void</span> *(*dup) (<span class="hljs-type">void</span> *ptr);<br>  <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-type">void</span> *ptr);<br>  <span class="hljs-type">int</span> (*match) (<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>&#125;<span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>redis的字典基于哈希表实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>  <span class="hljs-comment">// 哈希表数组的指针</span><br>dictEntry **table;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>  <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值，总是等于size-1</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht:<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>  <span class="hljs-type">void</span> *key;<br> <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>    <span class="hljs-type">void</span> *val;<br>    <span class="hljs-type">uint64_t</span> u64;<br>    <span class="hljs-type">int64_t</span> s64;<br>  &#125; v;<br>  <span class="hljs-comment">// 指向下一个哈希表节点，形成链表</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>  dictType *type;<br>  <span class="hljs-type">void</span> *privdata;<br>  dictht ht[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> rehashidx;<br>&#125; dict;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span>;<br>  <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br>  <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);<br>  <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);<br>  <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);<br>  <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *obj);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><p><code>ht[0]</code>和<code>ht[1]</code>都是哈希表，一般情况下，字典只使用 <code>ht[0]</code>，只有在需要进行rehash的时候才会使用<code>ht[1]</code>。当不进行rehash的时候，<code>rehashidx</code>始终为-1。当负载因子不在合理范围时，需要rehash来调整表大小：</p><ol><li>给<code>ht[1]</code>分配空间，如果是扩展则为<code>ht[0].used*2</code>的下一个2^n^,  如果是收缩则为<code>ht[0].used</code>的下一个2^n^</li><li>将所有的<code>ht[0]</code>rehash到<code>ht[1]</code>上</li><li>全部迁移之后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，为<code>ht[1]</code>创建一个新的空表。</li></ol><p>如果服务器没有正在执行BGSAVE或者BGREWRITEAOF命令，name负载因子大于等于1时触发。如果正在执行，name大于等于5时触发。考量是在执行以上2种命令时，redis会创建子进程，根据<strong>写时复制</strong>的优化机制，需要尽可能减少对服务器内存IO的压力，因此调大负载因子的阈值。</p><p>注意，rehash是渐进式的，不是一口气完成的。因为如果哈希表很大，服务器需要马上处理完的话可能负担过重，因此是每次对字典执行操作时顺带做一点，每搬运一个Entry就将rehashidx增加1，全部完成后置为-1。在rehash期间，redis会现在<code>ht[0]</code>上查找数据，找不到则在<code>ht[1]</code>上再找。另外，插入操作会在<code>ht[1]</code>上进行，包装<code>ht[0]</code>上的数据只减不增。                                                                         </p><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。每个dictType结构保存了一组用于操作特定类型键值对的函数。</p><p>redis的哈希算法使用MurmurHash2。</p><p>由于dictEntry组成的链表没有尾部节点的指针，所以遇到冲突时，新节点会插入表头位置。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>有序数据结构，每个阶段维持多个其他节点的指针，支持平均O(logN)，最坏O(N)的节点查找。</p><p>在redis中跳跃表用的不多，只用于实现有序集合键和在集群节点中作为内部数据结构。</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>当一个集合只包含整数，且数量不多时，就会使用整数集合作为底层实现。<code>contents</code>中的数字从小到大有序，没有重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">intset</span> &#123;</span><br>  <span class="hljs-comment">// 编码方式</span><br><span class="hljs-type">uint32_t</span> encoding;<br>  <span class="hljs-comment">// 元素数量</span><br><span class="hljs-type">uint32_t</span> length;<br>  <span class="hljs-comment">// 保存元素的数组</span><br><span class="hljs-type">int8_t</span> contents[];<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然<code>contents</code>被声明为<code>int8_t</code>，但是真正的类型取决于<code>encoding</code>如何规定每个整数的位数。</p><p>当新元素的类型比整数集合内所有元素都长时，整数集合需要<strong>升级</strong>：根据新元素的类型，扩展<code>contents</code>的大小，重新分配空间；将原有的元素转换成新类型后，<strong>从后往前</strong>重新添加到<code>contents</code>。</p><p>注意：引发升级的新元素的长度总是比整数集合内所有现有元素长，所以这个新元素要么比现有元素都小，要么都大。因此插入位置只会在<code>contents</code>的开头或者末尾。</p><ol><li>升级机制提升了整数集合的灵活性，为C语言这种静态语言提供了用一个结构保存不同类型整数对的方法。</li><li>节约了内存。</li></ol><p>注意：<strong>不支持降级</strong>操作。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>列表键和哈希键的底层实现之一。当列表键只包含少量列表项，并且列表项是小整数或短字符串时，就会采用压缩列表。</p><p>压缩列表在内存中由几个连续的组成部分：</p><ol><li>zlbytes：记录压缩列表占用字节数，在重新分配内存和计算zlend时使用</li><li>zltail，记录尾节点距离起始位置的偏移量，可以直接确定尾节点的位置</li><li>zllen：记录节点数量。当这个值等于UINT16_MAX时，说明达到上限，真实数量需要遍历后获得</li><li>entryX：列表节点，长度不定</li><li>zlend：特殊值0xFF，标记压缩列表的末端</li></ol><p>列表节点：</p><ol><li>previous_entry_length：1字节或5字节，取决于前一个节点的字节数是否超过254。有这个就可以得知前一个节点的起始位置，从而实现列表的倒序遍历。</li><li>encoding：记录了content保存数据类型和长度。要么是1、2、5字节长度，以00、01、10开头的字节数组编码（用来表示不同的长度），要么是1字节长度，以11开头的整数编码。</li><li>content</li></ol><p>连锁更新：压缩列表内恰好有多个连续的，长度介意250到253字节的节点，在前面新增节点会导致它们的previous_entry_length不够用1字节，需要扩容，从而导致后续节点连锁反应。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>redis没有用以上数据结构直接实现键值对数据库，而是基于这些数据结构创建了对象系统，包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象。还基于<strong>引用计数</strong>实现<strong>内存回收</strong>机制和<strong>对象共享</strong>。redis对象还带有访问时间记录，在服务器启用maxmemory时，空转较久的键可能被优先删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// 类型，5个常量</span><br><span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>  <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>  <span class="hljs-comment">// 指向底层实现数据结构的指针</span><br>  <span class="hljs-type">void</span> *ptr;<br>  <span class="hljs-comment">// ...</span><br>&#125; orbj;<br></code></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/jzkNDO"><img src="https://s1.ax1x.com/2022/07/26/jzkNDO.png" alt="jzkNDO.png" style="zoom:50%;" /></a></p><p>encoding有以上这些类型。每种对象至少基于2中底层实现，见下表：</p><p><a href="https://imgtu.com/i/jzASR1"><img src="https://s1.ax1x.com/2022/07/26/jzASR1.png" alt="jzASR1.png" style="zoom:50%;" /></a></p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是：</p><ol><li><code>int</code>：如果字符串是整数值并且可以用<code>long</code>类型表示，<code>ptr</code>属性会保存整数值，<code>void*</code>会转成<code>long</code>。</li><li><code>raw</code>：如果是字符串值，且长度大于32字节</li><li><code>embstr</code>：如果是字符串值，且长度≤32字节。这是专门用于保存短字符串的一种优化编码方式。虽然和<code>raw</code>编码一样，需要用<code>redisObject</code>和<code>sdshdr</code>两个结构来表达字符串，但是<code>raw</code>会调用两次内存分配函数，<code>embstr</code>只会调用一次，分配一块连续内存给这2个结构。这样释放内存时也只用调用一次，而且2个结构再内存中紧挨着可以利用缓存优势。</li></ol><p>对于<code>int</code>编码的字符串，如果对这个“整数”进行了属于字符串的操作，则会改变编码为<code>raw</code>。</p><p>redis只实现了对<code>int</code>和<code>raw</code>的修改，因此<code>embstr</code>实际上是只读的，对其的修改都会令编码改变为<code>raw</code>。</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>当同时满足以下条件时，列表对象使用<code>ziplist</code>编码：</p><ol><li>保存的所有字符串元素的长度都小于64字节</li><li>元素数量少于512个</li></ol><p>否则使用<code>linkedlist</code>编码。</p><p>注意：这两个上限值都可以在配置文件中修改。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>底层是<code>ziplist</code>或者<code>hashtable</code>。</p><p>使用压缩列表时，每次插入键值对都是紧挨着插入队尾。</p><p>当同时满足以下条件时，哈希对象使用<code>ziplist</code>编码：</p><ol><li>保存的所有键和值的字符串元素的长度都小于64字节</li><li>元素数量少于512个</li></ol><p>否则使用<code>hashtable</code>编码。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>底层是<code>intset</code>或者<code>hashtable</code>。</p><p>使用<code>intset</code>时，要求所有元素为整数，且不超过512个。</p><p>当使用哈希表时，只使用键，值全部为NULL。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>底层是<code>ziplist</code>或者<code>skiplist</code>。</p><p>使用<code>ziplist</code>时，每个元素使用2个紧挨的压缩列表节点来保存，第一个保存元素的成员，的第二个保存元素的分值。</p><p>使用<code>skiplist</code>时，一个<code>zset</code>结构同时包含一个字典和一个跳跃表。跳跃表节点的object属性保存元素的成员，score属性保存分数。通过跳跃表，可以对有序集合进行<strong>范围性操作</strong>。字典创建了成员到分值的映射，可以实现O(1)的分值查询。</p><p>字典和跳跃表在底层是共用元素的成员和分值的，不会产生浪费。</p><p>当元素数量小于128个，所有元素成员的长度小于64字节时，使用<code>ziplist</code>编码。</p><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><p>Redis中有些命令可以对任意类型执行，但是有些只能用于特定类型，说明其中有类型检查的操作。类型检查通过<code>redisObject</code>的<code>type</code>属性实现的。</p><p>同种对象有不同的底层实现，命令需要根据底层实现的不同，或者是作用的键类型不同，选择正确的API来执行，这就是<strong>多态命令</strong>。</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">int</span> refcount;<br>&#125; orbj;<br></code></pre></td></tr></table></figure><p>C语言本身没有内存回收功能，因此Redis自己实现了基于引用计数的内存回收机制，由<code>redisObject</code>的<code>refcount</code>属性来记录。</p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>引用计数机制允许实现对象共享，有利于节约内存。Redis在初始化服务器时会创建0到9999共一万个字符串对象，因为它们大概率会被用来共享。</p><p>用<code>object refcount</code>命令可以查看引用计数。</p><p>注意：只支持整数值的共享，字符串对象和包含多个值的对象验证相同的复杂度太高。</p><h4 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">unsigned</span> lru:<span class="hljs-number">22</span>;<br>&#125; orbj;<br></code></pre></td></tr></table></figure><p>该属性记录了对象最后一次被命令程序访问的时间。<code>object idletime</code>可以查看给定键的空转时长。这个命令实现是特殊的，在访问键的值对象时，不会修改值对象的lru属性。</p><p>如果服务器开了maxmemory选项，并且服务器的回收内存算法为<code>volatile-lru</code>或者<code>allkeys-lru</code>，那内存超过上限时优先释放空转时长较高的键。</p><h2 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 保存服务器中所有数据库的数组</span><br>redisDb *db;<br><span class="hljs-comment">// 服务器中数据库数量</span><br><span class="hljs-type">int</span> dbnum;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Redis中所有服务器都要保存在服务器状态<code>redis.h/redisServer</code>结构对的db数组中，类型为<code>redis.h/redisDb</code>。<code>dbnum</code>默认为16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 记录客户端当前正在使用的数据库</span><br>redisDb *db;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis是键值对数据库，每个数据库的所有键值对都保存在<strong>键空间</strong>里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 数据库键空间，保存数据库中所有的键值对</span><br>dict *dict;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对数据库的读写还会附带一些维护操作：</p><ol><li>更新服务器键空间的命中或不命中次数</li><li>更新LRU</li><li>如果发现键以过期，要删除键后再进行剩余操作</li><li>如果有使用WITCH命令监视该键，则修改后要将键标记为dirty，从而让事务注意到这个键已被修改</li><li>服务器每修改一个劲键，都会对脏键计数器加1，这个计数器会触发服务器的持久化和复制操作</li><li>如果服务器开启了数据库通知功能，那么在对键修改后要按照配置发送相应的数据库通知。</li></ol><p><code>expire</code>命令可以设置某个键的生存时间，在多少秒后删除。</p><p><code>expireat</code>命令可以设置某个键的过期时间，在某个时间戳来临时删除。</p><p><code>ttl</code>命令查看一个键的生存时间或者过期时间。</p><p>以上单位都是秒。<code>pexpire</code>、<code>pexpireat</code>、<code>pttl</code>以毫秒为单位。</p><p>以上的设置命令，最后都会经过转换，然后执行<code>pexpireat</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 过期字典，保存键的过期时间</span><br>dict *expires;<br>&#125;;<br></code></pre></td></tr></table></figure><p>过期时间保存在<code>redisDb</code>中的过期字典中。虽然过期字典和键空间内都保存了键，但是指向的键对象是共享的，所以没有浪费内存。</p><p><code>persist</code>命令可以移除一个键的过期时间。</p><p>检查一个键是否过期，有一个函数，大致操作是获取过期时间，和当前UNIX时间戳比较。另一种方法是用<code>ttl</code>或<code>pttl</code>命令查看过期时间是否大于0，但是实际上Redis还是使用与函数操作类似的操作，因为直接访问过期字典比执行一个命令要快。</p><h4 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>在设置过期时间的同时创建定时器，到点删除。该策略保证过期的键会被尽快删除。这是对内存最友好，对CPU最不友好的策略。对于内存不紧张但是CPU紧张的服务器来说不合适。</p><p>而且，定时器需要用到时间事件，当前的实现是无序链表，查询一个事件的复杂度是O(N)，不能高效处理大量事件。</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>对过期键放任不管，只有每次从键空间中取键时，都检查是否过期。对CPU最友好，对内存不友好。过期的键可能长期霸占内存，如果永远不被访问的话，几乎可以视作<strong>内存泄漏</strong>。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>折中方案。难点在于确定删除操作的时长和频率。</p><h4 id="Redis的过期删除策略"><a href="#Redis的过期删除策略" class="headerlink" title="Redis的过期删除策略"></a>Redis的过期删除策略</h4><p>Redis实际采用的是惰性删除和定期删除两种策略配合，说明Redis更看重的是CPU性能。</p><p>惰性删除策略由<code>db.c/expireIfNeeded</code>函数实现，所以读写数据库的命令都会在执行前调用该函数检查键是否过期。因此，由于每个被访问的键都可以在执行具体操作前因过期被函数，所以每个命令的实现函数<strong>必须能处理键不存在的情况</strong>。</p><p>定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现。每当Redis的<strong>周期性操作</strong><code>redis.c/serverCron</code>函数执行时，<code>activeExpireCycle</code>都会被调用，它在<strong>规定时间内分多次</strong>遍历服务器中各数据库，从数据库的<code>expires</code>字典中<strong>随机检查</strong>一部分键对的过期时间。</p><h5 id="对RDB的影响"><a href="#对RDB的影响" class="headerlink" title="对RDB的影响"></a>对RDB的影响</h5><p>执行<code>save</code>和<code>bgsave</code>的命令创建一个新的RDB文件。在创建时，只会保存未过期的键。</p><p>在启动Redis服务器时，如果开启了RDB功能，那么会载入RDB文件：</p><ol><li>如果以主服务器运行，会检查键的过期时间，只载入未过期的键。</li><li>如果以从服务器启动，<strong>无论是否过期的键都会被载入</strong>。在主从服务器进行数据同步的时候，从服务器的数据库会被清空，所以一般来讲不检验也没事。</li></ol><h5 id="对AOF的影响"><a href="#对AOF的影响" class="headerlink" title="对AOF的影响"></a>对AOF的影响</h5><p>当服务器使用AOF持久化时，如果某个键已经过期但还未被删除，不会影响到AOF文件。当它被删除后，AOF会追加一条DEL命令，<strong>显式记录</strong>该键已经删除。</p><p>在执行AOF重写时，已经过期的键不会保存到重写后的AOF文件里。</p><h5 id="对复制的影响"><a href="#对复制的影响" class="headerlink" title="对复制的影响"></a>对复制的影响</h5><p>当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制，以此保证<strong>主从一致</strong>。</p><p>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令。</p><p>从服务器在执行客户端的读命令时，即使碰到过期键也不会删除，而是当做未过期的处理。只有收到主服务器的DEL命令后才会删除过期键。</p><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>2.8版本新增功能，可以让客户端通过订阅给定的频道或模式，来获知键的变化和命令执行情况。</p><p>比如<code>subscribe __keyspace@0__:message</code>命令可以订阅0号数据库的message键的执行了什么命令。这类关注<strong>某个键执行了什么命令</strong>的通知称为<strong>键空间通知</strong>。</p><p>比如<code>subscribe __keyspace@0__:del</code>命令可以订阅0号数据库的del命令作用于哪些键。这类关注<strong>某个命令被什么键执行了</strong>的通知称为<strong>键时间通知</strong>。</p><p>服务器配置的<code>notify-keyspace-events</code>选项决定了服务器所发送的通知类型。</p><p>发送通知</p><p>发送通知由<code>notify.c/notifyKeyspaceEvent</code>函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">notifyKeyspaceEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">char</span> *event, robj *key, <span class="hljs-type">int</span> dbid)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>type：想要发送的通知类型，程序根据这个值判断通知是否为服务器配置<code>notify-keyspace-events</code>选项想要的通知类型，由此决定是否发送通知。</p></li><li><p>event：时间名称</p></li><li><p>keys：产生事件的键</p></li><li><p>dbid：产生事件的数据库号</p></li></ul><p>在函数内部，会通过按位与的方式检查通知类型，是否允许发送键空间通知，是否允许发送键事件通知。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB既可以手动执行，也可以定时执行。RDB文件是经过压缩的二进制文件。</p><p><code>SAVE</code>命令会阻塞服务器进程，直到RDB文件创建完毕为止。</p><p><code>BGSAVE</code>命令会派生子进程来创建RDB文件，不会阻塞服务器，但是在BGSAVE执行期间，客户端的<code>SAVE</code>和<code>BGSAVE</code>命令会被拒绝。<code>BGSAVE</code>和<code>BGREWRITEAOF</code>也不能同时执行：</p><ul><li>如果<code>BGSAVE</code>正在执行，那么<code>BGREWRITEAOF</code>会被延迟到<code>BGSAVE</code>执行完成后执行。</li><li>如果<code>BGREWRITEAOF</code>正在执行，那么<code>BGSAVE</code>会被拒绝。</li></ul><blockquote><p>复习：fork()在父进程中的返回值是子进程的pid，在子进程的返回值是0</p></blockquote><p>实际创建工作由<code>rdb.c/rdbSave</code>函数完成，SAVE命令和BGSAVE最终都会调用这个函数。</p><p>RDB文件的载入是在服务器启动是自动执行的，因此没有专门的载入命令。只要检测到RDB文件存在，就会自动载入。实际工作由<code>rdb.c/rdbLoad</code>函数完成。载入期间服务器阻塞。</p><p>由于AOF文件的更新频率通常比RDB高，所以如果开启了AOF功能，那么<strong>优先使用</strong>AOF来还原数据。</p><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p><code>BGSAVE</code>允许Redis实现后台自动保存，通过<code>SAVE</code>设置多个规则，只要其中任意一个条件满足，就会触发<code>BGSAVE</code>。比如<code>save 300 10</code>，意思是如果在300秒内对数据库进行至少10次修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 记录了保存条件的数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> *<span class="hljs-title">saveparams</span>;</span><br>  <span class="hljs-comment">// 修改计数器</span><br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> dirty;<br>  <span class="hljs-comment">// 上次保存时间</span><br>  <span class="hljs-type">time_t</span> lastsave;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> &#123;</span><br>  <span class="hljs-comment">// 秒数</span><br>  <span class="hljs-type">time_t</span> seconds;<br>  <span class="hljs-comment">// 修改数</span><br>  <span class="hljs-type">int</span> changes;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>SAVE</code>设置的保存条件会被保存到<code>redisServer</code>结构的<code>saveparams</code>属性。除了这个数组，服务器还维持dirty计数器和上次修改时间。dirty计数器记录了距离上次成功执行<code>SAVE</code>或者<code>BGSAVE</code>后，服务器对数据库状态（所有数据库）进行多少次修改。<code>lastsave</code>记录上次成功执行<code>SAVE</code>或者<code>BGSAVE</code>的UNIX时间戳。</p><p>Reidis的服务器周期性操作<code>serverCron</code>函数默认每个<strong>100毫秒</strong>执行一次，该函数的工作之一就是检查保存条件是否满足。如果时间超过并且修改次数超过，就触发保存。</p><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>一个完整的RDB包含以下部分</p><ul><li>REDIS：5字节，保存“REDIS“5个字符，程序可以在载入时以此检测是否为RDB文件。</li><li>db_version：4字节，一个用字符串表示的整数，记录RDB的版本号，比如”0006“。该书只介绍第6版的文件结构。</li><li>database：包含0个或多个数据库</li><li>EOF常量：1字节，标志RDB正文结束。</li><li>check_num：8字节的无符号整数，校验和，通过前四部分计算得出。</li></ul><p>每个非空的database可以保存为：</p><ul><li>SELECTDB：1字节常量，程序读到这个值，表示接下来读入的是一个数据库号码</li><li>db_number：数据库号码，根据号码大小不同可以是1&#x2F;2&#x2F;5字节。当读到号码后，服务器会调用<code>SELECT</code>命令切换到对应数据库，使得之后读入的键值对可以载入到对应数据库。</li><li>kay_value_pairs：保存了数据库中所有的键值对。如果键有过期时间，该信息也会保存。如果没有过期信息则没有前两项<ul><li>EXPIRETIME_MS：1字节常量，告知程序接下来要读入的是以毫秒为单位的过期时间。</li><li>ms：8字节的带符号整数，以毫秒为单位的UNIX时间戳，表示过期时间。</li><li>TYPE：1字节，记录value的类型。每一个TYPE常量都对应一种对象类型或者底层编码。决定如何读入和解释value数据。</li><li>key：总是一个字符串的对象，编码方式和<code>REDIS_RDB_TYPE_STRING</code>类型的value一样。</li><li>value：这里书中有大量的详尽分析，这里不赘述。</li></ul></li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与RDB记录数据库状态不同，AOF记录的是写命令。AOF保存的命令都是以Redis的命令请求协议格式保存，而Redis的命令请求协议是纯文本格式，所哟AOF是人类可读的。</p><p>AOF持久化的实现分为命令追加、文件写入、文件同步三个步骤。</p><p>当AOF功能开启时，服务器每执行完一个写命令，会以协议格式将命令追加到服务器状态的<code>aof_buf</code>缓冲区末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br><span class="hljs-comment">// ...</span><br>sds aof_buf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis的服务器进程就是一个<strong>事件循环</strong>，文件事件负责接收命令和发送命令，时间事件负责执行像<code>serverCron</code>这样的定时运行函数。服务器每结束一个事件循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否需要将<code>aof_buf</code>对的内容写入AOF中。</p><p><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>决定：</p><ul><li>always：将缓冲区内容写入并同步</li><li>everysec：将缓冲区内容写入，如果距离上次同步超过1秒，那么再次同步，并且同步线程由另一个线程执行。这是<strong>默认选项</strong>。</li><li>no：将缓冲区内容写入，但是不同步，有操作系统决定。</li></ul><blockquote><p>为了提高文件写入效率，现代操作系统中，用户调用write时，操作系统通常将数据暂存到一个内存缓冲区中，等缓冲区被填满、或超过指定时限后，才真正将缓冲区写入到磁盘。这在提高效率的同时也带来安全问题，因此系统还提供了fsync和fdatasync两个同步函数，可以强制让操作系统将缓冲区写入硬盘，确保数据安全。</p></blockquote><p>因此，always是安全性最高，但是效率最差的配置，即使出现停机故障，也最多地都市一个事件循环中产生的命令数据。everysec足够快，并且最多丢失1秒的数据，因此作为默认项。no的写入速度最快，但是由于会在系统缓存中累计一段时间的写入数据，所以单词同步时长是最长的，故障时丢失上次同步后的所有数据。</p><h4 id="载入和还原"><a href="#载入和还原" class="headerlink" title="载入和还原"></a>载入和还原</h4><ol><li>创建一个不带网络连接对的伪客户端，因为Redis的命令只能在客户端的上下文中执行。</li><li>从AOF文件中分析并读取一条写命令</li><li>使用伪客户端执行写命令</li><li>重复2、3步骤，直到所有写命令被处理完</li></ol><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着时间流逝，AOF文件中内容会增多，文件体积变大。比如分别使用多次RPUSH命令向列表添加1个元素，其实效果和一次添加多个元素效果是一样的，这里就有改进空间。为了解决AOF体积膨胀问题，Redis提供了<strong>AOF文件重写</strong>功能，可以生成一个效果一样的新AOF文件，同时体积更小。</p><p>AOF重写不需要对现有的AOF进行任何读取、分析或写入操作，而是通过<strong>读取数据库状态</strong>实现的。比如用了多条命令对一个列表进行增删改，其实等价于一条插入命令来描述其最终状态。</p><p>为了避免执行命令时造成客户端输入缓冲区溢出，在重写列表、哈希表、集合、有序集合这四种可能带有多个元素的键时，会先检查键锁包含的元素数量，如果超过了<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>常量，则会使用多条命令来记录键。此书版本中为64。</p><p>但是，AOF重写需要的大量的写入，如果要阻塞服务器的话就无法处理请求，因此Redis将AOF重写放到子进程执行。这样父进程可以继续处理请求，而且子进程带有服务器进程的数据副本（子进程会复制父进程的内存空间），使用子进程而不是线程，可以在不使用锁的情况下保证数据安全。</p><p>为了解决在子进程进行AOF重写的过程中，父进程处理请求使数据库状态更新，导致的数据不一致问题，服务器设置了一个<strong>AOF重写缓冲区</strong>。该缓冲区在创建子进程后开始使用，Redis每执行完一个写命令，就会同时发送给AOF缓冲区和AOF重写缓冲区。</p><p>当子进程完成重写后，会向父进程发送一个信号，父进程接到后会调用信号处理函数，进行如下操作：</p><ol><li>将AOF重写缓冲区的内从写入新AOF文件中，此时新AOF文件所描述的数据库状态与服务器的达成一致。</li><li>对新AOF文件进行改名，<strong>原子</strong>地覆盖旧AOF文件。</li></ol><p>整个AOF后台重写过程中，只有<strong>信号处理函数</strong>执行时会阻塞服务器进程，大大降低了AOF重写对性能的影响。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis中的事件分2种类型：文件事件和时间事件。</p><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>基于Reactor模式开发的网络事件处理器。</p><p>文件事件处理器使用<strong>I&#x2F;O多路复用</strong>来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同对的事件处理器。当被监听的套接字准备好执行连接（accept）、读取（read）、写入（write）、关闭（close）等操作时，对应的文件事件就会产生，此时文件事件处理器会调用关联好的事件处理器来处理这些事件。</p><p>虽然文件事件处理器以<strong>单线程</strong>运行，但是通过使用I&#x2F;O多路复用同时监听多个套接字，既实现了高性能对的网络通信模型，又很好地与Redis服务器中其他同样以单线程运行的模块进行对接，保持Redis内部单线程设计的简单性。</p><img src="https://s2.loli.net/2022/08/01/OlL1nE9qBHiP8sv.png" style="zoom:40%;" /><p>文件事件处理器由这四部分组成。文件事件是对套接字操作的抽象。文件事件可能会并发的出现，但是事件会被放在队列里，以有序的、同步的、每次一个套接字传送到分派器。处理器就是一个个函数，分派器会调用根据事件类型调用它们。</p><p>Redis中的I&#x2F;O多路复用的功能来自于包装常见的select、epoll、evport、kqueue这些I&#x2F;O多路复用函数库实现的，每个在源码中对应一个文件，都实现了相同的API，所以多路复用的底层实现是可以<strong>互换</strong>的。在源码中有<code>#include</code>宏定义了相关规则，程序在编译是自动选择系统中性能最高的函数库作为底层实现。</p><p>从代码来看，evport &gt; epoll &gt; kqueue &gt; select。select是Linux系统中一定会有的，性能也最差，作为最后选择。</p><p>事件分<code>AE_READABLE</code>和<code>AE_WRITABLE</code>两种。</p><ol><li>连接应答处理器：<code>networking.c/acceptTcpHandler</code>函数对连接服务器监听套接字的客户端进行应答，具体实现为<code>sys/socket.h/connect</code>的包装。绑定了服务端socket的读事件。</li><li>命令请求处理器：<code>networking.c/readQueryFromClient</code>函数包装了<code>unistd.h/read</code>，客户端连接成功后，服务器就会将客户端套接字的读事件与该处理器关联。</li><li>命令回复处理器：<code>networking.c/sendReplyToClient</code>包装了<code>unistd.h/write</code>，关联了写事件。</li></ol><h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>一个时间事件主要有三个属性：</p><ul><li>id：全局唯一，自增，新事件的id比老事件大</li><li>when：毫秒精度的UNIX时间戳，记录事件的到达事件</li><li>timeProc：时间事件处理器，一个函数。</li></ul><p>时间事件分为定时事件和周期事件。具体取决于时间事件处理器的返回值：如果返回<code>ae.h/AE_NOMORE</code>则为定时事件，如果是其他整数值，则为周期事件，返回值是对<code>when</code>属性的更新。</p><p>服务器中所有时间事件都在一个<strong>无序链表</strong>中，新的事件总是插在表头。</p><p>在本书版本中，正常模式下Redis只使用<code>serverCron</code>一个时间事件，链表几乎退化为指针。在事件不多的情况下对性能没有影响。</p><p>在调度上，会循环调用事件处理函数，但是在函数内部会先计算最近到期的事件，然后根据该时长设置最大阻塞时间，这样既可以避免服务器频繁轮训，也可以确保<code>aeApiPoll</code>不会阻塞过长时间。服务器总是先等待和处理文件事件，再检查时间事件。由于时间事件总是在文件事件之后，因此时间事件看起来会“迟到”。</p><p><img src="https://s2.loli.net/2022/08/05/LFdKc2TmiGNUseg.png" alt="截屏2022-08-05 17.03.47"></p><p>对文件事件和时间事件的处理都是同步、有序、原子的。事件不会主动抢占，而是会为了减少总体阻塞时间适当让出执行权。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在服务器端，每个客户状态表达为<code>redis.h/redisClient</code>的结构。在服务器状态结构里，这些客户端状态被保存在一个链表中。</p><p>客户端结构中包含以下属性：</p><ul><li>fd：套接字描述符。伪客户端的fd为-1。</li><li>name：名字，默认情况下没有。</li><li>flags：角色，以及客户端所处的状态。</li><li>querybuf：输入缓冲区用于保存客户端发送的命令</li><li>argc, **argv：命令参数和参数数量。argv[0]是命令，之后的是参数。命令保存到缓冲区后，服务器会解析命令，命令参数和个数保存到这里。</li><li>struct redisCommand *cmd：服务器根据argv[0]一个字典中找到这个命令对应的实现函数，交给cmd指针。这个结构保存了命令的实现函数、标志、传参个数、总执行次数等信息。</li><li>输出缓冲区：<ul><li>bufpos和buf[]：固定大小缓冲区。用于保存长度较小的回复。bufpos记录已经使用缓冲字节数。buf数组默认16KB。</li><li>list *reply：固定缓冲区用尽或者太小时会启用可变大小缓冲区。是一个链表，可以保存各种类型的对象。</li></ul></li><li>authenticated：用0或1表达是否通过认证</li><li>ctime：客户端创建时间，可以用来计算客户端已经与服务器连接了多少秒。</li><li>lastinteraction：客户端最后一次与服务器进行互动的时间。可以计算客户端空转时间。，记录在<code>CLIENT list</code>命令的idle域。</li><li>obuf_soft_limit_reached_time：输出缓冲区第一次到达软限制的时间。</li></ul><p>有一种客户端关闭的情况是输出缓冲区过大。如果超过硬性限制会直接关闭；如果超过软限制，会先记录时间，如果缓冲区大小一直超过软限制，并且持续一段时间（时长可以配置），那么会关闭。一段时间内不再超过，则不关闭，并且计时器清零。</p><ul><li>lua_client：服务器在初始化时创建负责执行Lua脚本的伪客户端。</li><li>载入AOF文件时创建的伪客户端。</li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>命令请求的执行过程：</p><ol><li>用户端将用户输入的命令转换成协议格式，发送给服务器</li><li>套接字因为客户端的写动作而变得可读，服务器读取命令后保存到输入缓冲区，解析提取命令和参数保存到argv和argc，然后调用命令执行器<ol><li>现根据<code>argv[0]</code>保存的命令，在<strong>命令表</strong>中查找，保存到客户端的cmd属性。每个命令是一个<code>redisCommand</code>结构，其中比较重要的属性有：proc，函数指针，指向该命令对应的执行函数；arity，命令参数的个数，如果是负数则表示参数数量大于等于该值的正数；flags，通过一系列bit表达命令的属性，比如是读还是写，是否需要内存检查等。</li><li>执行预备操作，进行各种检查：检查cmd是否为空指针，检查参数个数，检查身份验证，如果打开了maxmenory则要检查内存占用情况。。。书中还列举的很多。</li><li>执行命令</li><li>后续工作</li></ol></li><li>发送回客户端</li></ol><h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h4><ol><li>Redis中需要经常获取系统当前时间，因此<code>unixtime</code>和<code>mstime</code>这redisServer的属性会被缓存，每100毫秒更新，因此精度不高，只会用于对精度要求不高的任务。</li><li><code>lruclock</code>默认每10秒更新一次，当服务器要计算一个数据库键的空转时间时，就会用<code>lruclock</code>减去对象的<code>lru</code>属性。</li><li><code>trackOperationsPerSecond</code>函数会每100毫秒执行一次，以抽样计算的方式估算并记录服务器在最近一秒处理多大的请求数量。</li><li><code>stat_peak_memory</code>属性记录服务器的内存峰值大小。每次serverCron执行时都会更新。</li><li>处理SIGTERM信号。Redis收到信号不会立刻结束，而是要先拦截下来，做好关闭前的准备动作（比如持久化）然后再关闭。</li><li>管理客户端：调用<code>clientsCron</code>函数，做两个检查：连接超时和输入缓冲区。</li><li>管理数据库：<code>databasesCron</code>函数，对一部分数据库检查，删除过期键，必要时收缩字典。</li><li>执行被延迟的<code>BGREWRITEAOF</code>命令。在执行<code>BGSAVE</code>是收到的<code>BGREWRITEAOF</code>会被延迟执行。</li><li>检查持久化操作的运行状态。服务器状态用<code>rdb_child_pid</code>和<code>aof_child_pid</code>属性记录执行BGSAVE和BGREWRITEAOF的子进程pid，用这两个属性可以检查命令是否正在执行。</li><li>将AOF缓冲区的内容写入AOF文件</li><li>关闭异步客户端：关闭输出缓冲区大小超出限制对的客户端</li><li>增加<code>cronloops</code>计数器，这个属性记录了该函数执行次数。目前唯一的作用是在复制模块中实现没执行<code>serverCron</code>函数N次就执行一次指定代码的功能。</li></ol><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><ol><li>创建一个<code>redisServer</code>类型的实例server作为服务器的状态。设置一些默认值，以整数、浮点数、字符串属性为主。</li><li>载入配置选项</li><li>初始化服务器数据结构</li><li>还原数据库状态</li><li>执行事件循环</li></ol><h2 id="多机服务器实现"><a href="#多机服务器实现" class="headerlink" title="多机服务器实现"></a>多机服务器实现</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>daily_report</title>
    <link href="/other/daily-report/"/>
    <url>/other/daily-report/</url>
    
    <content type="html"><![CDATA[<h1 id="实习记录"><a href="#实习记录" class="headerlink" title="实习记录"></a>实习记录</h1><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>该模块分为3个月的长期计划，1个月的中期计划和1周的短期计划。</p><p>第一个月</p><table><thead><tr><th>技术 &#x2F; 事项</th><th>掌握程度</th><th>预计用时</th></tr></thead><tbody><tr><td>Spring</td><td>了解用法，能够写简易demo</td><td>1周，先学习Spring Framework，预计暂时不需要SpringMVC。根据第一个教程的目录，需要学习完事务。</td></tr><tr><td>Spring Boot &#x2F; Spring Cloud</td><td>了解用法，能够写简易demo</td><td>1周，学习Spring Boot和Spring Cloud，学习程度可以略低于Spring，但是尽量能写出demo</td></tr><tr><td>上述其他技术</td><td>暂时了解即可。部分技术已经有所了解。</td><td>在完成Spring学习目标之后进行，预计1周以内，再做模拟需求的期间先学习马上需要用到的。</td></tr><tr><td>做模拟需求</td><td></td><td>预计共1-2周</td></tr></tbody></table><p>学习Spring暂定基于以下网络教程：<a href="https://www.w3cschool.cn/wkspring/pesy1icl.html%EF%BC%8Chttps://www.nhooo.com/spring/spring-tutorial.html%EF%BC%8Chttp://c.biancheng.net/spring/module.html%E3%80%82%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E%EF%BC%8C%E5%90%8E%E8%80%85%E4%BD%9C%E4%B8%BA%E5%89%8D%E8%80%85%E7%9A%84%E8%A1%A5%E5%85%85%E3%80%82">https://www.w3cschool.cn/wkspring/pesy1icl.html，https://www.nhooo.com/spring/spring-tutorial.html，http://c.biancheng.net/spring/module.html。优先级从高到低，后者作为前者的补充。</a></p><p>第二个月：</p><ul><li>（可能）拉取项目代码学习</li><li>学习和复习Mysql和Redis的原理部分（较深入）</li><li>MyBatis和MyBatis-Plus的使用方法。</li></ul><p>第三个月：</p><ul><li>了解Kafka &#x2F; ZooKeeper等分布式技术</li><li>了解分布式技术在该项目中的应用</li><li></li></ul><h2 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h2><h3 id="6月20日"><a href="#6月20日" class="headerlink" title="6月20日"></a>6月20日</h3><p>实习入职第一天。</p><ul><li><input checked="" disabled="" type="checkbox"> 入职手续</li><li><input checked="" disabled="" type="checkbox"> 熟悉办公软件</li><li><input checked="" disabled="" type="checkbox"> 了解未来要使用的技术栈<ul><li>Java开发，Spring全家桶：Spring &#x2F; Spring Cloud &#x2F; Open Feign &#x2F; MyBatis-Plus &#x2F; gRPC</li><li>数据库和文件存储：seaweedFS &#x2F; cockroach &#x2F; Mysql &#x2F; Reids</li><li>分布式：Kafka &#x2F; ZooKeeper</li><li>项目管理和部署：Maven &#x2F; Docker &#x2F; Docker-Compose</li></ul></li></ul><p>需要了解的：Kafka &#x2F; ZooKeeper &#x2F; Maven &#x2F; Docker &#x2F; Docker-Compose</p><p>需要熟悉的（会用）：数据库</p><p>需要重点掌握的：Spring全家桶</p><p>彬沈：大约两周的时间学习，然后完成一个模拟需求，再进入项目。</p><p>明日计划：学习Spring的基础部分（IoC，AoP等），根据教程可以创建demo项目。</p><h3 id="6月21日"><a href="#6月21日" class="headerlink" title="6月21日"></a>6月21日</h3><p>无论是创建还是销毁，实现<code>InitializingBean</code>, <code>DisposableBean</code>接口调用的方法都晚于XML配置的方法。一般不建议使用接口实现， 因为XML配置更具灵活性。</p><p>beans标签下指定<strong>default-init-method</strong> 和 <strong>default-destroy-method</strong> 可以设置所有bean的默认初始化和销毁行为。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6000O Cloud Computing Note</title>
    <link href="/college/6000O-cloud-computing/"/>
    <url>/college/6000O-cloud-computing/</url>
    
    <content type="html"><![CDATA[<h1 id="6000O-Cloud-Computing-Note"><a href="#6000O-Cloud-Computing-Note" class="headerlink" title="6000O Cloud Computing Note"></a>6000O Cloud Computing Note</h1><h2 id="1-Cloud-Pricing-and-Economics"><a href="#1-Cloud-Pricing-and-Economics" class="headerlink" title="1. Cloud Pricing and Economics"></a>1. Cloud Pricing and Economics</h2><h2 id="三种计费模式"><a href="#三种计费模式" class="headerlink" title="三种计费模式"></a>三种计费模式</h2><ul><li><p>Reservation-based</p><p>Cost(t) &#x3D; Upfront + discount * R(On-demand rate) * t</p><p>作用：Guaranteed availability，无论数据中心多么繁忙都能保证资源可用</p><p>适合stable workload</p></li><li><p>Spot pricing</p><p>用户提交一个竞标（bid），云定期查看出价，出价最高的用户竞标成功</p><p>通常比on-demand便宜很多，因为没有No service guarantee。用户的bid不会超过on-demand的价格。</p><p>偶尔会有spot price很高的情况，是因为服务器把空间资源用spot pricing卖掉，用出价这种方式来回收。</p></li><li><p>On-demand</p></li></ul><p>为什么要有不同计费模式：</p><p>Market segmentation：每种模式适合的用户不同</p><p>供应方的问题：</p><ul><li><p>资源有限</p></li><li><p>每种类型分配多少资源</p></li><li><p>每种类型如何定价</p></li></ul><p>用户方的问题：</p><ul><li>需要预测需求</li><li>需要预测spot price的价格，并且想办法活用</li></ul><p>Cloud brokerage service：专门的公司来解决以上客户问题</p><h2 id="Total-Cost-of-Ownership-TCO"><a href="#Total-Cost-of-Ownership-TCO" class="headerlink" title="Total Cost of  Ownership (TCO)"></a>Total Cost of  Ownership (TCO)</h2><p>决定要自己部署本地机房还是用云服务。</p><p>Total cost of ownership (TCO)：系统直接和间接成本的估算</p><h2 id="提供者如何盈利"><a href="#提供者如何盈利" class="headerlink" title="提供者如何盈利"></a>提供者如何盈利</h2><p>提供者使用资源池和multi-tenant model来服务客户。用不同的物理和虚拟资源来动态分配。</p><ul><li><p>Location Independence：用户不知道自己的服务是在哪里被实现的。</p></li><li><p>资源池可以实现很高的资源利用率。</p></li><li><p>规模经济：机房越大，单价越省</p></li><li><p>Statistical multiplexing：灵活满足不同的用户在不同时间的资源需求</p></li></ul><h2 id="2-Service-Models-and-Challenges"><a href="#2-Service-Models-and-Challenges" class="headerlink" title="2. Service Models and Challenges"></a>2. Service Models and Challenges</h2><h4 id="Cloud-deployment-models"><a href="#Cloud-deployment-models" class="headerlink" title="Cloud deployment models"></a>Cloud deployment models</h4><ul><li>Public</li><li>Private：安全、没有网络带宽和可用性问题</li><li>Hybrid</li></ul><h4 id="Cloud-Service-Models"><a href="#Cloud-Service-Models" class="headerlink" title="Cloud Service Models"></a>Cloud Service Models</h4><p>架构：硬件、虚拟化、基础设施、平台、应用</p><ul><li><p>IaaS</p><p>提供者将硬件资源虚拟化，用户得到一台虚拟机，可以完全控制操作系统、存储和网络。典型案例：Netflix</p></li><li><p>PaaS</p><p>提供软件平台，或者中层，来供应用运行。用户要维护和部署他们的应用在平台上。</p><p>硬件资源自动分配，用户无法指定。</p><p>可以自动扩展，但是用户无法控制操作系统、存储和网络。</p></li><li><p>SaaS</p><p>提供软件和应用，并且来维护。用户只管使用。</p></li></ul><p>从上到下，灵活性和定制性增强，但是便利性和易管理性减弱。</p><p>XaaS：</p><ul><li><p>FaaS（function）</p><p>用户通过云函数的形式编写应用，规定触发函数执行的事件。然后云平台接管一切，包括资源分配、自动伸缩、容错等。用户只用根据<strong>CPU时间</strong>来付费。用户不管理服务器，因此也叫<strong>serverless computing</strong></p><p>好处：不用管理服务器，全由云提供者来维护；省钱，不用为空闲时间付费；灵活伸缩，由云提供者配置；高可用和高容错</p></li><li><p>MLaaS</p></li></ul><h4 id="Issues-of-Cloud"><a href="#Issues-of-Cloud" class="headerlink" title="Issues of Cloud"></a>Issues of Cloud</h4><ul><li>availability：停电等故障会导致损失</li><li>数据丢失</li><li>Vendor lock-in：某个云中的应用无法迁移到另一个</li><li>安全性</li><li>隐私性：云服务商会偷窥数据吗</li></ul><h4 id="Challenges-facing-cloud-providers"><a href="#Challenges-facing-cloud-providers" class="headerlink" title="Challenges facing cloud  providers"></a>Challenges facing cloud  providers</h4><ul><li>storage：大数据集无法存在本地，持久存储必须分布式；本地存储是脆弱的。</li><li>Scale：</li><li>Faults and failures：机器难免出问题</li><li>Networking：带宽、公平性、如何保证网络又快又稳定</li><li>Machine heterogeneity：每个机器的硬件都不同，如何保证性能；难以提供可预测和稳定的服务；难以监控系统，识别性能瓶颈，和掉队者的原因；难以达成用户之间的<strong>公平共享</strong>。</li></ul><p>目标：</p><ul><li>可以运行在各种规模上</li><li>容错</li><li>可预测的服务</li><li>高利用率</li><li>高上行和下行带宽</li><li>尽量少的人工干预</li></ul><h2 id="3-Virtualization"><a href="#3-Virtualization" class="headerlink" title="3. Virtualization"></a>3. Virtualization</h2><p>虚拟化是一个宽泛的术语。它可以应用于所有类型的资源（CPU、内存、网络等）</p><p>通过跨多个环境共享一台计算机的资源，允许一台计算机“看起来”像多台计算机，执行多个作业。</p><ul><li><p>Host：底层的物理机器</p></li><li><p>Virtual Machine Manger (VMM) or hypervisor：通过提供与主机相同的接口创建和运行虚拟机（半虚拟化情况除外）</p></li><li><p>virtual machine (VM)：基于软件实现的计算机，可用于运行通用的操作系统</p></li><li><p>Guest：通常是操作系统</p></li></ul><h3 id="Implementation-of-VMMs"><a href="#Implementation-of-VMMs" class="headerlink" title="Implementation of VMMs"></a>Implementation of VMMs</h3><ul><li><p>Type-0 hypervisors</p><p><strong>基于硬件</strong>的解决方案，通过固件（firmware）支持虚拟机的创建和管理。常见于大型机和大中型服务器中。</p></li><li><p>Type-1 hypervisors</p><p>类似操作系统的软件，直接在纯粹的基于x86的系统上提供虚拟化层。比如VMWare ESX。本身就类似于OS，其上可以有各种Guest OS。</p><p>还包括提供标准功能和VMM功能的通用操作系统。通常没有专用的1型虚拟机监控程序功能丰富</p></li><li><p>Type-2 hypervisors</p><p>VMM本身是一个进程（程序），由主机运行和管理。比如Virtual Box，运行在Host OS之上。</p><p>非常易用。由于是通过Host OS来间接访问硬件，性能不好，需要host OS授权，一般是个人使用。</p></li><li><p>Other variations</p><ul><li>Para-virtualization：将Guest OS修改为与VMM协作以优化性能的技术。Guest OS知道自己是虚拟机。</li><li>Programming-environment virtualization：VMM不会虚拟化真正的硬件，而是创建一个优化的虚拟系统，例如JVM</li><li>Emulators：允许为一个硬件环境（如iOS，Android）编写的应用程序在不同的硬件环境中运行</li></ul></li></ul><p>Type-1 hypervisors和Para-virtualization是云计算中最流行的。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>早期的大型机有很多问题：只能是batch-oriented；架构不兼容，升级硬件必须修改软件</p><p>MIT研发MAC (Multiple Access Computer)，是一种分时系统</p><ul><li>隔离：主机系统受VM保护；虚拟机相互保护</li><li>冻结、暂停、运行虚拟机：VM可以暂停和拷贝</li><li>有利于研究OS和系统开发</li><li>实时迁移</li></ul><p>计算机有一系列硬件：CPU，内存，IO设备，其他</p><p>OS：提供应用软件访问硬件资源的特殊软件层。与任何其他程序一样运行，但以特权（内核）CPU模式运行，将自己保护与用户程序中。可以访问硬件，执行敏感指令。</p><ul><li>为应用程序提供高级编程接口（系统调用接口），OS实现接口来调用底层设备。</li><li>与硬件互动，代表硬件控制程序的指令</li></ul><p>Application：</p><ul><li>依赖于系统调用接口的程序，在用户态运行。通过特殊指令来调用OS</li><li>MMU硬件允许操作系统给程序提供<strong>虚拟地址空间</strong>，让程序认为自己内存充足</li></ul><h3 id="How-does-virtualization-work"><a href="#How-does-virtualization-work" class="headerlink" title="How does virtualization work?"></a>How does virtualization work?</h3><p>如果将OS（比如Windows）当做用户态的程序运行，大部分时间是可行的，但是：</p><ul><li>如果需要进入内核态执行敏感指令？</li><li>Guest OS该用那个硬件？</li><li>如何保护Guest OS上的程序不会伤害GuestOS</li></ul><h4 id="Trap-and-emulate"><a href="#Trap-and-emulate" class="headerlink" title="Trap-and-emulate"></a>Trap-and-emulate</h4><p>Guest OS必须运行在用户态。Guest VM需要virtual user mode 和  virtual kernel mode，让Guest以为自己在正常运行，但实际上这两个模式都运行在<strong>用户态</strong>。只有VMM可以运行在<strong>内核态</strong>。</p><p>GuestOS中导致切换到内核模式的操作必须导致VM切换到虚拟内核模式。</p><p>如何从虚拟用户模式切换到虚拟内核模式？</p><ol><li>Trap：Guest在用户模式下尝试特权指令会导致错误——主机陷阱到内核模式</li><li>Emulate：VMM获得控制权，分析错误，模拟Guest尝试的指令的效果。VMM为Guest提供了一个虚拟硬件&#x2F;软件接口</li><li>Return：VMM在用户模式下将控制权返回给Guest</li></ol><h4 id="Correctness-requirement"><a href="#Correctness-requirement" class="headerlink" title="Correctness requirement"></a>Correctness requirement</h4><p>指令有两种：</p><ul><li>Privileged instructions：当CPU处于用户态时，被trap（需要内核态）</li><li>Sensitive instructions：修改（虚拟）硬件配置或资源的指令，以及行为依赖于（虚拟）硬件配置的指令，比如读写，设置寄存器</li></ul><p>Emulation is only needed for sensitive instructions</p><p>Popek &amp; Goldberg要求：如果敏感指令集是特权指令的子集，则可以高效且安全地构造VMM。这是对CPU架构的要求，但好多CPU不支持，有些敏感指令会运行在用户态。</p><h4 id="How-about-the-performance"><a href="#How-about-the-performance" class="headerlink" title="How about the performance?"></a>How about the performance?</h4><p>如果Popek &amp; Goldberg要求达到，那么性能会如何？</p><ul><li><p>Non-sensitive instructions：几乎没有开销，虚拟机和真机几乎一样快。</p></li><li><p>Sensitive instructions：如果引发trap，必须被引导到VMM并被其模拟。每一条指令可能需要数十条本机指令来模拟。</p><p>I&#x2F;O或系统调用密集型应用程序受到重创。</p></li></ul><h4 id="Trap-and-emulate并不总是管用（重点）"><a href="#Trap-and-emulate并不总是管用（重点）" class="headerlink" title="Trap-and-emulate并不总是管用（重点）"></a>Trap-and-emulate并不总是管用（重点）</h4><p>Trap-and-emulate依赖CPU error来捕获特权指令，如果所有的敏感指令都是特权指令，那么VMM可以提前预知到所有的敏感指令。</p><p>Intel架构不符合要求。popf指令，从堆栈内容加载CPU标志寄存器。</p><ul><li>如果CPU在内核态：所有flag都被替换</li><li>如果CPU在用户态：只有部分flag被替换，并且不会陷入内核态。</li></ul><p>Prof是敏感但不特权的指令，不能用Trap-and-emulate来虚拟化。</p><p>有些CPU没有明确区分特权指令和非特权指令，这使得一些特殊指令无法虚拟化。英特尔CPU直到1998年才被认为是可虚拟化的。</p><p>3种解决方法：</p><ul><li><p>Full virtualization：Emulate + binary translation</p></li><li><p>Para-virtualization：修改GuestOS以避免不可虚拟化的指令</p></li><li><p>Hardware-assisted virtualization：修复CPU</p></li></ul><h4 id="Full-virtualization"><a href="#Full-virtualization" class="headerlink" title="Full virtualization"></a>Full virtualization</h4><p><strong>x86 protection rings</strong></p><p>Intel x86架构有4个保护级别，从高到底为ring0-3。ring0对应内核态，ring3对应用户态，ring1和ring2在现代OS中不使用。ring0可以执行所有指令。</p><p>另Guest OS kernel运行在ring1，每当Guest要运行敏感指令时，Hypervisor会发现，并用binary translation将CPU从ring1陷入ring0，模拟运行结果然后返回。</p><p>注意：Full virtualization并不依赖与x86架构</p><p>binary translation的思路很简单，但是实现很复杂。</p><ul><li><p>如果Guest VCPU处于用户模式，guest可以以本机方式运行指令</p></li><li><p>如果Guest VCPU处于（虚拟）内核模式，hypervisor会检查Guest将要执行的每一条指令</p><ul><li>非特殊指令自然运行</li><li>将特殊指令转换为新的指令集，在仿真硬件中执行等效任务</li></ul></li></ul><p>hypervisor向VM的Guest OS提供一整套模拟硬件。无论主机系统上的实际物理硬件是什么，模拟硬件都保持不变。</p><p>binary translation的步骤：</p><ol><li>trapping I&#x2F;O calls：每当GuestPS请求硬件时，例如请求BIOS提供硬件列表，它都会被hypervisor捕获</li><li>emulate&#x2F;translate：无法虚拟化的指令被翻译为安全指令</li></ol><p>GuestOS被欺骗，以为它在ring0中运行特权代码。它实际上运行在主机的ring1中，hypervisor模拟硬件并捕获特权代码。</p><p>优点：</p><ul><li>不需要修改GuestOS</li><li>防止不稳定的虚拟机影响系统性能</li><li>VM移植性</li></ul><p>缺点：</p><ul><li>没有优化，性能就不好。可能的解决方案是：缓存特殊指令的翻译，以避免将来再次翻译</li></ul><h4 id="Para-virtualization"><a href="#Para-virtualization" class="headerlink" title="Para-virtualization"></a>Para-virtualization</h4><p>旨在通过硬件仿真克服完全虚拟化带来的性能损失。要求修改GuestOS的内核。最著名的实现是<strong>Xen</strong>。云计算中<strong>事实上</strong>的虚拟化技术。</p><p>指出Full virtualization是错误方向：对Full virtualization的支持从来都不是x86体系结构设计的一部分。</p><ul><li>为了实现正确的虚拟化，VMM必须处理某些监控器指令，但在权限不足的情况下执行这些指令会以静默方式失败，而不会造成方便的trap。</li><li>高效虚拟化x86 MMU也很困难（需要维护一个影子页表）</li><li>这些问题是可以解决的，但代价是复杂性增加和性能降低</li></ul><p>在某些情况下，GuestOS希望看到真实的和虚拟的资源：</p><ul><li>提供实时和虚拟时间可以让GuestOS更好地支持对时间敏感的任务，并正确处理TCP超时和RTT估计</li><li>公开真实的机器地址允许GuestOS通过使用超级页面或页面着色来提高性能</li></ul><p>Paravirtualization：权衡对GuestOS的小改动，与性能和VMM简单性方面的大提升。</p><p>Modified GuestOS kernel也运行在ring1，通过hypercall来调用Xen Hypervisor。</p><h5 id="VM-Memory-Interface"><a href="#VM-Memory-Interface" class="headerlink" title="VM Memory Interface"></a>VM Memory Interface</h5><p>虚拟化内存很难，但如果架构有以下部分则会变简单：</p><ul><li>一个由软件管理的TLB（转译后备缓冲区），可以有效地虚拟化</li><li>标记的TLB（带有地址空间标识符的TLB），不需要在每次转换时刷新</li></ul><p>不幸的是，这两种功能在x86中都不受支持。VMware的解决方案（full virtualization）使用shadow page  tables，这可能非常慢！</p><p>Xen的解决方案（直接页表访问）</p><ul><li><p>GuestOS允许对<strong>真实页表</strong>进行<strong>只读</strong>访问。<strong>对页表（PT）的更新必须由hypervisor验证</strong>，这确保来GuestOS只能映射到分配给它的物理内存。</p></li><li><p>GuestOS使用hypercall分配和管理自己的PTs</p></li><li><p><strong>Xen存在于每个OS地址空间顶部的64MB区域中</strong>，因此在进入和离开虚拟机监控程序时避免了TLB刷新</p></li></ul><h5 id="VM-CPU-Interface"><a href="#VM-CPU-Interface" class="headerlink" title="VM CPU Interface"></a>VM CPU Interface</h5><p>trap&#x2F;expection （系统调用、页面错误）处理程序向Xen注册以进行验证。</p><p>GuestOS可能会为系统调用安装一个“快速”异常处理程序，允许应用程序直接调用其GuestOS，并避免在每次调用时通过Xen间接调用</p><h5 id="Control-Transfer"><a href="#Control-Transfer" class="headerlink" title="Control Transfer"></a>Control Transfer</h5><p>在Xen中没有硬件中断，都是由软件事件来实现的。Xen用事件来告知GuestOS发生了什么。</p><p>Hypercalls：从GuestOS到Xen的同步调用（类似于系统调用）</p><h4 id="Para-vs-Full-Virtualization"><a href="#Para-vs-Full-Virtualization" class="headerlink" title="Para vs. Full Virtualization"></a>Para vs. Full Virtualization</h4><p>Full Virtualization</p><ul><li>不要更改操作系统，除非在运行时（二进制翻译）</li><li>性能缓慢（有时不正确）</li></ul><p>Para Virtualization：</p><ul><li>对操作系统的更改最少</li><li>更好的性能和操作系统与虚拟硬件之间更快的交互</li></ul><h3 id="Cloud-infrastructures"><a href="#Cloud-infrastructures" class="headerlink" title="Cloud infrastructures"></a>Cloud infrastructures</h3><p>云计算通常与虚拟化有关</p><ul><li>“高度弹性”</li><li>在虚拟化环境中启动新虚拟机既便宜又快速</li><li>将多个虚拟机整合到一台物理机器上可以提高利用率</li></ul><p>云基础设施实际上是一个虚拟机管理基础设施</p><p>IaaS:</p><ol><li>客户端选择一个映像文件来启动VM</li><li>控制器选择服务器来承载VM</li><li>数据传输</li><li>启动VM</li></ol><p>公有云总是需要虚拟技术，对于私有云而言不一定，谷歌的集群都是建立在裸机之上的：高效而无性能损失。Container</p><h2 id="4-Container-Virtualization"><a href="#4-Container-Virtualization" class="headerlink" title="4. Container Virtualization"></a>4. Container Virtualization</h2><p>Configure once, run anything。一次配置，到处运行。</p><p>VM vs. Containers：容器是隔离的，但是共享OS、bins&#x2F;库</p><p>虚拟机系统调用路径：</p><ul><li>虚拟机内部的应用程序进行系统调用</li><li>陷入Hypervisor（或主机操作系统）</li><li>把trap还给GuestOS</li></ul><p>容器虚拟化系统调用路径</p><ul><li>容器内的应用程序进行系统调用</li><li>陷入OS</li><li>操作系统将结果返回给应用程序</li></ul><p>从高层看，容器就是轻量的VM</p><ul><li>有自己的进程空间</li><li>自己的网络接口</li><li>可以以root运行</li><li>可以有自己的 &#x2F;sbin&#x2F;init</li></ul><p>从底层看：容器就是一个隔离的进程</p><p>容器的实现利用Linux内核机制</p><ul><li>namespace：每个进程的资源独立</li><li>cgroups：管理流程组的资源</li><li>seccomp：限制可用的系统调用</li><li>capabilities：限制可用权限</li><li>CRIU：checkpoint&#x2F;restore (w&#x2F; kernel support)</li></ul><p>什么name需要虚拟化：</p><ul><li>进程ID：<code>top</code>指令在容器中只显示容器中的进程。在容器外部，<code>top</code>指令可能会显示容器内的进程ID，但是可能不同。</li><li>文件名：容器内的进程可能对装载的文件系统有有限的不同视图。文件名可能会解析为不同的名称，容器外的一些文件名可能会被删除。</li><li>用户名：容器可能有不同的用户和不同的角色。容器内的<code>root</code>不一定是外部的<code>root</code></li><li>主机名和IP地址：容器内的进程在执行网络操作时可能会使用不同的主机名和IP地址。</li></ul><p>在进程粒度上限制内核端<strong>名称</strong>和数据结构的范围。</p><p>三个系统调用来管理：clone(), unshare(), setns(int fd, int nstype)</p><p>资源管理：操作系统可能希望确保整个容器，或其中运行的所有东西，消耗的能量不能超过一定量的CPU时间、内存、硬盘或者网络带宽。</p><p><strong>cgroups：Linux控制组</strong></p><p>控制组子系统为一组流程提供资源管理解决方案。<br>每个子系统都有一个层次结构（树），CPU、内存、块I&#x2F;O有独立的层次结构。每个进程都位于每个层次结构中的一个节点中，每个节点都是一组共享资源的进程。</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Container：一种基于cgroup和名称空间等内核机制的轻量级资源虚拟化。<br>多个容器在同一个内核上运行，并误以为它们是唯一使用资源的容器。</p><h2 id="5-Distributed-Storage-System"><a href="#5-Distributed-Storage-System" class="headerlink" title="5. Distributed Storage System"></a>5. Distributed Storage System</h2><p>就算能把单个硬盘做得足够大，也无法解决IO瓶颈，伸缩性很差。<br>CPU运算速度远高于硬盘读取速度。<br>建造一台高端超级计算机的成本非常非常高。<br>将所有数据存储在一个位置会增加硬件故障的风险。</p><p>Google的解决方式：向外扩展，而不是向上扩展。增加更多机器，而不是把机器做大。</p><p>许多廉价的、商品化的PC，每台都有磁盘和CPU。<br>高总存储容量，而不是增加单个硬盘的容量。<br>在多台机器上分散搜索处理：高I&#x2F;O带宽，与机器的数量成比例；并行化数据处理。</p><p>注意：机器越多，每个时刻可能有机器出问题的概率越大。</p><p>在大范围内，超级花哨的可靠硬件仍然会失败，尽管失败的频率较低。</p><p>可靠性必须来自<strong>软件</strong>！</p><p>GFS：建立在高度不可靠硬件之上的高度可靠的存储系统</p><h3 id="Target-environment（系统假设）"><a href="#Target-environment（系统假设）" class="headerlink" title="Target environment（系统假设）"></a>Target environment（系统假设）</h3><p>大量机器、分布式、出错时正常的<br>文件很大，但是数量不多。&gt;100M，一般是几个G大，几百万个文件。<br>一次写入，多次读取。文件通过追加来修改。大的流式读取和小的随机读取是典型的。<br>I&#x2F;O带宽比延迟更重要。适用于批处理和日志分析。<br>如果文件系统为并发附件提供同步，这会很有帮助。</p><h3 id="Design-Decisions"><a href="#Design-Decisions" class="headerlink" title="Design Decisions"></a>Design Decisions</h3><p>文件存储被分为数据块，大小为64MB。小于单个块的文件<strong>不会</strong>占用整个块的存储空间。</p><p>为什么使用大块：将磁盘搜索的成本降至最低；将文件传输速率提高到磁盘传输速率（传输时间远大于检索时间，2者相加等于文件传输时间 ）</p><p><strong>通过复制实现可靠性</strong><br>3-way replication：每个区块在3个以上的区块服务器上复制，同一个rack有一个副本，其他rack上有2+副本。</p><p>单master协调访问：维护元数据（文件名、权限、区块索引、文件夹层次结构等）。<br>文件数据存储在其他服务器上。访问数据需要向master申请。</p><p>添加<strong>记录追加</strong>操作，支持实时追加。</p><h3 id="General-Architecture"><a href="#General-Architecture" class="headerlink" title="General Architecture"></a>General Architecture</h3><p>Single master, Multiple chunkservers</p><ol><li>用file name和chunk index，向GFS Master查询</li><li>Master返回chunk的信息（chunk handle和locations）</li><li>客户向chunk server发送chunk句柄和byte range</li><li>chunkserver返回data</li></ol><p>可能的问题：</p><ol><li><p>Single point of failure：如果master掉线怎么办、</p><p>增加<strong>shadow master</strong></p></li><li><p>Scalability bottleneck：如果master遇到瓶颈怎么办</p><p>尽量减少主机参与，以解决可扩展性问题</p><ul><li>不参与数据传输，只用做元数据</li><li>大chunk：最小化搜索&#x2F;索引时间</li><li><strong>chunk leases</strong>：master将权限委托给数据中的主副本</li></ul></li></ol><h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>三种元数据都保存在内存中</p><ul><li>文件和chunk的命名空间</li><li>从文件到chunk的映射（每个chunk都有一个唯一的ID）</li><li>每个chunk副本的位置</li></ul><p>前2种类型通过<strong>操作日志</strong>持久化。</p><p>第3种操作通过在启动时轮询chunkservers获得的区块副本位置。Chunkserver是其持有的区块的最终仲裁者 </p><h4 id="Master的职责"><a href="#Master的职责" class="headerlink" title="Master的职责"></a>Master的职责</h4><ul><li>元数据存储</li><li>命名空间管理&#x2F;锁定</li><li>与服务器的定期通信：给出指示、收集状态、跟踪群集运行状况</li><li>区块创建、重新复制、重新平衡<ul><li>在racks上分散副本，减少错误</li><li>如果冗余低于阈值，则重新复制数据</li></ul></li><li>垃圾回收：比传统的文件删除更简单、更可靠<ul><li>master记录删除，将文件重命名为隐藏名称，惰性回收隐藏文件</li></ul></li><li>过时副本删除：使用ckunk版本号检测“过时”副本</li></ul><h4 id="Chunkserver"><a href="#Chunkserver" class="headerlink" title="Chunkserver"></a>Chunkserver</h4><ul><li>在本地磁盘上存储64 MB的文件块，每个块都有<strong>版本号</strong>和校验和。</li><li>读&#x2F;写请求指定块<strong>句柄</strong>和<strong>字节范围</strong>。</li><li>在可配置数量的Chunkserver上复制的区块（默认：3-way复制）</li><li>无文件数据缓存</li></ul><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><ul><li>向master发出控制（元数据）请求，比如<code>ls</code>命令</li><li>直接向服务器发出数据请求，比如<code>cat</code>命令</li><li>缓存的不是文件数据，而是元数据，这样可以减少与master的交互</li></ul><h3 id="File-read-and-write"><a href="#File-read-and-write" class="headerlink" title="File read and write"></a>File read and write</h3><p>文件读取：</p><ol><li>应用程序发起读取请求</li><li>GFS客户端翻译请求并将其发送给master </li><li>Master使用块句柄和副本位置进行响应</li><li>客户端选择“<strong>最近</strong>”的位置并发送请求（chunk句柄，比特范围）</li><li>Chunkserver将请求的数据发送到客户端</li><li>客户端将数据转发给应用程序</li></ol><p>文件写入：</p><ol><li>申请发起请求</li><li>GFS客户端翻译请求并将其发送给master </li><li>Master使用块句柄和副本位置进行响应</li><li>客户端将写入数据推送到所有位置。数据存储在区块服务器的内部缓冲区中。buffer满了就写入到disk。<ul><li>客户可能同时向3个服务器发送数据，也可能使用管道，向最近的服务器发送数据，该服务器再把数据复制到其他服务器。</li></ul></li><li>客户端向primary发送写命令</li><li>Primary确定其缓冲区中数据突变的顺序，并按顺序写入数据块。</li><li>Primary将串行命令发送给Secondary，并告诉它们执行写操作</li><li>Secondary回应primary</li><li>primary回应客户</li></ol><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><p>如果是写入出错，就重写。通过检查checksum跳过不一致的文件区域。</p><p>chunkserver定时要向master报告状态。Master检测到chunkserver出现故障的“心跳”</p><p>如果chunkserver出错：</p><ul><li>Master会减少dead chunkserver上所有区块的副本数。</li><li>Master将丢失副本的块重新复制到其他地方</li></ul><p>特点：</p><ul><li>高可用性<ul><li>快速恢复：master和纯看server可以在几秒内重启</li><li>区块副本：默认情况下为3个副本</li><li>Shadow master</li></ul></li><li>数据完整性：每个chunk中每64KB块就有一个checksum</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>读取可以达到网络上限的75-80%，写入可以达到50%，客户越多带宽越大。</p><p>GFS演示了如何在商品硬件上支持大规模处理工作负载</p><ul><li>容忍频繁的组件故障（故障是常态，而不是例外）</li><li>优化主要附加然后按顺序读取的大型文件</li><li>为许多并发读写器提供高聚合吞吐量</li></ul><p>限制：</p><ul><li>假设一次写入，多次读取</li><li>假设大文件数量适中：large chunk会导致，如果许多客户端访问同一个文件，小文件会在chunkserver上形成热点。</li></ul><h2 id="6-Hadoop-Distributed-File-System"><a href="#6-Hadoop-Distributed-File-System" class="headerlink" title="6. Hadoop Distributed File System"></a>6. Hadoop Distributed File System</h2><h3 id="HDFS-overview"><a href="#HDFS-overview" class="headerlink" title="HDFS overview"></a>HDFS overview</h3><p>HDFS是GFS的<strong>开源</strong>实现，是一种<strong>文件系统</strong>，用于存储具有<strong>流式数据访问模式</strong>的<strong>非常大的文件</strong>，运行在<strong>商用硬件</strong>集群上</p><p>设计假设：</p><ul><li>廉价的商品机器：在大型集群中，错误是常态而不是意外</li><li>“适度”数量的非常大的文件：几百万个大于100MB的文件</li><li>批处理：<ul><li>一次写入，大部分追加（可能同时）</li><li><strong>流式读取</strong>，而不是随机数据访问</li><li><strong>高持续吞吐量</strong>优于低延迟</li></ul></li></ul><p>HDFS的设计和GFS很像：</p><ul><li><p>NameNode：用于管理文件系统元数据的单个主机</p></li><li><p>DataNode (chunkserver)</p><ul><li><p>多个DataNode用于存储和检索数据</p></li><li><p>向NameNode报告托管的块列表</p></li></ul></li><li><p>SecondaryNameNode (shadow master)：执行checkpointing</p></li><li><p>整个集群的单个命名空间</p></li><li><p>数据一致性：写入一次，读取多次</p></li><li><p>文件被分成块：每块<strong>128MB</strong>，每个块在多个数据节点上复制</p></li><li><p>智能客户端：客户端可以找到块的位置；客户端直接从数据节点访问数据</p></li></ul><p>不同点：</p><ul><li>早期版本的每个文件只有一个编写器</li><li>更早的版本不支持记录附加操作</li><li>开源，为不同的文件系统提供了许多接口和库</li></ul><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><ul><li>管理文件系统名称空间<ul><li>将文件名映射到一组块</li><li>将块映射到其所在的数据</li></ul></li><li>节点群集配置</li><li>管理复制引擎用于块</li></ul><p>metadata：存储在内存中，记录了文件列表、每个文件的区块列表、文件属性、每个block在哪些DataNode。</p><p>事务日志：记录文件创建、文件删除等（metadata的前三项）</p><h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><ul><li>在本地文件系统中保存数据</li><li>保存区块的metadata</li><li>向用户提供数据和元数据</li><li>定期向NameNode报告“心跳”</li><li>报告Block report：定期（默认情况下为1小时）向NameNode发送所有现有块的报告</li><li>促进数据的管道化：将数据转发到其他指定的DataNode</li></ul><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>和GFS类似。但是如何选择最近的chunkserver呢？</p><p>不同的racks由Rack switch连接，Rack switch由Aggregation switch连接，形成一个树形结构。</p><ul><li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r1&#x2F;n1) &#x3D; 0 (在同一个节点)</li><li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r1&#x2F;n2) &#x3D; 2 (同一个rack的不同节点)</li><li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r2&#x2F;n3) &#x3D; 4 (同一个数据中心的不同rack)</li><li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d2&#x2F;r3&#x2F;n4) &#x3D; 6 (不同的数据中心)</li></ul><p>区块放置：当前策略（可替换为定制策略）</p><ul><li>本地节点上有一个副本</li><li>同一远程机架的两个节点上有第二个和第三个副本</li><li>随机放置其他副本</li></ul><p>一旦选择了复制副本位置，就会构建一个<strong>管道</strong>。</p><h3 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h3><p>错误处理：每三秒，DataNodes将心跳发送到NameNode。NameNode使用心跳来检测DataNode故障，10分钟内没有响应被视为失败。</p><p><strong>复制引擎</strong>在检测到数据节点故障时，选择一个新的DataNode放置副本，平衡磁盘用量，平衡负载。</p><p>数据纠错：</p><ul><li>验证数据的校验和（CRC32）</li><li>文件创建：客户端计算每512字节的校验和，DataNode保存校验和。</li><li>文件访问：客户端从DataNodes检索数据和校验和，如果验证失败就寻求其他副本。</li></ul><p>NameNode failure：单点故障</p><ul><li>事务日志存储在多个目录中：本地文件系统目录、远程文件系统目录</li><li>加入secondary NameNode<ul><li>非备用&#x2F;备份名称节点：仅用于检查点，具有FSImage的非实时副本</li><li>复制NameNode的FSImage和事务日志，将它们合并到一个新的FSImage</li><li>将新的FSImage上载到NameNode并清除事务日志</li></ul></li></ul><h3 id="限制（不满足）"><a href="#限制（不满足）" class="headerlink" title="限制（不满足）"></a>限制（不满足）</h3><ul><li>低延迟数据访问：数十毫秒范围。HDFS更强调吞吐量而不是延迟</li><li>很多小文件：文件数量很多时，所有元数据都在内存中，发生溢出。</li><li>多个写入者，随机导致文件修改。</li></ul><h3 id="Programming-APIs"><a href="#Programming-APIs" class="headerlink" title="Programming APIs"></a>Programming APIs</h3><p><code>org.apache.hadoop.fs</code></p><h2 id="7-Map-Reduce"><a href="#7-Map-Reduce" class="headerlink" title="7. Map Reduce"></a>7. Map Reduce</h2><p>并行化问题源于</p><ul><li>“工作人员之间的通信（如状态交换）”</li><li>对共享资源（如数据）的访问</li></ul><p>因此，我们需要<strong>同步机制</strong>。</p><ul><li>semaphores（上锁，解锁）</li><li>条件变量（wait, notify, broadcast）</li><li>barriers（一项工作在完成前置条件之前无法开始）</li></ul><p>编程模型：shared memory (pthreads)、message passing (MPI)</p><p>设计模式：master-slaves、producer-consumer flows、shared work queues</p><p>解决典型的大数据问题，涉及5步：</p><ul><li>对大量记录进行迭代</li><li>从每个迭代上提取感兴趣的东西</li><li>对中间结果进行洗牌和排序</li><li>汇总中间结果</li><li>生成最终输出</li></ul><p>其中前2步是Map，后3步是Reduce。</p><p>关键思想：为这两个操作提供一个功能抽象</p><p>函数式编程：函数式操作从不修改现有的数据集，但会创建新的数据集。</p><p><a href="https://imgtu.com/i/bbnnvd"><img src="https://s1.ax1x.com/2022/03/13/bbnnvd.png" alt="bbnnvd.png" style="zoom:50%;" /></a></p><p>如果中间有一个worker出问题了，那么它的计算就要重新进行一次，然后重新fold。</p><p>map函数可以任意，但是fold函数如果是有顺序要求的，那么不同节点的先后完成顺序会影响到结果。</p><p>因此要求fold函数有交换性（Commutativity）和结合性（Associativity）</p><p><strong>MapReduce的编程模型借鉴了函数式编程</strong></p><p>来自数据源的记录作为<strong>键值对</strong>提供</p><ul><li>map (k, v) → [&lt;k2, v2&gt;] </li><li>reduce (k2, [v2]) → [&lt;k3, v3&gt;]</li></ul><p>具有<strong>相同键</strong>的<strong>所有值</strong>都被发送到同一个reducer。执行框架来处理<strong>其他事情</strong></p><p><a href="https://imgtu.com/i/bbu2Y8"><img src="https://s1.ax1x.com/2022/03/13/bbu2Y8.png" alt="bbu2Y8.png" style="zoom:50%;" /></a></p><p>什么是其他事情？</p><ul><li>调度：分配worker、负载均衡</li><li>处理数据分布：将处理器移向数据、自动并行</li><li>处理同步：收集、排序、洗牌中间数据；网络和硬盘传输优化</li><li>处理错误：发现worker失败和重启</li></ul><p>除了Map和Reduce函数，程序员还可以（可选）指定combiner和partitioner</p><p><code>combine (k, [v]) → &lt;k, v&gt;</code><br>mini-reducer，在内存中运行，在map后立刻运行，只处理本次map得到的数据。</p><p><code>partition (k, # of partitions) → partition for k</code><br>为并行reduce操作划分密钥空间。通常是密钥的简单散列，例如<code>hash(k) mod n</code></p><p><strong>Barrier</strong>在map和reduce之间。<br>map都完成了，reduce才能开始。但我们可以更早地开始将中间数据传输到执行map的管道shuffling中。</p><p>Key按照排序顺序到达每个reducer。reducer之间没有强制排序。类似于归并排序，每个reducer内按照key顺序到达和处理，但是互相没有排序关系。 </p><h2 id="8-Hadoop"><a href="#8-Hadoop" class="headerlink" title="8. Hadoop"></a>8. Hadoop</h2><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><ul><li><code>void setup(Mapper.Context context)</code>：任务开始前初始化 </li><li><code>void map(K key, V value, Mapper.Context context)</code>: 对每个键值对调用</li><li><code>void cleanup(Mapper.Context context)</code>: 结束时调用</li></ul><h4 id="Reducer-x2F-Combiner"><a href="#Reducer-x2F-Combiner" class="headerlink" title="Reducer&#x2F;Combiner"></a>Reducer&#x2F;Combiner</h4><ul><li><code>void setup(Reducer.Context context)</code></li><li><code>void reduce(K key, Iterable value, Reducer.Context  context)</code>：每个key调用一次</li><li><code>void cleanup(Reducer.Context context)</code></li></ul><h4 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h4><ul><li><code>int getPartition(K key, V value, int numPartitions)</code></li></ul><h4 id="terminology"><a href="#terminology" class="headerlink" title="terminology"></a>terminology</h4><p>Jobs：</p><ul><li>打包Hadoop程序提交到集群</li><li>需要指定输入和输出路径</li><li>需要指定输入和输出格式</li><li>需要指定映射器、还原器、组合器、分区器</li><li>需要指定中间&#x2F;最终键&#x2F;值类</li><li>需要指定还原器的数量（但不是映射器，为什么？）</li></ul><p>Task：在数据片上执行Map或Reduce，也称为Task-In-Progress（TIP）</p><p>Task attempt：试图在机器上执行任务的特定实例。某个特定任务将至少尝试一次，如果崩溃，可能会尝试更多次。</p><h4 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h4><p>Writable -&gt; WritableComparable -&gt; IntWritable&#x2F;LongWritable&#x2F;Text</p><ul><li>Writable：定义反序列化&#x2F;序列化协议。Hadoop中的每种数据类型都是Writable。<br>如同java中<code>Object</code>是最原始的基类，<code>Writable</code>是Hadoop中的原始类。</li><li>WritableComparable ：定义排序顺序。所有键都必须是这种类型（但不是值）。</li><li>IntWritable等：不同数据类型的具体类。</li><li>SequenceFile：键值对序列的二进制编码。Java自带的序列化太重了，Hadoop自己用了轻量的。</li></ul><p>技巧：</p><ul><li>尽可能避免对象创建——重用可写对象，更改有效负载</li><li>执行框架重用reducer中的值对象</li><li>通过类静态传递参数</li></ul><p>如果遇到复杂数据类型，需要想办法用Hadoop支持的类型来表示，或者自己实现Writable接口。</p><h2 id="Anatomy-of-Hadoop"><a href="#Anatomy-of-Hadoop" class="headerlink" title="Anatomy of Hadoop"></a>Anatomy of Hadoop</h2><p>基本概念</p><p>每个cluster：</p><ul><li>NameNode：HDFS的master节点</li><li>JobTracker：作业提交的master节点</li></ul><p>每个从属机器需要设定：</p><ul><li>DataNode：作为HDFS的数据块</li><li>TaskTracker：包含多个任务曹</li></ul><p>Hadoop&#x3D;HDFS+MapReduce</p><p>Hadoop有自己的RPC协议。</p><p>所有的交流都由slave发起：避免循环等待的死锁；slave周期性报告状态</p><p>所有的类都要提供显式的序列化方法，所以Hadoop数据类型必须继承自<code>Writable</code>。</p><p>Master节点运行JobTracker实例，接收client的作业申请。</p><p>Slave节点运行TaskTracker实例，分配java进程给任务。</p><p>Hadoop中的MapReduce程序 &#x3D; Hadoop作业</p><p>作业被分为了map任务和reduce任务，多个任务可以整合为workflow。</p><p>作业提交：</p><ul><li>client创建作业，配置，提交到JobTracker。作业是jar文件和XML文件，包含序列化的程序配置选项。</li></ul><p>运行MapReduce作业：</p><ul><li>将jar和XML文件放入HDFS</li><li>通知TaskTracker从何处检索相关程序代码</li></ul><p>计算Input splits<br>JobTracker将作业数据放在HDFS的共享位置，排队<br>TaskTrackers轮询任务。</p><h4 id="Hadoop-IO"><a href="#Hadoop-IO" class="headerlink" title="Hadoop IO"></a>Hadoop IO</h4><p>输入格式：按行输入，键值对形式，序列化文件</p><p>输出格式：键值对，序列化文件</p><h4 id="Shuffle-和sort"><a href="#Shuffle-和sort" class="headerlink" title="Shuffle 和sort"></a>Shuffle 和sort</h4><p>Map</p><ul><li>映射输出缓冲在循环缓冲区中的内存中</li><li>当缓冲区达到阈值时，内容溢出到磁盘</li><li>溢出合并到单个分区文件中（在每个分区内排序）：合并器在合并期间运行</li></ul><p>Reduce</p><ul><li>映射输出被复制到reducer机器上</li><li>“sort”是映射输出的多次合并（发生在内存和磁盘上）：合并器在合并过程中运行</li><li>最终的合并过程直接进入reducer</li></ul><h2 id="9-MapReduce-Algorithm-Design"><a href="#9-MapReduce-Algorithm-Design" class="headerlink" title="9. MapReduce Algorithm Design"></a>9. MapReduce Algorithm Design</h2><p>框架负责：</p><ul><li>调度任务，分配worker去做map和reduce任务</li><li>数据分发</li><li>同步：收集、排序、洗牌</li><li>发现和处理错误</li></ul><p>程序员只用写mrcp四个函数，无法控制mapper和reducer</p><p>但是可以：</p><ul><li>选择合适的数据类型</li><li>中间值key的排序顺序</li><li>Partitioner：哪个reducer进程处理哪个key</li><li>保存mapper和reducer的状态</li></ul><p><a href="https://imgtu.com/i/qkkGK1"><img src="https://s1.ax1x.com/2022/03/18/qkkGK1.png" alt="qkkGK1.png" style="zoom:50%;" /></a></p><p>如何让Hadoop算法可伸缩</p><ul><li>避免创建对象：昂贵的操作，垃圾回收影响效率</li><li>避免缓存：堆空间有限；用于小数据集</li></ul><p>理想状态：运行时间和数据量成正比，和资源量成反比<br>为什么达不到：shuffle和sort需要同步机制，同步要求交流，交流影响性能</p><p>因此，要尽量避免交流</p><ul><li>在本地reduce中间数据</li><li>combiner帮忙（可选，不一定会用）</li></ul><p><a href="https://imgtu.com/i/qkEQXR"><img src="https://s1.ax1x.com/2022/03/18/qkEQXR.png" alt="qkEQXR.png" style="zoom:50%;" /></a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/other/interview/"/>
    <url>/other/interview/</url>
    
    <content type="html"><![CDATA[<p>用来记录我面试过程中遇到的问题</p><h3 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h3><ul><li>http 2.0</li><li>TCP的状态</li><li>分布式系统如何解决一致性</li></ul><h3 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h3><h4 id="IO多路复用是为了解决什么问题"><a href="#IO多路复用是为了解决什么问题" class="headerlink" title="IO多路复用是为了解决什么问题"></a>IO多路复用是为了解决什么问题</h4><p>传统的多进程并发模型 ：每进来一个新的I&#x2F;O流会分配一个新的进程管理。</p><p>但是这样不适合高并发的场景，因此引入多路IO复用：用单个线程，同时记录跟踪多个I&#x2F;O流(sock)的状态，来同时管理多个I&#x2F;O流。每个IO流（socket）就是一个客户连接。</p><table><thead><tr><th align="left"></th><th align="left">select</th><th align="left">poll</th><th>epoll</th></tr></thead><tbody><tr><td align="left">数据结构</td><td align="left">bitmap</td><td align="left">数组</td><td>红黑树</td></tr><tr><td align="left">最大连接数</td><td align="left">1024</td><td align="left">无上限</td><td>无上限</td></tr><tr><td align="left">fd拷贝</td><td align="left">每次调用select拷贝</td><td align="left">每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td align="left">工作效率</td><td align="left">轮询：O(n)</td><td align="left">轮询：O(n)</td><td>回调：O(1)</td></tr></tbody></table><h4 id="堆和栈："><a href="#堆和栈：" class="headerlink" title="堆和栈："></a>堆和栈：</h4><ul><li>栈：分配专门的寄存器存放栈的地址，压栈和出栈都有专门的指令执行；编译时决定大小；有OS控制</li><li>堆：由C&#x2F;C++库函数实现，由算法寻找足够大的内存空间，需要调用函数；运行时决定；由程序员控制</li><li>栈直接访问数据；堆先获得指针，再访问数据</li><li>栈被换出内存可能性比堆大</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图" style="zoom: 80%;" /><p>使用时，<code>getShape()</code>根据获得的参数来决定生成Circle、Square还是Rectangle，但一定是满足Shape接口的。</p><h3 id="3-20"><a href="#3-20" class="headerlink" title="3.20"></a>3.20</h3><h4 id="MVCC如何实现的"><a href="#MVCC如何实现的" class="headerlink" title="MVCC如何实现的"></a>MVCC如何实现的</h4><p>InnoDB用事务版本号，行记录中的隐藏列和Undo Log实现。</p><ul><li><strong>事务版本号</strong>：每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。</li><li><strong>行记录的隐藏列</strong><ul><li>row_id :隐藏的行 ID ,用来生成默认的聚集索引。</li><li>trx_id: 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。</li><li>roll_ptr:回滚指针，指向这个记录的 Undo Log 信息。</li></ul></li><li><strong>Undo Log</strong>：数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找。</li></ul><h4 id="数据原子性"><a href="#数据原子性" class="headerlink" title="数据原子性"></a>数据原子性</h4><p>主要是利用 Innodb 的<strong>undo log</strong>。 <strong>undo log</strong>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。</p><h4 id="数据持久性"><a href="#数据持久性" class="headerlink" title="数据持久性"></a>数据持久性</h4><p>主要是利用Innodb的<strong>redo log</strong>。当做数据修改的时候，不仅在内存中操作，还会在<strong>redo log</strong>中记录这次操作。当事务提交的时候，会将<strong>redo log</strong>日志进行刷盘(<strong>redo log</strong>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据<strong>undo log</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</p><h4 id="采用redo-log的好处？"><a href="#采用redo-log的好处？" class="headerlink" title="采用redo log的好处？"></a>采用redo log的好处？</h4><p>其实好处就是将<strong>redo log</strong>进行刷盘比对数据页刷盘效率高，具体表现如下：</p><ul><li><strong>redo log</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li><li><strong>redo log</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li></ul><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>MySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，它记录了所有的 <strong>DDL</strong> 和 <strong>DML</strong> 语句（除了数据查询语句select、show等），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是<strong>复制</strong>和恢复。</p><p>Binlog日志的两个最重要的使用场景</p><ul><li>MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的</li><li>数据恢复：通过使用 mysqlbinlog工具来使恢复数据</li></ul><h3 id="3-21"><a href="#3-21" class="headerlink" title="3.21"></a>3.21</h3><ul><li>C&#x2F;C++各自的字符串操作</li></ul><h4 id="文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出"><a href="#文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出" class="headerlink" title="文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出"></a>文件读取的流程，读进来后在OS内存还是进程内存，如果内存不够了怎么换出</h4><p>目前的理解是，先读入内核缓冲区，再读入用户缓冲区。进程发起read的请求，但是用户态无法直接IO，需要切换到内核态。OS不会马上相应IO，而是可能加入队列，一定时间后统一从磁盘读取，先读取到内核缓冲区，用户进程再从内核中获取。</p><h4 id="HTTP，TCP协议的头部内容"><a href="#HTTP，TCP协议的头部内容" class="headerlink" title="HTTP，TCP协议的头部内容"></a>HTTP，TCP协议的头部内容</h4><p><a href="https://imgtu.com/i/qOJkkR"><img src="https://s1.ax1x.com/2022/04/05/qOJkkR.png" alt="qOJkkR.png"></a></p><p><a href="https://imgtu.com/i/qOJe1K"><img src="https://s1.ax1x.com/2022/04/05/qOJe1K.png" alt="qOJe1K.png" style="zoom: 80%;" /></a></p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程 (runoob.com)</a></p><h4 id="TCP状态图"><a href="#TCP状态图" class="headerlink" title="TCP状态图"></a>TCP状态图</h4><p><a href="https://imgtu.com/i/qOJKne"><img src="https://s1.ax1x.com/2022/04/05/qOJKne.png" alt="qOJKne.png"></a></p><h3 id="3-24"><a href="#3-24" class="headerlink" title="3.24"></a>3.24</h3><h4 id="用UDP在应用层面实现可靠：RDT"><a href="#用UDP在应用层面实现可靠：RDT" class="headerlink" title="用UDP在应用层面实现可靠：RDT"></a>用UDP在应用层面实现可靠：RDT</h4><ul><li>RDT1.0：建立在理想可靠信道上，发送和接收方都只有等待调用状态</li><li>RDT2.0：考虑了翻转错误，发送方增加了等待ACK或NAK状态。</li><li>RDT2.1：考虑了ACK或NAK出错出错的情况。简单重传会导致重复分组，因此引入序列号，发送方給每个分组增加序列号，接收方丢弃重复分组。序列号目前可以只为0或1，说明每次只发送一个包。</li><li>RDT2.2：取消NAK，在ACK中显式加入被确认分组的序列号，这样重复的ACK即代表NAK。</li><li>RDT3.0：考虑了丢失分组，因此加入超时重传。如果ACK只是延迟了也无妨，因为接收端收到了重复的分组会自动丢弃。收到重复ack会忽略，因为包可能还在路上，所以只用管计时器。</li></ul><h4 id="unique-ptr如何转交，移动语义和右值引用"><a href="#unique-ptr如何转交，移动语义和右值引用" class="headerlink" title="unique_ptr如何转交，移动语义和右值引用"></a>unique_ptr如何转交，移动语义和右值引用</h4><p><code>unique_ptr</code>无法复制，但是可以转移所有权，使用移动语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>std::unique_ptr&lt;T&gt; p2 = std::<span class="hljs-built_in">move</span>(p1);<br></code></pre></td></tr></table></figure><h3 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h3><h4 id="几种O-N-2-的的排序"><a href="#几种O-N-2-的的排序" class="headerlink" title="几种O(N^2)的的排序"></a>几种O(N^2)的的排序</h4><ul><li>选择排序：每次选择较小的元素放在数组前部<ul><li>没有最坏情况</li></ul></li><li>冒泡排序：通过不断地交换，将较大的数交换到数组末尾。<ul><li>原本逆序时情况最坏</li></ul></li><li>插入排序：数组从左到右扩大有序的范围，将新遍历到的元素插入到有序部分并保持有序，后续元素向后平移</li><li>希尔排序：优化插入排序，先分组排序，这样总体上看“基本有序”，再将整个数组排序。可以有效减少需要向后平移元素的个数。</li></ul><h4 id="Linux脚本编程"><a href="#Linux脚本编程" class="headerlink" title="Linux脚本编程"></a>Linux脚本编程</h4><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><h4 id="协程和进程区别"><a href="#协程和进程区别" class="headerlink" title="协程和进程区别"></a>协程和进程区别</h4><ul><li>创建线程需要OS，程序本身没法创建线程，但是可以创建协程。因为不需要进入内核态创建，因此协程也称为<strong>用户态线程</strong>。</li><li>一个程序有一个主线程，可以管理多个协程。</li><li>线程可以真正的<strong>并行</strong>执行，但是线程只能在线程的基础上<strong>并发</strong>执行。因此才说<strong>线程是程序执行的基本单位</strong>。</li><li>协程适合IO密集的程序。</li></ul><h4 id="core，越界错误，如何检测"><a href="#core，越界错误，如何检测" class="headerlink" title="core，越界错误，如何检测"></a>core，越界错误，如何检测</h4><p>Linux下C程序常常会因为内存访问错误等原因造成segment fault（段错误），此时如果系统core dump功能是打开的，那么将会有内存映像转储到硬盘上来，之后可以用gdb对core文件进行分析，还原系统发生段错误时刻的堆栈情况。这对于我们发现程序bug很有帮助。</p><h4 id="Go中数组和切片的区别"><a href="#Go中数组和切片的区别" class="headerlink" title="Go中数组和切片的区别"></a>Go中数组和切片的区别</h4><p>其实类似于vector和vector内部的data的区别。</p><p>Go中的数组时一种类型，包含了数据类型和长度，一旦定以后就不能更改长度。类似于C++中<code>new</code>一个数组就需要指定类型和大小。</p><p>切片就类似于<code>vector</code>，是对数组的<strong>引用</strong>，自身只保存了大小、容量、引用的数组。</p><h3 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h3><h4 id="STL-sort"><a href="#STL-sort" class="headerlink" title="STL sort"></a>STL sort</h4><p><a href="https://imgtu.com/i/Lkqhrt"><img src="https://s1.ax1x.com/2022/04/10/Lkqhrt.png" alt="Lkqhrt.png" style="zoom: 33%;" /></a></p><h4 id="智能指针是线程安全的吗"><a href="#智能指针是线程安全的吗" class="headerlink" title="智能指针是线程安全的吗"></a>智能指针是线程安全的吗</h4><p>shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><h4 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h4><p>用户在浏览网站、使用<a href="https://baike.baidu.com/item/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E8%BD%AF%E4%BB%B6">即时通讯软件</a>、甚至在阅读电子邮件时，通常会点击其中的链接。攻击者通过在链接中插入<a href="https://baike.baidu.com/item/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81">恶意代码</a>，就能够盗取用户信息。</p><h4 id="跨域？"><a href="#跨域？" class="headerlink" title="跨域？"></a>跨域？</h4><p>简单来说，就是我在一个站点向另一个站点发送了请求（<a href="https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020">ajax</a>或者链接），只要这两个站点HTTP协议、域名或是端口中有一个不一样，说明发送了跨域。</p><h4 id="跨域请求伪造"><a href="#跨域请求伪造" class="headerlink" title="跨域请求伪造"></a>跨域请求伪造</h4><p>CSRF（Cross Site Request Forgery），跨域请求伪造，即是恶意网站引诱用户点击，或直接将恶意代码植入到正常网站中，伪造用户向正常网站的服务器发送伪造的请求。由于请求是从用户的浏览器发出，便能自动带上用户的cookie发送到服务器。</p><h3 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h3><h4 id="validate关键词"><a href="#validate关键词" class="headerlink" title="validate关键词"></a>validate关键词</h4><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><h4 id="智能指针，循环引用"><a href="#智能指针，循环引用" class="headerlink" title="智能指针，循环引用"></a>智能指针，循环引用</h4><p>两个shared_ptr</p><p>一般来讲，解除这种循环引用有下面有三种可行的方法(参考)：</p><ol><li>当只剩下最后一个引用的时候需要手动打破循环引用释放对象。</li><li>当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。</li><li>使用弱引用的智能指针打破这种循环引用。<br>虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。我们一般使用第三种方法：弱引用的智能指针weak_ptr。</li></ol><h4 id="struct内存对齐"><a href="#struct内存对齐" class="headerlink" title="struct内存对齐"></a>struct内存对齐</h4><ol><li>结构体变量的<strong>起始地址</strong>能够被其最宽的成员大小整除</li><li><a href="https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:208895189%7D">结构体</a>每个成员相对于<strong>起始地址的偏移</strong>能够被其<strong>自身大小整除</strong>，如果不能则在<strong>前一个成员后面</strong>补充字节</li><li>结构体总体大小能够<strong>被最宽的成员的大小</strong>整除，如不能则在<strong>后面</strong>补充字节</li></ol><h3 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h3><h4 id="子类和父类的构造和析构顺序"><a href="#子类和父类的构造和析构顺序" class="headerlink" title="子类和父类的构造和析构顺序"></a>子类和父类的构造和析构顺序</h4><p>由于子类包含了父类的功能和属性，不妨将父类看做子类的一个成员，子类依赖于父类，子类是在父类的基础上加上了自己的独有部分。这样看来，构造时一定是从下到上，先构造被依赖的父类，再构造子类。析构时则相反。</p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>平均周转时间表示，所有进程完成任务所花的所有时间除以进程的个数。因此周转时间要算上进程<strong>等待</strong>时间加上<strong>运行</strong>时间。</p><h4 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h4><p>装填因子：a&#x3D;n&#x2F;m  其中n为key个数，m为表长。</p><p>加载因子是表示Hsah表中元素的填满的程度。</p><h4 id="筛选法建堆"><a href="#筛选法建堆" class="headerlink" title="筛选法建堆"></a>筛选法建堆</h4><p>建堆有两种方式：</p><ol><li>插入法：O(NlogN)，是比较熟知的方法，适用于事先不知道元素的个数，可以动态建堆。具体方法为以一个完全二叉树为堆（可以用数组代替），每次新元素加入二叉树的末尾（不破坏完全二叉树），然后与父节点比较进行上浮。</li><li>筛选法：O(N)，适用于元素已知的情况。从下往上，从左往右的第一个非叶子节点（其实就是数组的<code>a[a.size / 2 - 1]</code>）开始，从下往上遍历（从<code>a[a.size / 2 - 1]</code>到<code>a[0]</code>）,维护该节点为堆的根节点。</li></ol><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为<code>最优二叉树</code>，也称为<code>哈夫曼树(Huffman Tree)</code>。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>构造方法：</p><ol><li>起初每个节点看做一个单节点的树，然后全部放入优先队列，按照根节点的权重从小到大。</li><li>每次取出最小的两个，作为左右子节点，求出的和为父节点，重写加入优先队列。</li><li>重复上述过程直至队列只剩一个节点。</li></ol><p><strong>霍夫曼编码</strong>也是类似的原理。字符出现的频率作为权重</p><h4 id="双路归并"><a href="#双路归并" class="headerlink" title="双路归并"></a>双路归并</h4><p>类似于力扣题：合并两个有序链表</p><h3 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h3><h4 id="红黑树比其他平衡二叉搜索树优越在哪里？"><a href="#红黑树比其他平衡二叉搜索树优越在哪里？" class="headerlink" title="红黑树比其他平衡二叉搜索树优越在哪里？"></a>红黑树比其他平衡二叉搜索树优越在哪里？</h4><p>AVL树高度更低，查询性能更好，但是删除性能差（不稳定）</p><p>红黑树牺牲了平衡性，以及用染色的方式，尽量减少旋转操作。</p><h4 id="B-树与B树"><a href="#B-树与B树" class="headerlink" title="B+树与B树"></a>B+树与B树</h4><p>B树规则：</p><ol><li>每个内部节点有n个关键码，就不能超过n+1个分支。将上限设为m，也称就是<strong>B树的阶次</strong>。那么下限不能少于m&#x2F;2，注意是<strong>向上取整</strong>，因此可以理解为<code>(m+1)/2</code>。由此，不同结构的B树可以用分支的上下限来区分，比如与红黑树有关的<strong>（2,4）树</strong>。</li><li>所有叶节点在同一层</li></ol><p>对于B树而言，高度是对于外部节点，而不是叶节点。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找的细节问题</title>
    <link href="/algorithm/binary-search/"/>
    <url>/algorithm/binary-search/</url>
    
    <content type="html"><![CDATA[<p>二分查找的思路其实很好理解，但是细节很坑。到底要给 <code>mid</code> 加一还是减一，<code>while</code> 到底用<code>&lt;=</code>还是<code>&lt;</code>，这些都会对二分查找的效果有细微的影响。</p><p>二分查找总体上有几个应用：</p><ol><li>寻找一个数</li><li>寻找一个数第一次出现的位置（左边界）</li><li>寻找一个数最后一次出现的位置（右边界）</li></ol><h1 id="基础版本：寻找一个数"><a href="#基础版本：寻找一个数" class="headerlink" title="基础版本：寻找一个数"></a>基础版本：寻找一个数</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//细节点</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<span class="hljs-comment">//细节点</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//细节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//细节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是最基础的版本：寻找一个数，如果存在则返回下标；不存在则返回-1。</p><h2 id="while应该是-lt-还是-lt"><a href="#while应该是-lt-还是-lt" class="headerlink" title="while应该是&lt;=还是&lt;"></a>while应该是<code>&lt;=</code>还是<code>&lt;</code></h2><p>将<code>right</code>初始化为<code>nums.size()-1</code>，说明<code>right</code>的含义是数组的最后一个元素的索引，而不是数组长度或者尾后元素。<strong>我们先按照<code>nums.size()-1</code>来讨论</strong>。</p><ul><li>如果使用<code>&lt;=</code>，那么说明每次搜索的区间是<code>[left, right]</code>，注意是左闭右闭区间。</li><li>如果使用<code>&lt;</code>，那么说明每次搜索的区间是<code>[left, right)</code>，注意是左闭右开区间。</li></ul><p>终止搜索的条件为：</p><ul><li>找到目标值：<code>if(nums[mid] == target)</code></li><li>搜索区间为空<ul><li>对于<code>left &lt;= right</code>：终止条件是<code>left == right + 1</code>，用区间表达为<code>[right + 1, right]</code>。这个区间显然是为空的。</li><li>对于<code>left &lt; right</code>：终止条件是<code>left == right</code>，用区间表达为<code>[right, right]</code>。这个区间其实是不为空的<code>left</code>或者<code>right</code>本身是合法。如果退出了循环，相当于该索引<strong>没有被检查</strong>。</li></ul></li></ul><p>那么结论很明显了，如果定义了<code>right = nums.size() - 1</code>，那么应该搭配<code>while(left &lt;= right)</code>。</p><p>如果非要用<code>while(left &lt;= right)</code>，那么就应该把漏掉了<code>left == right</code>情况给<strong>特判</strong>。注意，由于需要访问<code>nums[left]</code>所以还要加入对<code>nums</code>为空的特判。但是额外两处特判多少让人觉得有人不自然。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">if(nums.empty())return -1;<br>while(left &lt; right) &#123;<br>    // ...<br>&#125;<br>return nums[left] == target ? left : -1;<br></code></pre></td></tr></table></figure><h2 id="左闭右开的版本"><a href="#左闭右开的版本" class="headerlink" title="左闭右开的版本"></a>左闭右开的版本</h2><p>如果定义<code>right = nums.size()</code>，那么搜索的起始区间是<code>[0, nums.size)</code>，与之搭配的应该是<code>while(left &lt; right)</code>，正如上面所说。</p><p>需要注意的点是<code>if(nums[mid] &gt; target) right = mid;</code>。因为<code>right</code>是闭区间，本身就是无法访问的，如果让<code>right = mid - 1</code>，相当于不仅判断<code>mid</code>不满足，也认为<code>mid - 1</code>不满足，相当于多跳过了一个点。</p><p>代码如下，和最初版差不多简洁。很合理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//细节点</span><br><span class="hljs-keyword">while</span>(left &lt; right) &#123;<span class="hljs-comment">//细节点</span><br>    <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] == target)<br>        <span class="hljs-keyword">return</span> mid; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//细节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>right = mid;<span class="hljs-comment">//细节点</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><h1 id="寻找一个数第一次出现的位置（左边界）"><a href="#寻找一个数第一次出现的位置（左边界）" class="headerlink" title="寻找一个数第一次出现的位置（左边界）"></a>寻找一个数第一次出现的位置（左边界）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//细节点</span><br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;<span class="hljs-comment">//细节点</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            right = mid;<span class="hljs-comment">//这样才能用上二分的性质</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid;<span class="hljs-comment">//细节点</span><br>    &#125;<br>    <span class="hljs-comment">// 如果没有找到</span><br>    <span class="hljs-keyword">if</span>(left &gt;= nums.<span class="hljs-built_in">size</span>() || nums[left] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先展示左闭右开的写法，<code>right = nums.size()</code>，<code> while(left &lt; right)</code>，<code>right = mid;</code></p><p>注意，最后返回<code>left</code>或<code>right</code>是一样的，因为终止条件是<code>left == right</code>。</p><h1 id="寻找一个数最后一次出现的位置（右边界）"><a href="#寻找一个数最后一次出现的位置（右边界）" class="headerlink" title="寻找一个数最后一次出现的位置（右边界）"></a>寻找一个数最后一次出现的位置（右边界）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || nums[left<span class="hljs-number">-1</span>] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与左边界类似的，寻找右边界时，即使找到target了也要<code>left = mid + 1;</code>。由于<code>mid = left - 1</code>，因此最后返回的是<code>left - 1 </code>，除非寻找的是数组中第一个比target大的数。</p><h1 id="最终记忆版本（板子）"><a href="#最终记忆版本（板子）" class="headerlink" title="最终记忆版本（板子）"></a>最终记忆版本（板子）</h1><p>统一采用左闭右闭的形式，即<code>right = nums.size() - 1</code>，<code> while(left &lt;= right)</code>，<code>right = mid - 1;</code>,<code>left = mid + 1;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//right == left - 1</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链学习笔记</title>
    <link href="/college/blobkchain/"/>
    <url>/college/blobkchain/</url>
    
    <content type="html"><![CDATA[<p>为了开展我的个人项目，第一周的任务是学习区块链的背景知识，了解zkSync的basic idea。</p><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><p>区块链是站在巨人的肩膀上的：</p><ul><li>1982年，David Chaum提出了注重隐私安全的密码学网络支付系统</li><li>1985年，Neal Koblitz和Victor Miller各自独立提出著名的椭圆曲线加密算法</li><li>1991年，Stuart Haber和W. Scott Stornetta提出用时间戳确保数位文件安全的协议</li><li>1997年，Adam Back发明了Hashcash（哈希现金），采用工作量证明演算法（PoW）</li><li>1998年，Wei Dai发表了匿名的分散式电子现金系统B-money</li><li>2001年，NSA发布SHA-2系列算法，其中包括比特币最终采用的SHA-256哈希算法</li></ul><p>至此，区块链技术依赖的所有技术基础都具备了</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><ul><li>RSA：基于大整数分解</li><li>ECC：基于椭圆曲线</li></ul><p>区块链中常用算法是ECC，因为它更难破解。破解228比特的RSA密钥需要的能量可以煮沸一茶匙的水，而破解228比特的ECC密钥需要的能量能煮沸地球上所有的水。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>应用于梅克尔树、区块指针、挖矿</p><p>主要的哈希函数有：</p><ul><li>MD4&#x2F;MD5（已被攻破）</li><li>SHA家族：SHA-1（已被攻破）、SHA-256（比特币）、SHA-384、SHA-512</li></ul><p>在比特币的系统中，除了公钥和私钥外，由于公钥本身还是太复杂了，因此会对公钥使用哈希函数，生成一个<strong>比特币地址</strong>，通过这个地址来进行交易。</p><p><img src="https://s4.ax1x.com/2022/03/02/b8Y1Fx.jpg" alt="b8Y1Fx.jpg"></p><h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><p>拜占庭将军问题：一组拜占庭将军分贝率军围困一座易守难攻的城池。他们的行动只有进攻或撤退，并且他们必须行动一致，否则会损失惨重。他们会通过信使来互相联系，将自己的信息告知给其他将军。每个将军通过自己收到的信息来决定进攻还是撤退。</p><p>在是个分布式系统里的模型，可以用来归纳共识机制面临的问题：</p><ul><li>信使送信太慢：延时</li><li>信使被中途截杀：信息丢失</li><li>将军阵亡：服务器宕机</li><li>叛变、发送假消息、伪造他人信件：攻击者</li><li>策反：贿赂其他节点，发动合谋攻击</li></ul><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p> 根据这个模型，可以按照<strong>安全等级</strong>分出三种安全模型：</p><ul><li><p><strong>非拜占庭容错模型</strong>：没有攻击者，所有节点都安全可靠</p><p>错误类型：消息丢失、重复、延时；服务器宕机、通信协议不可靠</p></li><li><p><strong>拜占庭容错模型</strong>：存在攻击者，节点之间互不可信</p><p>错误类型：非拜占庭容错；攻击者篡改消息内容</p></li><li><p><strong>经济模型</strong>：存在有经济实力的攻击者</p><p>攻击类型：大量购买硬件资源试图攻击；贿赂其他节点发动合谋攻击</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>根据FLP定理和CAP定理，在一个异步的分布式系统中无法达成强一致性。那么有哪些解决方案呢？</p><ul><li>非拜占庭容错：适用于分布式数据库<ul><li>共识机制：Paxos、Raft等</li><li>性能较高，容错性较差</li></ul></li><li>拜占庭容错：适用于分布式账本（区块链）<ul><li>共识机制：PoW、PoS、DPos、PBFT</li><li>容错性较高，性能较差</li><li>设计思路：<ul><li>提高作恶的成本，降低错误出现的概率</li><li>在允许一定恶意节点存在的前提下，依旧实现账本一致</li></ul></li></ul></li></ul><h4 id="实用拜占庭容错算法"><a href="#实用拜占庭容错算法" class="headerlink" title="实用拜占庭容错算法"></a>实用拜占庭容错算法</h4><p>PBFT是目前解决拜占庭容错问题最高的方法，将原有的指数级降到多项式级。</p><p>可以容忍少于1&#x2F;3的节点作恶，而且参与的节点越多，作恶难度越大，性能越差。</p><p>适用于有强一致性要求的联盟链、私有链，或者节点数量固定的公有链，如DPOS公链。以为算法要求每次产生新区块，其他所有的区块必须在规定时间内给出反馈，如果超过2&#x2F;3节点都认可，那么就达成强一致，这个区块就再也无法改动了。</p><h3 id="比特币类共识机制的特点"><a href="#比特币类共识机制的特点" class="headerlink" title="比特币类共识机制的特点"></a>比特币类共识机制的特点</h3><ul><li><p><strong>随机性</strong></p><p>记账者们解决数学谜题，竞争记账权的过程，可以看做随机选择的过程。由于比特币的一笔交易一般需要6个区块才能最终确认，而作恶者被随机选中6次的概率是很低的。</p><p>但是，随机性想要生效，前提是选择是真随机，或者至少不能被预测或者操控。如果作恶者能掌握大部分的节点或者算力，那么还是可以作恶。</p></li><li><p><strong>抗女巫攻击</strong>：如何抵御通过刷小号方式来提高被选中概率的作恶手法。</p><p>大致思路为提高创建账号或者加入共识需要的成本。挖矿就是一种工作量的门槛，光有小号没有算力是无法作恶的。或者就是对资源设置门槛，也就是使用权益证明。</p></li><li><p><strong>激励机制</strong></p><p>奖励诚实的参与者，惩罚作恶者的反激励机制。</p></li></ul><h4 id="工作量证明（PoW）"><a href="#工作量证明（PoW）" class="headerlink" title="工作量证明（PoW）"></a>工作量证明（PoW）</h4><p>挖矿的谜题就像个模仿，解密很苦难，但是结果是否正确很容易检验。</p><p>至于难度目标到底是多少，则是由比特币的程序每隔2016个区块就自动调节一次的，根据之前出块速度和之前难度目标反推全网算力，再根据全网算力设置一个合适的难度目标，让全网平均<strong>10分钟</strong>能出一个块。这样一来，**谁的计算能力强，谁在单位时间内计算次数多，谁就有更大的概率试出符合要求的哈希值，获得记账权和比特币奖励，这种共识机制也被称为工作量证明(PoW)**。</p><h4 id="权益证明（POS）"><a href="#权益证明（POS）" class="headerlink" title="权益证明（POS）"></a>权益证明（POS）</h4><ul><li><p>PoW：拥有算力越大，出块概率越大</p></li><li><p>PoS：锁定的代币越多，出块概率越大</p></li></ul><p>抗女巫攻击：通过资源门槛来，因为创建再多的小号，作恶者拥有的代币总量是不变的。</p><p>随机性：通过VDF、VRF等函数生成随机数。</p><p>激励机制：挖出区块的奖励；手续费</p><p>以太坊目前还在采用PoW，但是在2.0版本会采用PoS。</p><h4 id="授权权益证明（DPOS）"><a href="#授权权益证明（DPOS）" class="headerlink" title="授权权益证明（DPOS）"></a>授权权益证明（DPOS）</h4><ul><li><p>PoS：用代币给区块投票</p></li><li><p>DPoS：用代币给节点投票</p></li></ul><p>持币者通过锁定代币获得一定投票权，投票给节点候选人，得票排名靠的节点代为行使出块权利，轮流出块。</p><p>优势：</p><ul><li>让专业的人来做专业的事，网络增加安全稳定，并且不是所有的个人用户都愿意承担记账的义务</li><li>控制记账者的数量，大大降低了达成共识需要的节点数，可以极大提高性能，加快达成共识的速度（每笔交易确认的速度）</li></ul><p>劣势：去中心化程度低</p><h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><p>Bit Coin，代号（BTC），于2008年以论文形式发布，2009年创世区块诞生。</p><p>定位是一种<strong>点对点的电子现金系统</strong>，可以消除目前线上交易对<strong>可信第三方</strong>的依赖。</p><h2 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h2><ul><li>每10分钟左右会产生一个新的区块，<strong>一定数量</strong>的比特币会奖励给创建者。</li><li>奖励数量<strong>每4年减半1次</strong>，最初创建一区块奖励50btc。产生到21万个区块后降为25btc，后面一次对半递减。</li><li>比特币的上限约为<strong>2100万</strong>个，预计<strong>2140</strong>年左右全部挖出。目前已经挖出近<strong>1800万</strong>个。</li></ul><h3 id="区块链和比特币之间的关系"><a href="#区块链和比特币之间的关系" class="headerlink" title="区块链和比特币之间的关系"></a>区块链和比特币之间的关系</h3><p>区块链是支持比特币作为一款应用的底层技术，提供了<strong>分布式账本技术</strong>，解决了交易各方的<strong>信任问题</strong>。</p><h2 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h2><p>假设有交易双方发生了交易，他们会将这比交易的信息全网广播，使分布式账本的状态发生改变。</p><p>记账者负责记录一段时间内的<strong>交易信息</strong>，一起参与交易的双方<strong>账户状态</strong>，并打包到一个区块中。由于大约每10分钟产生一个新区块，所以可以看做每一个区块就是<strong>一页账单</strong>，记录了这10分钟内发生的交易。区块按照<strong>时间顺序</strong>串联，上一个区块的结尾时的状态紧接着下一个区块开头的状态，就形成了<strong>区块链</strong>。</p><h3 id="账户体系"><a href="#账户体系" class="headerlink" title="账户体系"></a>账户体系</h3><p>比特币采用<strong>非对称加密</strong>，公钥作为<strong>账号</strong>，私钥作为<strong>密码</strong>。</p><p>随机生成私钥，通过数学加密曲线（如椭圆加密曲线）生成公钥。知道公钥<strong>难以</strong>计算出私钥。</p><h3 id="交易发出"><a href="#交易发出" class="headerlink" title="交易发出"></a>交易发出</h3><p>假设A要给B转账，那么A需要：</p><ul><li>一个交易单，内容包括：付款人A，收款人B，比特币数量，来源（A的余额）。</li><li>A对交易单进行<strong>数字签名</strong></li><li>B用A的公钥验证数字签名。</li></ul><h3 id="挖矿：争夺记账权"><a href="#挖矿：争夺记账权" class="headerlink" title="挖矿：争夺记账权"></a>挖矿：争夺记账权</h3><p>网络中有很多记账者，他们在自己的账单里记录了上一页账单的哈希值（以此证明账单的连续性），监听别人广播的交易信息并记录在自己的账单中。</p><p>那么问题来了，那么多记账者，每个人都有自己版本的账单，到底谁的账单会被公认为下一页账单呢？比特币解决这个问题的方式是<strong>数学谜题</strong>。</p><p><code>H ( nonce || prev_hash || tx || tx ... || tx ) &lt; target</code> </p><p>（随机值+上个区块的哈希值+记录的交易）取哈希值，结果要满足一个很难达到的条件。记账者需要不断尝试随机数，第一个尝试成功的人拥有记账权。</p><h3 id="记账验证"><a href="#记账验证" class="headerlink" title="记账验证"></a>记账验证</h3><p>记账者获得记账权后，发布的区块需要被全网检验后才能接收，成为被公认的下一页账单。</p><p>其他记账者会检查：</p><ul><li>验证上一个区块的哈希值，和自己记录的是否一样。</li><li>验证每一笔交易是否合法：付款人和收款人的签名，交易余额是否足够</li><li>验证本页的哈希值是否有效</li></ul><p>通过验证后，获胜者可以获得奖励：</p><ul><li>区块奖励：挖出一个区块会奖励一定数量的比特币</li><li>交易手续费：这一个区块中记录的所有交易，都能从中获得一笔手续费。</li></ul><h3 id="交易模型：UTXO模型"><a href="#交易模型：UTXO模型" class="headerlink" title="交易模型：UTXO模型"></a>交易模型：UTXO模型</h3><p>UTXO: Unspent Transaction Output 未花费的交易输出</p><p>重点在于记录<strong>交易</strong>而非<strong>余额</strong>：</p><ul><li>传统账户交易：只看余额在交易前后的状态，加减账户的余额数字。</li><li>基于UTXO的交易：只记录交易过程，下一笔交易的输入必须是之前交易的输出</li></ul><p>比如A要给B转账20btc，账本中记录的不是A的余额减少了20，B增加了20。而是50个btc从A点流出，其中20流入了B，30流入了A。</p><p>用上一笔的流入作为下一笔的流出，并且可能是多笔流入一起作为下一笔流出。</p><p>因此在比特币交易中，没有<strong>余额</strong>的概念，上一次交易的流入减去的币就是余额。在花费的时候，必须知名每一笔余额的来源，而且必须全部花完，多余部分流回自己的地址，也可以每次都创建一个新的地址，这又是一个不符合直觉的地方。没有账户系统，每个人可以对应多个地址。</p><h4 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h4><p>电子货币容易出现<strong>双花问题</strong>。A可以同时声称自己将一比钱转给了B和C。比特币使用<strong>分叉与最长链原则</strong>来解决。</p><p>A如果要双花，那么他会将这两笔交易都广播。由于网络状况，不同的记账者接收到这两笔交易的先后顺序不同，并且收到一种一条后就不会再记录另一条。假设有两个记账者分别记录的给B和C的交易，并且几乎同时完成了数学谜题，那么他们会各自产生新区块，并且都认为自己是应该被公认的，这样就产生了<strong>分叉</strong>。</p><p>不同的分叉产生了不同的账本，只有记账者认可数最多的版本，才是公认的账本。如何体现认可数呢？通过区块链的<strong>长度</strong>。记账者会在他们认可的账本后面继续记账，因此越多人认可的区块链，有越多人参与，经过一段时间后该链的长度就会明显长与其他分叉，成为公认的账本。在比特币中，大家一般等待<strong>6个区块</strong>来确认一笔交易。注意，这只是一个<strong>约定俗成</strong>的数字。</p><h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1Vt411X7JF">北京大学肖臻老师《区块链技术与应用》公开课</a></p></blockquote><p>Ethereum，数字货币代号<strong>ETH</strong>，是区块链2.0应用的代表。相比1.0：</p><table><thead><tr><th align="left">区块链1.0（以比特币为代表）</th><th>区块链2.0（以太坊为代表）</th></tr></thead><tbody><tr><td align="left">非图灵完备：只能执行有限类型指定</td><td>图灵完备的</td></tr><tr><td align="left">不支持智能合约</td><td>支持智能合约</td></tr><tr><td align="left">定位于支付网络，数字货币</td><td>定位于平台，可以衍生出各种应用</td></tr></tbody></table><p>图灵完备：指机器执行任何其他可编程计算机能够执行计算的能力。一切可计算的问题都能解决，这样的虚拟机或者编程语言就叫图灵完备。</p><p>比特币的系统是图灵不完备的，而以太坊的智能合约系统是图灵完备的，实现了<strong>可编程的区块链</strong>，可以创建自己的应用，因此才说定位于<strong>平台</strong>。</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>传统的非智能合约，需要一个第三方来确保合约执行。</p><p>智能合约就是写在区块链上的一串自动执行的代码，一方面它不断地监听预置触发条件是否达到，如果达到了则执行预置的行动。</p><h3 id="DApp"><a href="#DApp" class="headerlink" title="DApp"></a>DApp</h3><p>以智能合约作为后台，加上数据库和前段界面后，就形成了DApp（去中心化的APP）。与传统APP最大的区别在于去中心化，说明其后端和数据库不是在某个中心化服务器，而是放在区块链上的。</p><h2 id="交易模型"><a href="#交易模型" class="headerlink" title="交易模型"></a>交易模型</h2><p>以太币的交易相较于比特币更加符合直觉，因为加入了<strong>账户系统</strong>。</p><p>因此天然避免双花问题，因为直接从余额中扣除两次即可。但是也引来了新的攻击——<strong>重放攻击</strong>。因此需要在交易中加入<strong>nonce</strong>，表示这个账户的第几次交易，并且由数字签名保护。</p><h3 id="账户类型"><a href="#账户类型" class="headerlink" title="账户类型"></a>账户类型</h3><p>以太坊中有两种账户：</p><ul><li>外部账户：由私钥来控制，包含信息有余额、交易次数（nonce）</li><li>合约账户：<ul><li>包含信息有：balance、nonce（表示调用其他合约的次数）、代码、存储（storage）</li><li>不能够主动发起交易。以太坊规定交易只能由外部账户发起。</li></ul></li></ul><h2 id="状态树"><a href="#状态树" class="headerlink" title="状态树"></a>状态树</h2><p>维护地址到状态的映射。以太坊中的地址是160位的，也就是40个16进制的整数。</p><ul><li>为什么不用哈希表维护这个映射：某些账户状态的更新需要重新计算整个哈希表的hash值，不能像merkle树那样只修改受到影响的部分。</li><li>为什么不使用merkle树：因为merkle树不提供快速查找的功能。而且如果不规定底层叶子节点的排序问题，那么每个全节点构造的merkle树可能是不一样的。比特币中其实也没有规定顺序，每个记账者监听到的交易的顺序是不同的，但是由于会竞争记账权，因此最后大家都遵循到记账权的人所记录的版本。</li><li>为什么不使用排序的merkle树：地址生成是随机的，很可能新增地址需要从中间插入，那么也会影响到大半个merkle树。</li></ul><p>以太坊实际使用的是<strong>trie</strong>结构，也就是我们熟知的<strong>前缀树</strong>。地址由40个16进制数组成，最后还需要一个结束标志符，则branching factor是17。</p><p>trie有很多很好的性质：</p><ul><li>无论插入节点的顺序是什么，构造出来的树都是一样的</li><li>只要地址不发生碰撞，那么每个地址一定对应唯一的分支</li><li>更新的局部性很好</li></ul><img src="C:\Users\JackZhu\AppData\Roaming\Typora\typora-user-images\image-20220310130157561.png" alt="image-20220310130157561" style="zoom:50%;" /><p>但是有个问题：当节点数量很少的时候，很多分支都是“一脉单传”的，有压缩的空间。以太坊使用的结构对trie进行了路径压缩，形成了<strong>Patricia trie</strong>。他可以将上面的树压缩成下面的状态。</p><img src="C:\Users\JackZhu\AppData\Roaming\Typora\typora-user-images\image-20220310130130956.png" alt="image-20220310130130956" style="zoom:50%;" /><p>Patricia trie在键值分布比较稀疏的时候效果好。对于以太坊地址而言，这个场景就非常适合，因为用户都可以在本地创建地址，为了避免地址碰撞，只能将地址规定得足够长。</p><p>merkle tree和binary tree的区别就是使用了哈希指针。那么merkle Patricia tree就是在Patricia tree的基础上使用了哈希指针。和比特币的merkle tree一样，merkle Patricia tree也提供了避免篡改、merkle proof的功能。</p><p>以太坊最终使用的是<strong>Modified MPT</strong>，shared nibbles表示共享的前缀。</p><img src="C:\Users\JackZhu\AppData\Roaming\Typora\typora-user-images\image-20220310131320802.png" alt="image-20220310131320802" style="zoom:50%;" /><p>在新的区块中，有些节点的信息发生了变化，这些变化不是在原地改动的，而是在新的区块中，没有修改的部分指向原区块的数据，修改的部分存在新区块中。Storage tree也是一个MPT，其中按键值对的形式保存，可以看做是程序中的<strong>变量</strong>。</p><img src="C:\Users\JackZhu\AppData\Roaming\Typora\typora-user-images\image-20220310132852516.png" alt="image-20220310132852516" style="zoom:50%;" /><p>为什么状态树要保存全局信息，而不是只保存当前区块内的交易涉及到的信息：因为假如A给B转账，需要知道A和B的状态。如果账户很久没有发生过交易，那么需要往前扫描很多区块才能找到；如果是新账户，那么要扫描到创世区块才能确定是新账户。</p><h3 id="交易树和收据树"><a href="#交易树和收据树" class="headerlink" title="交易树和收据树"></a>交易树和收据树</h3><p>由于智能合约的复杂性，所以以太坊引入这两种树来保存交易信息。这两个树不需要保存全局的信息，只包含新区块中产生的交易。理论上只需要使用普通的merkle tree，但实际使用MPT。</p><p>交易树的键值是交易在发布区块时的序号。</p><h2 id="发币和ICO"><a href="#发币和ICO" class="headerlink" title="发币和ICO"></a>发币和ICO</h2><p>为什么市面上有那么多数字货币？</p><p>因为他们很多是基于以太坊上的<strong>ERC20协议</strong>发行的代币。该协议允许用户自定义并发行Token，该Token的交易会被监听并记录在以太坊区块链上，因此其安全性和可信度等同于以太币ETH。该种代币发行方式有开源的代码模板可以借鉴，因此技术门槛比较低，吸引了各种人来发币。</p><p>其实很多代币的发行是一种<strong>众筹模式</strong>。比如一个团队打算开发一款DApp，他们可以先发币，声称该货币会在他们DApp中有作用，但是目前还在开发阶段。别人可以先买币，项目团队用买币的收入来开发，等开发完成后，这种货币也会有价值了，那么前期买币的人就获得了收益。这种就是Initial Coin Offering（<strong>首次发行代币</strong>）。</p><p>代币在区块链上火交易所内迅速流通，流动性媲美上市。但是其极强的流动性和该时期监管的缺失造成了极强的炒作性。大量散户涌入也加剧了盲目投机，催生出了一批借发币形式来圈钱的假项目，使发出的代币沦为“空气币”。</p><h2 id="以太币ETH的作用"><a href="#以太币ETH的作用" class="headerlink" title="以太币ETH的作用"></a>以太币ETH的作用</h2><ul><li><p>以太坊上用于支付交易手续费和运算服务的介质</p><ul><li><p>交易手续费：同比特币等电子现金系统，是给记账者的奖励</p></li><li><p>运算服务费：支付费用来运算智能合约或者其他以太坊上的程序（因为在以太坊上，节点不仅要负责记账，还需要负责智能合约的运算）</p></li></ul></li><li><p>ICO众筹中最常用的募资款项</p></li><li><p>加密货币交易市场中的主流交易对（不同代币之间的价值媒介）</p></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>目前有2个比较有前景的应用方向</p><h3 id="1-去中心化金融DeFi"><a href="#1-去中心化金融DeFi" class="headerlink" title="1. 去中心化金融DeFi"></a>1. 去中心化金融DeFi</h3><p>消除传统金融中的中介方、繁琐的手续和交易成本。</p><p>支付：不再依赖银行的账户系统，而是点对点支付，在跨国支付场景下尤为轻便<br>借贷：抵押资产借钱，在传统金融中只能抵押给银行等放贷机构，而智能合约的信用使得普惠借贷成为可能。<br>交易：去中心化交易所，链上撮合交易，无中心化风险（删库跑路）</p><h3 id="2-去中心化自治组织DAO"><a href="#2-去中心化自治组织DAO" class="headerlink" title="2. 去中心化自治组织DAO"></a>2. 去中心化自治组织DAO</h3><p>公司一般会有自己的章程，但是现实执行中未必会遵守。而DAO可以实现编程化的组织管理，即规则公开透明且无法篡改，满足条件自动执行，由程序替代人为管理。 </p><p>这样的特性也可以支持分布式协作。我们可以不需要认识组织内的成员，只需要认可规则，就可以一起协作。</p><h2 id="以太坊2-0"><a href="#以太坊2-0" class="headerlink" title="以太坊2.0"></a>以太坊2.0</h2><ul><li><p>共识机制切换：从PoW更换为POS</p></li><li><p>性能提升：采用分片技术，实现性能横向扩展</p></li><li><p>两条链：将于以太坊1.0并行存在，后期可能合并</p></li></ul><h1 id="zkSync"><a href="#zkSync" class="headerlink" title="zkSync"></a>zkSync</h1><blockquote><p>This video [L2 scalability and zkSync (Edcon talk) ](<a href="https://www.youtube.com/watch?v=el-9YYGN1nw&t=97s">L2 scalability and zkSync (Edcon talk) - YouTube</a>)is from the website of zkSync</p></blockquote><p>This video talks about scalability problem. In the speaker’s opinion, it is hard to scale blockchain because the core value propositon of layer 1 is resilience. The way that BitCoin and Etherum reach resilience is decentralization. </p><p>However, in order to ensure security in such an open system, every transactioin executed every L1 node should be verified, rather than easily trusted. Including more nodes in the system requires more verification, and this could be bad for scalability. Only increasing throughput will rise the requirement of nodes, which leads to less qualified nodes. Therefore, the scalability means increasing throughput without increasing node load.</p><p>There are two way to do this:</p><ul><li>Sharding: not verify every transaction, but only a few of them.</li><li>Compression: verify a larger amount of transcations by spending the same amount of computational resources.</li></ul><p>Most of technologies, no matter they belong to Sharding or Compression, have <strong>data availbility problem</strong>. Most of them keep data off-chain, which makes it possible to withhold the data. <strong>Optimisitc rollup</strong> and <strong>zkRollup</strong> keep data on-chain. With rollup technology, the levels of security and usability are very close to mainnet, but the cost is that scalability boost is capped at 100x compared to mainnet. </p><p>key words:</p><ul><li><p><strong>zK</strong>：zero-knowledge proofs</p></li><li><p><strong>Layer2</strong>：基于以太坊主网的系统，为了对主网进行扩展</p></li><li><p><strong>zkSync</strong>：A Layer 2 scaling solution on Ethereum that offers low gas and fast transactions, without compromising on security. </p></li><li><p><strong>Rollup</strong>：Layer2 方案之一，也叫卷叠，通过将以太坊主网上交易的计算和存储转移至 Layer2 处理并压缩，再将压缩后的数据上传至以太坊主网以拓展以太坊性能。</p></li><li><p>ZK Rollup：采用零知识证明的 Rollup 方案，和其他 Rollup 的不同之处在于采用 zkSNARK 算法（一种零知识证明算法）压缩数据。</p><p>zkRollup（zkSync 将其所采用的 ZK Rollup 写作 zkRollup）通过将每笔交易压缩后的数据传到以太坊主网上，保证数据的有效性和可用性，使 zkSync 网络具备和以太坊主网同等的安全性。</p></li><li><p><strong>zKSNARK</strong>：指的是一种证明结构，其中人们可以证明拥有某些信息，例如密钥，而无需透露该信息，并且证明者和验证者之间没有任何相互作用。</p></li></ul><h4 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h4><p>为了解决以太坊的可拓展性问题，开发者提出了两个方向的解决方案，Layer2 和分片（Eth2 的一个重要升级）。Layer2 字面意思是二层网络，相对的，当前的以太坊主网也称为一层网络（Layer1），二层网络也就是基于当前以太坊主网的一个系统。</p><p>Layer2 方案主要是从减轻 Layer1 负担的角度出发，将 Layer1 的大量计算需求搬到 Layer2 上。</p><p>主流 Layer2 方案有 ZK Rollup、Optimistic Rollup、Plasma、State Channels（状态通道）、Validium 等。</p><h4 id="Rollups"><a href="#Rollups" class="headerlink" title="Rollups"></a>Rollups</h4><p>Rollups 是一种「混合」的 Layer2 方案。<strong>Rollups 将计算（以及状态存储）转移至链下，但同时将每笔交易的部分数据保留在链上。</strong></p><p>为了提高效率，他们使用了不少 fancy 的压缩技巧，尽可能地使用「计算」代替「数据」。其结果是系统的扩容仍然受限于底层区块链的数据带宽，但效率是可观的：Ethereum ERC20 代币转账成本约为 45,000 gas，而 Rollup 中的 ERC20 代币转账仅使用 16 字节的链上空间，成本低于 300 gas。</p><p>事实上，数据上链是关键（注意：将数据放在 IPFS 上是行不通的，因为 IPFS 不提供任何给定数据是否可用的共识，所以数据必须放到区块链上）。将数据放在链上并获得共识，如果任何人愿意，他们可以在本地处理 rollup 中的所有操作，从而允许他们监测欺诈交易，请求提款，或亲自生成 transaction batches。</p><p>因为没有数据可用性问题，所以恶意或离线运营者所造成的损失会更少（比如他们不能造成 1 周的延迟），从而为谁有权发布 batches 打开了更大的设计空间，并简化 rollups 系统。最重要的是，没有数据可用性问题也意味着不再需要将资产映射到 owners。</p><p>这是 Ethereum 社区对 rollups 比以往的 Layer2 扩容方案更兴奋的关键原因：<strong>Rollups 是完全通用的，我们甚至可以在 rollup 内运行一个 EVM，使得现有的 Ethereum 应用不必编写过多新的代码就可以迁移到 rollups 上。</strong></p><h4 id="ZK-Rollup"><a href="#ZK-Rollup" class="headerlink" title="ZK Rollup"></a>ZK Rollup</h4><p>ZK 是 Zero Knowledge（零知识）的缩写，零知识证明是指证明者能够在不向验证者提供任何有用信息的情况下，使验证者相信某个论断是正确的。</p><p>Rollup 中文叫做卷叠，是一种以太坊扩容方案的统称。Rollup 通过将链上计算转移至链下（二层网络），但同时将每笔交易的部分数据保留在链上达到提升以太坊网络性能的目的。</p><p>ZK Rollup &#x3D; 交易压缩 + 零知识证明（zk-SNARK）</p><p>ZK Rollup 核心思想是在链下达成交易共识，并通过零知识证明算法压缩交易数据，保证链下交易状态的有效性，最后将数据同步至以太坊主网。</p><h4 id="Optimistic-rollups-VS-ZK-rollups"><a href="#Optimistic-rollups-VS-ZK-rollups" class="headerlink" title="Optimistic rollups VS ZK rollups"></a>Optimistic rollups VS ZK rollups</h4><ul><li><p><strong>Optimistic rollups</strong>，采用欺诈性证明：rollup 合约会跟踪历史的 state roots 和每一个 batch 的哈希值。如果有人发现某个 batch 的 post-state root 不正确，那么他们可以向合约提交证明，证明该 batch 计算错误。合约验证该证明有效后，会对该 batch 和之后的所有 batch 进行回滚。</p></li><li><p><strong>ZK rollups</strong>，采用有效性证明：每一个 batch 都包含一个称为 ZK-SNARK 的密码学证明（例如采用 PLONK 协议），它可以证明 post-state root 是执行该 batch 的正确结果。无论计算量有多大，合约都可以迅速地在链上验证证明。</p></li></ul><h4 id="zK-SNARK"><a href="#zK-SNARK" class="headerlink" title="zK-SNARK"></a>zK-SNARK</h4><p>Zk-SNARK是一个首字母缩略词，代表”零知识简洁的非交互式知识论证”。zk-SNARK是一种加密证明，允许一方证明其拥有某些信息而不泄露该信息。使用在交易发生之前创建的密钥可以证明此证明。它被用作加密货币<a href="https://www.investopedia.com/terms/z/zcash.asp">Zcash</a>协议的一部分。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链, 比特币, 以太坊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客网TOP101</title>
    <link href="/algorithm/nowcoder/"/>
    <url>/algorithm/nowcoder/</url>
    
    <content type="html"><![CDATA[<p>算是在LeetCode之外开一个新坑，毕竟LeetCode是写过一次的，而且不是专项练习。牛客网的101题是有分单元的，而且我没有写过。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 反转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    ListNode* last = <span class="hljs-literal">nullptr</span>;<br>    ListNode* next = pHead-&gt;next;<br>    <span class="hljs-keyword">while</span>(pHead)&#123;<br>        next = pHead-&gt;next;<br>        pHead-&gt;next = last;<br>        last = pHead;<br>        pHead = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 链表内指定区间反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy-&gt;next = head;<br>    ListNode *pre = dummy, *cur = head; <br>    <span class="hljs-comment">//获取反转区间的起点和起点前的点pre</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        pre = cur;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 这个循环相当于把每次遍历到的节点提前至反转区间的头部</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++)&#123;<br>        ListNode *tmp = cur-&gt;next;<br>        cur-&gt;next = tmp-&gt;next;<br>        tmp-&gt;next = pre-&gt;next;<br>        pre-&gt;next = tmp;<span class="hljs-comment">//每次都更新反转区间与链表头部的连接的节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于每次都将<code>cur-&gt;next</code>移动到<code>pre-&gt;next</code>，然后<code>cur</code>前进一格。</p><p><a href="https://imgtu.com/i/b8JUI0"><img src="https://s4.ax1x.com/2022/03/02/b8JUI0.png" alt="b8JUI0.png" style="zoom:50%;" /></a></p><p><a href="https://imgtu.com/i/b8D73n"><img src="https://s4.ax1x.com/2022/03/02/b8D73n.png" alt="b8D73n.png" style="zoom:50%;" /></a></p><h3 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 链表中的节点每k个一组翻转</h3><p>和上一题一样的思路，采用递归写法，先判断节点数量是否需要反转。如果需要，那么执行<code>k-1</code>次，每次都是把<code>cur-&gt;next</code>移动到<code>pre-&gt;next</code>，然后<code>cur</code>前进一格。执行完后<code>cur</code>正好处在反转区间的尾部，<code>cur-&gt;next</code>就是下一个反转区间的开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!head || k &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode *pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), *cur = head, *next = <span class="hljs-literal">nullptr</span>;<br>    pre-&gt;next = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span> head;<span class="hljs-comment">//节点数不到k个</span><br>        cur = cur-&gt;next;<span class="hljs-comment">//寻找反转区间的右边界，开区间</span><br>    &#125;<br>    cur = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++)&#123;<span class="hljs-comment">//只需要执行k-1次</span><br>        next = cur-&gt;next;<br>        cur-&gt;next = next-&gt;next;<br>        next-&gt;next = pre-&gt;next;<br>        pre-&gt;next = next;<br>    &#125;<br>    cur-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(cur-&gt;next, k);<br>    <span class="hljs-keyword">return</span> pre-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 合并两个排序的链表</h3><p>递推版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    ListNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* dummy = cur;<br>    <span class="hljs-keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;<br>       <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;<br>            cur-&gt;next = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur-&gt;next = pHead1 ? pHead1 : pHead2;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p> 递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pHead1)<span class="hljs-keyword">return</span> pHead2;<br>    <span class="hljs-keyword">if</span>(!pHead2)<span class="hljs-keyword">return</span> pHead1;<br>    <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;<br>        pHead1-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1-&gt;next, pHead2);<br>        <span class="hljs-keyword">return</span> pHead1;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pHead2-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1, pHead2-&gt;next);<br>        <span class="hljs-keyword">return</span> pHead2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 合并k个已排序的链表</h3><p>只要利用了优先队列这样的数据结构，这题就很容易了，让优先队列自动帮我们维护排序即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> ListNode* l, <span class="hljs-type">const</span> ListNode* r)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> l-&gt;val &gt; r-&gt;val;&#125;<br>&#125;;<br><span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;<br>    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l: lists)<br>        <span class="hljs-keyword">if</span>(l) q.<span class="hljs-built_in">push</span>(l);<br>    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode *cur = dummy;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        cur-&gt;next = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next) q.<span class="hljs-built_in">push</span>(cur-&gt;next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 判断链表中是否有环</h3><p>快慢指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a>BM7 链表中环的入口结点</h3><p>快慢指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    <span class="hljs-comment">// 先检查有没有环</span><br>    ListNode *fast = pHead, *slow = pHead;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        <span class="hljs-comment">// 确定有环，再来寻找环的入口</span><br>        fast = pHead;<span class="hljs-comment">//这一步很关键，有数学证明这样可以使快慢指针在入口相遇</span><br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM8-链表中倒数最后k个结点"><a href="#BM8-链表中倒数最后k个结点" class="headerlink" title="BM8 链表中倒数最后k个结点"></a>BM8 链表中倒数最后k个结点</h3><p>第一种思路比较符合直觉：先遍历一遍获得链表长度，然后再遍历一次找到截取的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    ListNode* cur = pHead;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        cur = cur-&gt;next;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k &gt; len)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    cur = pHead;<br>    <span class="hljs-type">int</span> n = len - k;<br>    <span class="hljs-keyword">while</span>(n--)cur = cur-&gt;next;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种写法是快慢指针，其实性能应该是差不多的，但是看起来高端一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ListNode *fast = pHead, *slow = pHead;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-keyword">if</span>(!fast)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 删除链表的倒数第n个节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        fast = fast-&gt;next;<br>    <span class="hljs-comment">//如果此时快指针已经到达尾后，说要删除的就是链表头</span><br>    <span class="hljs-keyword">if</span>(!fast) <span class="hljs-keyword">return</span> head-&gt;next;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<span class="hljs-comment">//直到fast到达结尾</span><br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//此时慢指针停在该被删除的节点之前，修改其next跳过被删除的节点</span><br>    slow-&gt;next = slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 两个链表的第一个公共结点</h3><p>既然保证输入数据肯定是正确的，那么只要不断遍历，两个节点一定会相遇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pHead1 || !pHead2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode *p1 = pHead1, *p2 = pHead2;<br>    <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>        p1 = p1 ? p1-&gt;next : pHead1;<br>        p2 = p2 ? p2-&gt;next : pHead2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM11-两个链表生成相加链表"><a href="#BM11-两个链表生成相加链表" class="headerlink" title="BM11 两个链表生成相加链表"></a>BM11 两个链表生成相加链表</h3><p>结合力扣第2题和牛客第1题，先将两个链表反转，相加后再将结果反转后返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">addInList</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReverseList</span>(<span class="hljs-built_in">addTwoNumbers</span>(<span class="hljs-built_in">ReverseList</span>(head1), <span class="hljs-built_in">ReverseList</span>(head2)));<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* cur = head;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 || l2 || tmp)&#123;<br>        <span class="hljs-type">int</span> sum = tmp;<br>        sum += l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>        sum += l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>        tmp = sum / <span class="hljs-number">10</span>;<br>        sum %= <span class="hljs-number">10</span>;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(l1)l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l2)l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    ListNode* last = <span class="hljs-literal">nullptr</span>;<br>    ListNode* next = pHead-&gt;next;<br>    <span class="hljs-keyword">while</span>(pHead)&#123;<br>        next = pHead-&gt;next;<br>        pHead-&gt;next = last;<br>        last = pHead;<br>        pHead = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM12-单链表的排序"><a href="#BM12-单链表的排序" class="headerlink" title="BM12 单链表的排序"></a>BM12 单链表的排序</h3><p>要求：空间复杂度 O*(*n)，时间复杂度 O(nlogn)，那我为何不直接塞到数组里，然后对数组排序，再重建列表呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> ListNode* a, <span class="hljs-type">const</span> ListNode* b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a-&gt;val &lt; b-&gt;val;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">sortInList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    vector&lt;ListNode*&gt; arr;<br>    ListNode* tmp = head;<br>    <span class="hljs-keyword">while</span>(tmp)&#123;<br>        arr.<span class="hljs-built_in">push_back</span>(tmp);<br>        tmp = tmp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>        arr[i]-&gt;next = arr[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    arr[arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM13-判断一个链表是否为回文结构"><a href="#BM13-判断一个链表是否为回文结构" class="headerlink" title="BM13 判断一个链表是否为回文结构"></a>BM13 判断一个链表是否为回文结构</h3><p>这里也复用了BM1的代码。用快慢指针找到链表中间的部分，然后反转后半链表。</p><p>将数据都读到数组里也是一种做法，这题并没有限制空间，但是反转链表的方式可以节省内存，但是会改变链表本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPail</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//从slow开始讲后半部分的链表反转</span><br>    ListNode *l1 = <span class="hljs-built_in">ReverseList</span>(slow), *l2 = head;<br>    <span class="hljs-keyword">while</span>(l1)&#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val != l2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        l1 = l1-&gt;next;<br>        l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a>BM14 链表的奇偶重排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    ListNode *even_head = head-&gt;next, *odd = head, *even = head-&gt;next;<br>    <span class="hljs-comment">//如果是奇数个节点，因为even本身起点就比head多1，所以即使只剩一个节点</span><br>    <span class="hljs-keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;<br>        odd-&gt;next = odd-&gt;next-&gt;next;<br>        odd = odd-&gt;next;<br>        even-&gt;next = even-&gt;next-&gt;next;<br>        even = even-&gt;next;<br>    &#125;<br>    odd-&gt;next = even_head;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 删除有序链表中重复的元素-I</h3><p>每次遍历到该节点和下一个节点一样的，就让该节点跳过下一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *cur = head;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a>BM16 删除有序链表中重复的元素-II</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode *cur = head, *pre = dummy;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;<br>            <span class="hljs-comment">//跳过除了自己之外的所有重复节点</span><br>            <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            &#125;<br>            pre-&gt;next = cur-&gt;next;<span class="hljs-comment">//pre-&gt;next跳过重复节点cur</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pre = cur;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找-x2F-排序"><a href="#二分查找-x2F-排序" class="headerlink" title="二分查找&#x2F;排序"></a>二分查找&#x2F;排序</h2><h3 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 二分查找-I</h3><p>二分查找的思路本身没什么好说的，但是细节部分很值得深究，比如每次重新赋值<code>left</code>和<code>right</code>要不要对<code>mid</code>加一或者减一；循环判断条件用<code>&lt;=</code>还是<code>&lt;</code>，这些会影响到查找的效果。我会在<a href="/%E7%AC%94%E8%AE%B0/binary-search/">这篇笔记</a>中单独讲这个问题。</p><p>这里先提供一个最基本的二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-type">int</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>            l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h3><p>从矩阵的右上角开始查找，如果偏大了就向左走，偏小了就向右走。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> R = array.<span class="hljs-built_in">size</span>(), C = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = C - <span class="hljs-number">1</span>;<span class="hljs-comment">//起点是右上角</span><br>    <span class="hljs-keyword">while</span>(r &lt; R &amp;&amp; c &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//坐标还在合理范围内</span><br>        <span class="hljs-keyword">if</span>(array[r][c] &lt; target) r++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[r][c] &gt; target) c--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 寻找峰值</h3><p>二分法，判断当前点<code>mid</code>是上坡还是下坡，向上坡方向靠拢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//由于right=mid，所以right是有可能被返回的</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<span class="hljs-comment">//退出条件left==right</span><br>        <span class="hljs-type">int</span> mid = (right + left) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>])<span class="hljs-comment">//这是上坡，右侧可能有峰值</span><br>            left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//mid+1是因为mid不可能是峰值</span><br>        <span class="hljs-keyword">else</span> right = mid;<span class="hljs-comment">//mid可能是峰值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 数组中的逆序对</h3><p>在归并排序中可以顺便统计逆序对。在合并阶段，左区间的所有节点应该小于右区间的所有节点，所以在比较左右区间中的点时，只要遇到了右区间的元素比左区间小的情况，那么该右区间元素与左区间的所有元素都形成了逆序对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> M = <span class="hljs-number">1000000007</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(data.size())</span></span>;<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;data, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, l, mid, ans);<br>    <span class="hljs-built_in">mergeSort</span>(data, tmp, mid +<span class="hljs-number">1</span> , r, ans);<br>    <span class="hljs-built_in">merge</span>(data, tmp, l, mid, r, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;data, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> &amp;ans)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(data[i] &gt; data[j])&#123;<span class="hljs-comment">//右区间的元素小于左区间，会产生逆序对</span><br>            tmp[k++] = data[j++];<br>            <span class="hljs-comment">//data[i, mid]中所有元素都与data[j]产生逆序对</span><br>            ans = (ans + (mid - i + <span class="hljs-number">1</span>)) % M;<br>        &#125;<span class="hljs-keyword">else</span> tmp[k++] = data[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)<br>        tmp[k++] = data[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r)<br>        tmp[k++] = data[j++];<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; l &lt;= r; l++, k++)<br>        data[l] = tmp[k];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 旋转数组的最小数字</h3><p>二分查找，判断<code>arr[mid]</code>和<code>arr[left]</code>的关系。但是这道题要小心<code>[1,0,1,1,1]</code>这样的数据，因为<code>mid</code>第一次迭代时就是中间的1，如果只是在<code>arr[mid] == arr[left]</code>的情况下<code>left++</code>的话，mid将永远访问不到0所在的位置。因此需要加上<code>if(rotateArray[left] &lt; rotateArray[right])</code>的特判。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; rotateArray)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = rotateArray.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<span class="hljs-comment">//最后剩下的元素一定是答案</span><br>        <span class="hljs-keyword">if</span>(rotateArray[left] &lt; rotateArray[right])<br>            <span class="hljs-keyword">return</span> rotateArray[left];<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(rotateArray[mid] &gt; rotateArray[left])<br>            left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//mid不可能为答案</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotateArray[mid] &lt; rotateArray[left])<br>            right = mid;<span class="hljs-comment">//mid可能为答案</span><br>        <span class="hljs-keyword">else</span> left++;<span class="hljs-comment">//无法判断，保守策略</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> rotateArray[left];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 比较版本号</h3><p>双指针，每次提取一个数字来比较。如果遇到不相等就提前结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, len1 = version1.<span class="hljs-built_in">size</span>(), len2 = version2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> num1, num2;<br>    <span class="hljs-keyword">while</span>(i &lt; len1 || j &lt; len2)&#123;<br>        num1 = <span class="hljs-built_in">consume</span>(i, version1);<br>        num2 = <span class="hljs-built_in">consume</span>(j, version2);<br>        <span class="hljs-keyword">if</span>(num1 &gt; num2)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num1 &lt; num2)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p, string&amp; s)</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[p] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>        ret = ret * <span class="hljs-number">10</span> + s[p++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    p++;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 二叉树的前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-built_in">dfs</span>(root, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 二叉树的中序遍历</h3><p>和上题差不多，只需要改<code>dfs</code>部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 二叉树的后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>    ans.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 求二叉树的层序遍历</h3><p>可能bfs会直观一点，不过dfs也不难写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>    <span class="hljs-built_in">dfs</span>(root, ans, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;ans, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() &lt;= depth)<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    ans[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 按之字形顺序打印二叉树</h3><p>理论上可以借用上题的代码获取数据，然后把偶数行给<code>reverse</code>，但是这样效率不高，不如在递归的时候就把数据按顺序排好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>    <span class="hljs-built_in">dfs</span>(pRoot, ans, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;ans, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() &lt;= depth)<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    ans[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-keyword">if</span>(depth % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ans, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 二叉树的最大深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM29-二叉树中和为某一值的路径-一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a>BM29 二叉树中和为某一值的路径(一)</h3><p>注意空树直接返回<code>false</code>的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum -= root-&gt;val;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 二叉搜索树与双向链表</h3><p>先中序遍历，把排好序的数都保存到数组上，再遍历一遍创建列表，这是一种直观的思路。递归的写法其实在时间复杂度和空间复杂度上没有明显优势。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">TreeNode *dummy, *pre;<br><span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRootOfTree) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>    pre = dummy;<br>    <span class="hljs-built_in">dfs</span>(pRootOfTree);<br>    dummy-&gt;right-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> dummy-&gt;right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(!dummy) dummy-&gt;right = node;<br>    pre-&gt;right = node;<br>    node-&gt;left = pre;<br>    pre = node;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a>BM31 对称的二叉树</h3><p>题解中很多写法声称每个节点只会访问一次，其实是不对的，这样写才能保证一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!pRoot-&gt;left || !pRoot-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(pRoot-&gt;left-&gt;val != pRoot-&gt;right-&gt;val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(pRoot-&gt;left, pRoot-&gt;right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* l, TreeNode* r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!l &amp;&amp; !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!l || !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(l-&gt;val != r-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="hljs-built_in">isSame</span>(l-&gt;right, r-&gt;left);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 合并二叉树</h3><p>在确保<code>t1</code>和<code>t2</code>非空的情况下，把<code>t2</code>合并到<code>t1</code>上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span>(!t1 || !t2) <span class="hljs-keyword">return</span> t1 ? t1 : t2;<br>    <span class="hljs-comment">//到这里说明t1和t2都存在</span><br>    t1-&gt;val += t2-&gt;val;<br>    t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>    t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>    <span class="hljs-keyword">return</span> t1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 二叉树的镜像</h3><p>关键在于使用<strong>后序遍历</strong>，从底层开始逐层向上翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!pRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>    <span class="hljs-built_in">swap</span>(pRoot-&gt;left, pRoot-&gt;right);<br>    <span class="hljs-keyword">return</span> pRoot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 判断是不是二叉搜索树</h3><p>中序遍历下二叉搜索树应该是有序的，因此使用<code>pre</code>记录前一个节点的值，每次遍历到的节点值都应该大于<code>pre</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">long</span> pre;<br><span class="hljs-type">bool</span> ans;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    pre = LONG_LONG_MIN;<br>    ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node || !ans) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(pre &lt; node-&gt;val)&#123;<br>        pre = node-&gt;val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a>BM35 判断是不是完全二叉树</h3><p>用BFS逐层遍历，用<code>flag</code>变量记住是否遇到过空节点。如果已经遇到过空节点后，再遇到正常节点，那么就是不完全二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    queue&lt;TreeNode*&gt; q;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode *node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!node)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//flag为true说明在此节点前已经遇到空节点了</span><br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a>BM36 判断是不是平衡二叉树</h3><p>如果写一个计算高度的函数，然后从上往下遍历，那么会在计算高度的时候重复计算。可以在计算高度时从下往上判断，如果不合法则返回-1，合法则返回高度。遇到-1之后就不需要继续计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(pRoot) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode *node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(node-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//如果不合法则返回-1，合法则返回高度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a>BM37 二叉搜索树的最近公共祖先</h3><p>根节点一定是祖先，因此从根往下找。如果<code>root</code>比p和q都大，那么说明p和q都在root的左子树上，反之则在右子树上。当p和q分别位于<code>root</code>的左右两边时，说明<code>root</code>是最近公共祖先。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(root)&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; p &amp;&amp; root-&gt;val &gt; q)<br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; p &amp;&amp; root-&gt;val &lt; q)<br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM38-在二叉树中找到两个节点的最近公共祖先（重要）"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先（重要）" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先（重要）"></a>BM38 在二叉树中找到两个节点的最近公共祖先（重要）</h3><ol><li><p>如果该节点不是O1也不是O2，那么O1与O2必然分别在该节点的左子树和右子树中</p></li><li><p>如果该节点就是O1或者O2，那么另一个节点在它的左子树或右子树中</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, o1, o2)-&gt;val;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root || root-&gt;val == o1 || root-&gt;val == o2)<br>        <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">dfs</span>(root-&gt;left, o1, o2);<br>    TreeNode* right = <span class="hljs-built_in">dfs</span>(root-&gt;right, o1, o2);<br>    <span class="hljs-comment">//如果不在左子树，就肯定在右子树；反正依然</span><br>    <span class="hljs-keyword">if</span>(!left) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span>(!right) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-comment">//如果左右子树都不为空，那么说明该点就是最近公共祖先</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a>BM39 序列化二叉树</h3><p>采用先序遍历的方式序列化和反序列化。序列化时遇到空节点则设置为<code>#</code>，反序列化时遇到空节点则设置为不可能的值。采用队列来保存节点值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;    <br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(root, ans); <br>    <span class="hljs-type">char</span>* ret = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ans.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(ret, ans.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; vals;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>            vals.<span class="hljs-built_in">push</span>(tmp);<br>            tmp = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            tmp = <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp = tmp * <span class="hljs-number">10</span> + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(vals);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, string&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!node)&#123;<br>        ans += <span class="hljs-string">&quot;#,&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ans += <span class="hljs-built_in">to_string</span>(node-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left, ans);<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right, ans);<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(queue&lt;<span class="hljs-type">int</span>&gt;&amp; vals)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(vals.<span class="hljs-built_in">front</span>() == <span class="hljs-number">-1</span>)&#123;<br>        vals.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vals.<span class="hljs-built_in">front</span>());<br>    vals.<span class="hljs-built_in">pop</span>();<br>    node-&gt;left = <span class="hljs-built_in">build</span>(vals);<br>    node-&gt;right = <span class="hljs-built_in">build</span>(vals);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a>BM40 重建二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">auto</span> mid = <span class="hljs-built_in">find</span>(vin.<span class="hljs-built_in">begin</span>(), vin.<span class="hljs-built_in">end</span>(), root-&gt;val);<br>    <span class="hljs-type">int</span> left = mid - vin.<span class="hljs-built_in">begin</span>(), right = vin.<span class="hljs-built_in">end</span>() - mid;<br>    root-&gt;left = <span class="hljs-built_in">reConstructBinaryTree</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+left), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(vin.<span class="hljs-built_in">begin</span>(), mid));<br>    root-&gt;right = <span class="hljs-built_in">reConstructBinaryTree</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+left, pre.<span class="hljs-built_in">end</span>()), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(mid+<span class="hljs-number">1</span>, vin.<span class="hljs-built_in">end</span>()));<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a>BM41 输出二叉树的右视图</h3><p>先使用上一题的代码重建二叉树，再层序遍历，每层取最后一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; xianxu, vector&lt;<span class="hljs-type">int</span>&gt;&amp; zhongxu)</span> </span>&#123;<br>    TreeNode *root = <span class="hljs-built_in">reConstructBinaryTree</span>(xianxu, zhongxu);<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        TreeNode *last = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            last = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(last-&gt;left)q.<span class="hljs-built_in">push</span>(last-&gt;left);<br>            <span class="hljs-keyword">if</span>(last-&gt;right)q.<span class="hljs-built_in">push</span>(last-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(last-&gt;val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">d<br></code></pre></td></tr></table></figure><h2 id="堆-x2F-栈-x2F-队列"><a href="#堆-x2F-栈-x2F-队列" class="headerlink" title="堆&#x2F;栈&#x2F;队列"></a>堆&#x2F;栈&#x2F;队列</h2><h3 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 用两个栈实现队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> tmp = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br></code></pre></td></tr></table></figure><h3 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a>BM43 包含min函数的栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        s.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(min_s.<span class="hljs-built_in">empty</span>())<br>            min_s.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> min_s.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">min</span>(value, min_s.<span class="hljs-built_in">top</span>()));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        s.<span class="hljs-built_in">pop</span>();<br>        min_s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_s;<br></code></pre></td></tr></table></figure><h3 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a>BM44 有效括号序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; left;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s)&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;[&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>            left.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; left.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            left.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a>BM45 滑动窗口的最大值</h3><p>本来应该是用优先队列来维护窗口内的最大值，但是C++的<code>priority_queue</code>无法提供快速的查找功能，这样在串口移动的时候无法删除失效的元素。因此可以改用<code>multiset</code>，内部也是有序的，可以直接获取最大值，而且可以O(logN)查找失效元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>  multiset&lt;<span class="hljs-type">int</span>&gt; m;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    m.<span class="hljs-built_in">insert</span>(nums[i]);<br>    <span class="hljs-keyword">if</span>(i &gt;= size) m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">find</span>(nums[i - size]));<br>    <span class="hljs-keyword">if</span>(i &gt;= size - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(*m.<span class="hljs-built_in">rbegin</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM46-最小的K个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46 最小的K个数"></a>BM46 最小的K个数</h3><p>用一个大根堆，从大到小维护目前遍历过的元素中最小的k个。每次遍历一个新的数，就和堆顶比较，如果比堆顶小，就入堆，并控制堆大小为k；如果比堆顶还大，就跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : input)&#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &lt; k)<br>            pq.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>() &gt; i)&#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>());<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47 寻找第K大"></a>BM47 寻找第K大</h3><p>两种思路。第一种，构造一个小顶堆，控制堆的size不超过k。在size达到k的时候，新元素和堆顶比较，如果比堆顶更大则可以入堆。最后返回堆顶就是第k大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &lt; K) pq.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>() &lt; i)&#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种思路是分治，利用快排的思想。每次只对第k大的元素可能在的半边排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(a, l, r);<br>    <span class="hljs-keyword">if</span>(pivot == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a[pivot];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pivot &gt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, l, pivot - <span class="hljs-number">1</span>, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(a, pivot + <span class="hljs-number">1</span>, r, k);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> tmp = a[l];<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; tmp &gt;= a[r]) r--;<br>        a[l] = a[r];<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; tmp &lt;= a[l]) l++;<br>        a[r] = a[l];<br>    &#125;<br>    a[l] = tmp;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 数据流中的中位数</h3><p>维护一个大顶堆和一个小顶堆。大顶堆保存数据流中较小的数据，小顶堆保存较大的数据。插入时尽量插入小顶堆，并且控制小顶堆比大顶堆多1个或者相等。然后如果需要取中位数的时候，奇数情况下从小顶堆取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue&lt;<span class="hljs-type">int</span>&gt; big_heap;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; small_heap;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!big_heap.<span class="hljs-built_in">empty</span>() &amp;&amp; num &lt; big_heap.<span class="hljs-built_in">top</span>())<br>        big_heap.<span class="hljs-built_in">push</span>(num);<br>    <span class="hljs-keyword">else</span> <br>        small_heap.<span class="hljs-built_in">push</span>(num);<br>    <span class="hljs-keyword">if</span>(small_heap.<span class="hljs-built_in">size</span>() == big_heap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span>)&#123;<br>        big_heap.<span class="hljs-built_in">push</span>(small_heap.<span class="hljs-built_in">top</span>());<br>        small_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(small_heap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> == big_heap.<span class="hljs-built_in">size</span>())&#123;<br>        small_heap.<span class="hljs-built_in">push</span>(big_heap.<span class="hljs-built_in">top</span>());<br>        big_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">if</span>((small_heap.<span class="hljs-built_in">size</span>() + big_heap.<span class="hljs-built_in">size</span>()) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (small_heap.<span class="hljs-built_in">top</span>() + big_heap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> small_heap.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a>BM49 表达式求值</h3><p>首先提供的是直接求值的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-built_in">cal</span>(ops, nums);<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">priority</span>(ops.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">priority</span>(c))<br>                <span class="hljs-built_in">cal</span>(ops, nums);<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                tmp = tmp * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            i--;<br>            nums.<span class="hljs-built_in">push</span>(tmp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())<span class="hljs-built_in">cal</span>(ops, nums);<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops, stack&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> b = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">char</span> op = ops.<span class="hljs-built_in">top</span>(); ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %d\n&quot;</span>, a, op, b);<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a + b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a - b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a * b);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后提供的版本由2个函数组成。先由<code>getSuffixExpr()</code>将中缀表达式转换为后缀表达式，注意这一步已经将运算符优先级处理完毕。第二部由<code>parseSuffixExpr()</code>将后缀表达式转换为计算结果，只一步不需要考虑运算符优先级，只需要按照规则逐个运算符计算即可。</p><p>如何处理运算符优先级：每次运算符入栈时，先将栈内优先级大于等于新运算符的出栈，表示这些应当被优先计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; exp = <span class="hljs-built_in">getSuffixExpr</span>(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseSuffixExpr</span>(exp);<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getSuffixExpr</span><span class="hljs-params">(string s)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    vector&lt;string&gt; exp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isDigit</span>(c))&#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isDigit</span>(s[i]))&#123;<br>                tmp = tmp * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                i++;<br>            &#125;<br>            i--;<br>            exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(tmp));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">priority</span>(ops.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">priority</span>(c))<br>                exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>            ops.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())exp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pop</span>(ops));<br>    <span class="hljs-keyword">return</span> exp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parseSuffixExpr</span><span class="hljs-params">(vector&lt;string&gt;&amp; exp)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span>(string&amp; s : exp)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isDigit</span>(s[<span class="hljs-number">0</span>]))<br>            nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">cal</span>(s[<span class="hljs-number">0</span>], nums);<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">pop</span><span class="hljs-params">(stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops)</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">1</span>, ops.top())</span></span>;<br>    ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">char</span> op, stack&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> b = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a + b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a - b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a * b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;/&#x27;</span>)nums.<span class="hljs-built_in">push</span>(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a>BM50 两数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(m[target - numbers[i]] != <span class="hljs-number">0</span>)&#123;<br>            ans[<span class="hljs-number">0</span>] = m[target - numbers[i]];<br>            ans[<span class="hljs-number">1</span>] = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            m[numbers[i]] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a>BM51 数组中出现次数超过一半的数字</h3><p>投票法。记录当前遇到的出现最多的数字和次数，如果遍历到一样的就增加次数，不一样则减少次数；次数如果减到-1则换一个数字来记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : numbers)&#123;<br>        <span class="hljs-keyword">if</span>(ans == i)&#123;<br>            cnt++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>                ans = i;<br>                cnt++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a>BM52 <em>数组中只出现一次的两个数字</em></h3><p>首先需要做过一道前置题目：数组中只出现一次的数字。那道题中将所有的数组元素异或即可，因为出现两次的数字异或后会抵消，最后只留下出现一次的数字。</p><p>这道题中有2个数字只出现一次，如果按照同样的方式，只能得到这两个数字的异或值。已知这两个数肯定不同，那么异或的结果必然不同，至少有一位为1。那么就找到这一位，将数组中的数按照这一位是否为1来分成2类，分别将两类数异或后即是所求的答案。可以理解为每一类数各contribute to其中一个答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : array) a ^= i;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span>((a &amp; p) == <span class="hljs-number">0</span>) p &lt;&lt;= <span class="hljs-number">1</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-comment">// p在最先遇到a为1的那位上为1</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : array)&#123;<br>        <span class="hljs-keyword">if</span>(i &amp; p) n ^= i;<br>        <span class="hljs-keyword">else</span> m ^= i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; m) <span class="hljs-built_in">swap</span>(n, m);<br>    <span class="hljs-keyword">return</span> &#123;n,m&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 <em>缺失的第一个正整数</em></h3><p>在恢复后，数组应当有 <code>[1, 2, ..., N]</code> 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。我们遍历，如果遍历到的<code>x=nums[i]</code>在<code>[1,N]</code>内，就把这个数交换到他应该在的位置：<code>nums[x-1]</code>。持续交换直到<code>x</code>是一个<code>[1,N]</code>以外的数，或者就是这个位置应该所在的数：<code>x-1==i</code>。</p><p>由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 N，整个方法的时间复杂度为 O(N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberDisappeared</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 如果nums[i]不是该在的位置上应有的数，则继续循环。注意避免死循环</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt; nums[i] &amp;&amp; nums[i] &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>] != nums[i])<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM54-三数之和"><a href="#❓BM54-三数之和" class="headerlink" title="❓BM54 三数之和"></a>❓BM54 三数之和</h3><p>我们进行循环选择第一个数<strong>x</strong>，然后创建两个指针<strong>i</strong>和<strong>j</strong>，指针<strong>i</strong>指向下一个数，指针<strong>j</strong>指向最后一个数。</p><ul><li>若指针<strong>i</strong> 加指针<strong>j</strong> 大于当前数 <strong>x</strong>则指针<strong>j</strong> –，</li><li>若指针<strong>i</strong> 加指针<strong>j</strong> 小于当前数 <strong>x</strong>则指针<strong>i</strong>++，</li><li>若指针<strong>i</strong> 加指针<strong>j</strong> 等于当前数<strong>x</strong> 则答案为<strong>x</strong> 和指针<strong>i</strong> 与<strong>j</strong> 的三元组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; num[i] == num[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(num[i] + num[l] + num[r] == <span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;num[i], num[l], num[r]&#125;);<br>                <span class="hljs-comment">// 跳过一样的</span><br>                <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r &amp;&amp; num[l] == num[l+<span class="hljs-number">1</span>]) l++;<br>                <span class="hljs-keyword">while</span>(r - <span class="hljs-number">1</span> &gt; l &amp;&amp; num[r] == num[r<span class="hljs-number">-1</span>]) r--;<br>                l++; r--; <span class="hljs-comment">// 掉过当前数字，到下一个数字</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i] + num[l] + num[r] &gt; <span class="hljs-number">0</span>) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a>BM55 没有重复项数字的全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num) &#123;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    ans.<span class="hljs-built_in">clear</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-built_in">dfs</span>(num, tmp);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;num, vector&lt;<span class="hljs-type">int</span>&gt; &amp;tmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == num.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[num[i]])&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(num[i]);<br>            vis[num[i]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(num, tmp);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>            vis[num[i]] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a>BM56 有重复项数字的全排列</h3><p>通过<code>last</code>来控制，在同一层递归的循环中，不重复使用相同数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-built_in">dfs</span>(nums, tmp, ans);<br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; tmp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> last = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i] || last == nums[i])<br>            <span class="hljs-keyword">continue</span>;<br>        last = nums[i];<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">dfs</span>(nums, tmp, ans);<br>        vis[i] = <span class="hljs-literal">false</span>;<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a>BM57 岛屿数量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                ans++;<br>                <span class="hljs-built_in">dfs</span>(i, j, grid);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> mr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> mc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span></span>&#123;<br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>        <span class="hljs-type">int</span> nr = r + mr[i];<br>        <span class="hljs-type">int</span> nc = c + mc[i];<br>        <span class="hljs-keyword">if</span>(nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[nr][nc] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(nr, nc, grid);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a>BM58 字符串的排列</h3><p>直接用set保存所有遇到过的字符串排列会使得空间复杂度达到O(n!)，通过先将字符串排序，然后每层递归都判断自己这个字符是否是第一次使用，这样可以将空间复杂度减少到O(n)。还有一种next_permutation算法，基于交换，对每一个排列找到需要交换的元素，得到下一个字典序的排列，可以将空间复杂度减少到O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; ans;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>string tmp;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>    vis.<span class="hljs-built_in">resize</span>(str.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">dfs</span>(str);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[i])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; vis[i<span class="hljs-number">-1</span>] &amp;&amp; str[i<span class="hljs-number">-1</span>] == str[i])<span class="hljs-keyword">continue</span>;<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(str[i]);<br>        <span class="hljs-built_in">dfs</span>(str);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>        vis[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM59-N皇后"><a href="#❓BM59-N皇后" class="headerlink" title="❓BM59 N皇后"></a>❓BM59 N皇后</h3><p>注释语句可以输出皇后的摆法。这种写法不需要借助vis数组来记录第几行，第几列，低级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Nqueen</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">search</span>(<span class="hljs-number">0</span>, n, C, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, <span class="hljs-type">int</span>&amp; ans)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur == n)&#123;<br>        ans++;<br>        <span class="hljs-comment">// for(int i = 0; i &lt; n; i++)</span><br>        <span class="hljs-comment">//     printf(&quot;%d%c&quot;, C[i]+1,&quot; \n&quot;[i==n-1]);</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        C[cur] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cur; j++)<br>            <span class="hljs-keyword">if</span>(C[cur] == C[j] || cur - C[cur] == j - C[j] || cur + C[cur] == j + C[j])&#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(ok)<br>            <span class="hljs-built_in">search</span>(cur + <span class="hljs-number">1</span>, n, C, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cur==n)&#123;<br>tot++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,C[i]+<span class="hljs-number">1</span>,<span class="hljs-string">&quot; \n&quot;</span>[i==n<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(!vis[<span class="hljs-number">0</span>][i]&amp;&amp;!vis[<span class="hljs-number">1</span>][cur+i]&amp;&amp;!vis[<span class="hljs-number">2</span>][cur-i+n])&#123;<br>C[cur]=i;<br>vis[<span class="hljs-number">0</span>][i]=vis[<span class="hljs-number">1</span>][cur+i]=vis[<span class="hljs-number">2</span>][cur-i+n]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">search</span>(cur+<span class="hljs-number">1</span>);<br>vis[<span class="hljs-number">0</span>][i]=vis[<span class="hljs-number">1</span>][cur+i]=vis[<span class="hljs-number">2</span>][cur-i+n]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a>BM60 括号生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    string tmp;<br>    <span class="hljs-built_in">dfs</span>(ans, tmp, n, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; ans, string&amp; cur, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> l)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> * n)&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt; n)&#123;<br>        string tmp = cur + <span class="hljs-string">&quot;(&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(ans, tmp, n, l+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l == n || l &gt; cur.<span class="hljs-built_in">size</span>() - l)&#123;<br>        string tmp = cur + <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(ans, tmp, n, l);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a>BM61 矩阵最长递增路径</h3><p>一种新的写法，不同于我习惯的循环向四个方向扩展。注意这是递归，会先探到死路在逐层返回，所以每个节点都已经充分访问过其可能路径，之后不需要再访问，可直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m; j++)&#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(matrix, dp, i, j, <span class="hljs-number">-1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; dp, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> pre)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix[r][c] &lt;= pre)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(dp[r][c] != <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[r][c];<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; n) tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r+<span class="hljs-number">1</span>, c, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r<span class="hljs-number">-1</span>, c, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(c + <span class="hljs-number">1</span> &lt; m) tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r, c+<span class="hljs-number">1</span>, matrix[r][c]));<br>    <span class="hljs-keyword">if</span>(c - <span class="hljs-number">1</span> &gt;= m)tmp = <span class="hljs-built_in">max</span>(tmp, <span class="hljs-built_in">dfs</span>(matrix, dp, r, c<span class="hljs-number">-1</span>, matrix[r][c]));<br>    dp[r][c] = tmp + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> tmp + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a>BM62 斐波那契数列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a>BM63 跳台阶</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">jumpFloor</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">jumpFloor</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 最小花费爬楼梯</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>] + cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + cost[i<span class="hljs-number">-2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❗BM65-最长公共子序列-二"><a href="#❗BM65-最长公共子序列-二" class="headerlink" title="❗BM65 最长公共子序列(二)"></a>❗BM65 最长公共子序列(二)</h3><p>如果是只用求最长公共子序列的长度，只需要前半部分的代码。如果需要求具体的字串是什么，需要根据长度反推，从后往前推。</p><p><a href="https://imgtu.com/i/jjJsSS"><img src="https://s1.ax1x.com/2022/07/24/jjJsSS.png" alt="jjJsSS.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i][j]表示s[:i]和s[:j]之间的最长公共字串长度</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 得到了最长公共字串的长度，接下来求对应子串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[s1.<span class="hljs-built_in">size</span>()][s2.<span class="hljs-built_in">size</span>()]);<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>(), j = s2.<span class="hljs-built_in">size</span>(); dp[i][j] &gt;= <span class="hljs-number">1</span>; )&#123;<br>        <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-comment">// dp[i][j]来自dp[i-1][j-1]</span><br>            ans += s1[i<span class="hljs-number">-1</span>];<br>            i--; j--;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>]) i--; <span class="hljs-comment">// 哪边大就来自哪边</span><br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;-1&quot;</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❗BM66-最长公共子串"><a href="#❗BM66-最长公共子串" class="headerlink" title="❗BM66 最长公共子串"></a>❗BM66 最长公共子串</h3><p>全部清零后，直接二重遍历，如果遇到更长的字串就记录长度和结束位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>];<br>    <span class="hljs-comment">// 最长公共字串的长度，以及结束位置</span><br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1[i<span class="hljs-number">-1</span>] == str2[j<span class="hljs-number">-1</span>])&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; maxLen)&#123;<br>                    maxLen = dp[i][j];<br>                    last = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(last - maxLen, maxLen);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM67-不同路径的数目-一"><a href="#BM67-不同路径的数目-一" class="headerlink" title="BM67 不同路径的数目(一)"></a>BM67 不同路径的数目(一)</h3><p>能到达<code>dp[i][j]</code>的路径只能来自<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a>BM68 矩阵的最小路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = matrix[i][j] + dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = matrix[i][j] + <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a>BM69 把数字翻译成字符串</h3><p>由于每次解析要么用1位数，要么用2位数，所以<code>dp[i]</code>的状态由<code>dp[i-1]</code>和<code>dp[i-2]</code>推出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: 到nums[:i]为止有几种解析方式</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 如果当前数字是0，那么无法作为1位数解析</span><br>        dp[i] = nums[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : dp[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> twoDigits = nums[i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">10</span> * (nums[i<span class="hljs-number">-2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">// 十位数不能是0，并且值要在范围内</span><br>            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-2</span>] != <span class="hljs-number">0</span> &amp;&amp; twoDigits &gt;= <span class="hljs-number">10</span> &amp;&amp; twoDigits &lt;= <span class="hljs-number">26</span>)&#123;<br>                dp[i] += dp[i<span class="hljs-number">-2</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM70-兑换零钱-一"><a href="#BM70-兑换零钱-一" class="headerlink" title="BM70 兑换零钱(一)"></a>BM70 兑换零钱(一)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoney</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: 达到i金额，最少需要d[i]张纸币</span><br>    <span class="hljs-comment">// MAX: 不可能达到的最大值</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>], MAX = aim + <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(aim == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= aim; i++) dp[i] = MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= aim; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : arr)&#123;<br>            <span class="hljs-comment">// 目前检查的金额i大于钞票v，说明状态dp[i]可以由dp[i-v]达到</span><br>            <span class="hljs-keyword">if</span>(i &gt;= v)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-v] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[aim] == MAX ? <span class="hljs-number">-1</span> : dp[aim];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM71-最长上升子序列-一"><a href="#BM71-最长上升子序列-一" class="headerlink" title="BM71 最长上升子序列(一)"></a>BM71 最长上升子序列(一)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i]: arr[:i]以内的最长上升子序列</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-comment">// 这一步很关键，因为每一个元素都可以作为子序列的起点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) dp[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[i])&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 答案不一定是dp[arr.size()-1]</span><br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a>BM72 连续子数组的最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        array[i] = <span class="hljs-built_in">max</span>(array[i], array[i] + array[i<span class="hljs-number">-1</span>]);<br>        ans = <span class="hljs-built_in">max</span>(ans, array[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a>BM73 最长回文子串</h3><p>中心扩散法和动态规划法的时间复杂度都是O(N^2^)， 但是中心扩散法的空间复杂度是O(1)，动态规划是O(N^2^)。还有一种时间复杂度O(N)的马拉车算法，暂时还没学会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLongestPalindrome</span><span class="hljs-params">(string A)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">getLen</span>(A, i, i));<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">getLen</span>(A, i, i + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">(string&amp; A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; A.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(A[l] == A[r])&#123;<br>            l--;<br>            r++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 此时A[l] ！= A[r]，需要减2</span><br>    <span class="hljs-keyword">return</span> r - l + <span class="hljs-number">1</span> - <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a>BM74 数字字符串转化成IP地址</h3><p>比牛客的官解稍微简洁一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-built_in">solve</span>(s, ans, <span class="hljs-built_in">vector</span>&lt;string&gt;(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; ans, vector&lt;string&gt; tmp, <span class="hljs-type">int</span> beg)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(beg == s.<span class="hljs-built_in">size</span>() &amp;&amp; tmp.<span class="hljs-built_in">size</span>() != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(beg &gt;= s.<span class="hljs-built_in">size</span>() &amp;&amp; tmp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-comment">// 拼接答案</span><br>        string s1 = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(string&amp; i : tmp)<br>            s1 += i + <span class="hljs-string">&#x27;.&#x27;</span>;<br>        ans.<span class="hljs-built_in">push_back</span>(s1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span> &amp;&amp; beg + len &lt;= s.<span class="hljs-built_in">size</span>(); len++)&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(beg, len));<br>        <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span> || (len &gt; <span class="hljs-number">1</span> &amp;&amp; s[beg] == <span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-keyword">break</span>;<br>        tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(beg, len));<br>        <span class="hljs-built_in">solve</span>(s, ans, tmp, beg + len);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM75-编辑距离-一"><a href="#❓BM75-编辑距离-一" class="headerlink" title="❓BM75 编辑距离(一)"></a>❓BM75 编辑距离(一)</h3><p>用<code>dp[i][j]</code>表示从两个字符串首部各自到<code>str1[i]</code>和<code>str2[j]</code>为止的子串需要的编辑距离，那很明显<code>dp[str1.length][str2.length]</code>就是我们要求的编辑距离。</p><p>初始状态可以看做，空字符串想要变成另一个字符串，只能通过增加字符。</p><p>对于<code>dp[i+1][j+1] = min(dp[i][j], min(dp[i+1][j], dp[i][j+1])) + 1;</code>这句关键代码的解释：</p><p>希望<code>str1[:i+1]</code>和<code>str2[:j+1]</code>相同，已知<code>str1[i] != str2[j]</code>，那么<code>dp[i+1][j+1]</code>可以由以下转移：</p><ul><li><code>dp[i][j]</code>：<code>str1[:i]</code>和<code>str2[:j]</code>已经相同，修改<code>str1[i]</code></li><li><code>dp[i+1][j]</code>：<code>str1[:i+1]</code>和<code>str2[:j]</code>已经相同，删除字符<code>str1[i+1]</code></li><li><code>dp[i][j+1]</code>：<code>str1[:i]</code>和<code>str2[:j+1]</code>已经相同，增加字符<code>str2[j]</code>到str1[:i]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">editDistance</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = str1.<span class="hljs-built_in">size</span>(), len2 = str2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-comment">// 初始化边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)<br>        dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++)<br>        dp[<span class="hljs-number">0</span>][i+<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>][i] + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 遍历str1的每个位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)&#123;<br>        <span class="hljs-comment">// 遍历str2对应的每个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1[i] == str2[j]) <span class="hljs-comment">// 字符相同，不需要编辑，直接从dp[i][j]转移</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 需要从这3个来源选最小的，增加1个编辑距离</span><br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM76-正则表达式匹配"><a href="#❓BM76-正则表达式匹配" class="headerlink" title="❓BM76 正则表达式匹配"></a>❓BM76 正则表达式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><h3 id="BM77-最长的括号子串"><a href="#BM77-最长的括号子串" class="headerlink" title="BM77 最长的括号子串"></a>BM77 最长的括号子串</h3><p>始终保持栈底元素为当前已经遍历过的元素中<strong>最后一个没有被匹配的右括号的下标</strong>，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><ol><li>对于遇到的每个<code>(</code> ，将它的下标放入栈中</li><li>对于遇到的每个<code>)</code>，先弹出栈顶元素表示匹配了当前右括号：<ol><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，将其下标放入栈中来更新我们之前提到的<strong>最后一个没有被匹配的右括号的下标</strong></li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为<strong>以该右括号为结尾的最长有效括号的长度</strong></li></ol></li><li>从前往后遍历字符串并更新答案即可。</li></ol><p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的<strong>最后一个没有被匹配的右括号的下标</strong>，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。(注意，这样栈里无论如何都<strong>至少有一个元素</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>(); <br>                ans = <span class="hljs-built_in">max</span>(i - st.<span class="hljs-built_in">top</span>(), ans);<br>            &#125;  <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM78-打家劫舍-一"><a href="#BM78-打家劫舍-一" class="headerlink" title="BM78 打家劫舍(一)"></a>BM78 打家劫舍(一)</h3><p><code>dp[i]</code>表示<code>nums[:i]</code>部分（左闭右开）能取得的最大值。对于每一个i，要么不偷，那么<code>dp[i+1]=dp[i]</code>；要么偷，那么<code>dp[i+1]=dp[i-1]+nums[i]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        dp[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i], dp[i<span class="hljs-number">-1</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM79-打家劫舍-二"><a href="#BM79-打家劫舍-二" class="headerlink" title="BM79 打家劫舍(二)"></a>BM79 打家劫舍(二)</h3><p>使用两个dp数组，分别忽略第一个和最后一个房子进行dp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 最开始的房不偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// 最后一个房不偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp2</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        dp1[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp1[i], dp1[i<span class="hljs-number">-1</span>] + nums[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>        dp2[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp2[i], dp2[i<span class="hljs-number">-1</span>] + nums[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp1[nums.<span class="hljs-built_in">size</span>()], dp2[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM80-买卖股票的最好时机-一"><a href="#BM80-买卖股票的最好时机-一" class="headerlink" title="BM80 买卖股票的最好时机(一)"></a>BM80 买卖股票的最好时机(一)</h3><p>不需要用到动态规划，只用遍历数组，维护目前遇到的最小值和最大利润，遍历时更新这两个值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>], ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : prices)&#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, i - minPrice);<br>        minPrice = <span class="hljs-built_in">min</span>(minPrice, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM81-买卖股票的最好时机-二"><a href="#BM81-买卖股票的最好时机-二" class="headerlink" title="BM81 买卖股票的最好时机(二)"></a>BM81 买卖股票的最好时机(二)</h3><p>一个合理的买卖股票过程就是寻找数组中的一段连续上升子序列。只要找出所有的连续上升子序列，就可以得到总利润。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, last = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(prices[i] &lt; prices[i<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-comment">// 连续上升子序列断了，结算之前的利润，更新起点为当前价格</span><br>            ans += prices[i<span class="hljs-number">-1</span>] - last;<br>            last = prices[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(*prices.<span class="hljs-built_in">rbegin</span>() &gt; last)<br>        ans += *prices.<span class="hljs-built_in">rbegin</span>() - last;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM82-买卖股票的最好时机-三"><a href="#❓BM82-买卖股票的最好时机-三" class="headerlink" title="❓BM82 买卖股票的最好时机(三)"></a>❓BM82 买卖股票的最好时机(三)</h3><ul><li><code>dp[i][0]</code>表示到第i天为止没有买过股票的最大收益</li><li><code>dp[i][1]</code>表示到第i天为止买过一次股票还没有卖出的最大收益</li><li><code>dp[i][2]</code>表示到第i天为止买过一次也卖出过一次股票的最大收益</li><li><code>dp[i][3]</code>表示到第i天为止买过两次只卖出过一次股票的最大收益</li><li><code>dp[i][4]</code>表示到第i天为止买过两次同时也买出过两次股票的最大收益</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, last = prices[<span class="hljs-number">0</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">-1e9</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 没有操作过，所以和前一天一样</span><br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 第一次买入，从没操作过转移</span><br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        <span class="hljs-comment">// 第一次卖出，从第一次买入</span><br>        dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>        <span class="hljs-comment">// 第二次买入，从没操作过转移</span><br>        dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>        <span class="hljs-comment">// 第二次卖出，从第一次买入</span><br>        dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="BM83-字符串变形"><a href="#BM83-字符串变形" class="headerlink" title="BM83 字符串变形"></a>BM83 字符串变形</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">trans</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;string&gt; tmp;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) s[i] -= <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) s[i] += <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(last, i - last));<br>            last = i + <span class="hljs-number">1</span>;<br><br>        &#125;<br>    &#125;<br>    string ans = s.<span class="hljs-built_in">substr</span>(last, s.<span class="hljs-built_in">size</span>() - last);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = tmp.<span class="hljs-built_in">rbegin</span>(); it != tmp.<span class="hljs-built_in">rend</span>(); ++it)&#123;<br>        ans += <span class="hljs-string">&quot; &quot;</span> + (*it);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM84-最长公共前缀"><a href="#BM84-最长公共前缀" class="headerlink" title="BM84 最长公共前缀"></a>BM84 最长公共前缀</h3><p>牛客上只有O(N*M)的复杂度，N是字符串数量，M是字符串平均长度。但是牛客的进阶要求是O(N)，题解随便翻翻没有翻到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> len = strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-type">char</span> c = strs[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span>(strs[j].<span class="hljs-built_in">size</span>() == i || strs[j][i] != c)&#123;<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM85-验证IP地址"><a href="#BM85-验证IP地址" class="headerlink" title="BM85 验证IP地址"></a>BM85 验证IP地址</h3><p>稍微复杂的模拟，注意代码的结构即可。注意<code>(i = s.find(spliter))</code>这里必须要括号，因为<code>=</code>的优先级很低，如果不带括号就是<code>i = (s.find(spliter) &amp;&amp; i != s.npos)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(IP.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIPv4</span>(IP))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv4&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIPv6</span>(IP))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv6&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string s, string spliter)</span></span>&#123;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">while</span>((i = s.<span class="hljs-built_in">find</span>(spliter)) &amp;&amp; i != s.npos)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>        s = s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>);<br>    &#125;<br>    res.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv4</span><span class="hljs-params">(string ip)</span></span>&#123;<br>    vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(ip, <span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-comment">// 必须有4个数</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>        cout &lt;&lt; s[i] &lt;&lt; endl;<br>        <span class="hljs-comment">// 不允许缺省</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 不允许前导0</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> &amp;&amp; s[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 必须每一位都是数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s[i])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(s[i]);<br>        <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv6</span><span class="hljs-params">(string ip)</span></span>&#123;<br>    vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(ip, <span class="hljs-string">&quot;:&quot;</span>);<br>    <span class="hljs-comment">// 必须有8组</span><br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-comment">//位数必须是1-4</span><br>        <span class="hljs-keyword">if</span>(s[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s[i])<br>            <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">isdigit</span>(c) || (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) || (<span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM86-大数加法"><a href="#BM86-大数加法" class="headerlink" title="BM86 大数加法"></a>BM86 大数加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>, a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() || i &lt; t.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        a = i &lt; s.<span class="hljs-built_in">size</span>() ? s[i] : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        b = i &lt; t.<span class="hljs-built_in">size</span>() ? t[i] : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        tmp += a + b - (<span class="hljs-string">&#x27;0&#x27;</span> * <span class="hljs-number">2</span>);<br>        ans += (tmp % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        tmp /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp) ans += <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="BM87-合并两个有序的数组"><a href="#BM87-合并两个有序的数组" class="headerlink" title="BM87 合并两个有序的数组"></a>BM87 合并两个有序的数组</h3><p><code>A[m:]</code>部分是空的，所以不能思维定式从小到大处理，而是从大到小处理，优先填补<code>A[m:]</code>这部分空数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = m - <span class="hljs-number">1</span>, b = n - <span class="hljs-number">1</span>, i = m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(a &gt;= <span class="hljs-number">0</span> || b &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span>) A[i--] = B[b--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b &lt; <span class="hljs-number">0</span>) A[i--] = A[a--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[a] &gt; B[b]) A[i--] = A[a--];<br>        <span class="hljs-keyword">else</span> A[i--] = B[b--];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM88-判断是否为回文字符串"><a href="#BM88-判断是否为回文字符串" class="headerlink" title="BM88 判断是否为回文字符串"></a>BM88 判断是否为回文字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; l &lt; r; l++, r--)&#123;<br>        <span class="hljs-keyword">if</span>(str[l] != str[r])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM89-合并区间"><a href="#BM89-合并区间" class="headerlink" title="BM89 合并区间"></a>BM89 合并区间</h3><p>先按照区间的左边界排序，然后逐一判断合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;Interval&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;<br>    vector&lt;Interval&gt; ans;<br>    <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    ans.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : intervals)&#123;<br>        <span class="hljs-keyword">auto</span> tmp = ans.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span>(tmp.start &lt;= i.start &amp;&amp; tmp.end &gt;= i.start)&#123;<br>            ans[ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>].end = <span class="hljs-built_in">max</span>(tmp.end, i.end);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Interval&amp; a, <span class="hljs-type">const</span> Interval&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.start != b.start ? a.start &lt; b.start : a.end &lt; b.end;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM90-最小覆盖子串"><a href="#BM90-最小覆盖子串" class="headerlink" title="BM90 最小覆盖子串"></a>BM90 最小覆盖子串</h3><p>设置两个指针left，right。表示S的子串tmp可由left和right表示，当需要添加元素时候，就将right++，pop元素就left++。</p><p>我们用哈希表判断left到right是否完全包含T，动态维护窗口中所有字符以及个数。具体过程如下：</p><p>如果新加入的字符是被需要的（指在T里面），那么这个字符加入到窗口中，当窗口中的字符数目和被需要的数目相等时候，匹配度加一。right右移，这里匹配度是window里面的字符与need里面字符相等的数目。</p><p>如果新加入的字符不被需要（指不在T里面），right右移</p><p>当匹配度等于被需要的字符种类数，说明left-right覆盖到了T的所有字符，并且记录当前的left和right位置，然后就开始向右移动left</p><p>如果left位置的字符是被T所需要的，windo所统计的left字符要减一，当窗口中left处的字符数目小于need的字符数目，匹配度减一</p><p>如果left位置的字符不是被T所需要的，直接右移即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string S, string T)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-type">int</span> need[<span class="hljs-number">128</span>], cnt[<span class="hljs-number">128</span>], target = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(need, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(need));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: T) &#123;<br>        <span class="hljs-comment">// 记录T中出现多少种字符</span><br>        <span class="hljs-keyword">if</span>(need[c] == <span class="hljs-number">0</span>)target++;<br>        need[c]++;<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, minlen = INT_MAX;<br>    <span class="hljs-comment">// match记录窗口匹配多少个字符</span><br>    <span class="hljs-type">int</span> match = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; r &lt; S.<span class="hljs-built_in">size</span>(); r++)&#123;<br>        <span class="hljs-type">char</span> c = S[r];<br>        <span class="hljs-keyword">if</span>(need[c] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果这个字符有需求</span><br>            cnt[c]++;<br>            <span class="hljs-comment">// 如果这个字符的出现次数满足要求了</span><br>            <span class="hljs-keyword">if</span>(cnt[c] == need[c]) match++;<br>        &#125;<br>        <span class="hljs-comment">// 当目前字串符合要求时，尽量尝试缩小左边界，直到窗口不符合要求</span><br>        <span class="hljs-keyword">while</span>(match == target)&#123;<br>            <span class="hljs-keyword">if</span>(minlen &gt; r - l + <span class="hljs-number">1</span>)&#123;<br>                minlen = r - l + <span class="hljs-number">1</span>;<br>                start = l;<br>            &#125;<br>            c = S[l];<br>            <span class="hljs-keyword">if</span>(need[c] &gt; <span class="hljs-number">0</span>)&#123;<br>                cnt[c]--;<br>                <span class="hljs-keyword">if</span>(cnt[c] &lt; need[c]) match--;<br>            &#125;<br>            l++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minlen == INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : S.<span class="hljs-built_in">substr</span>(start, minlen);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM91-反转字符串"><a href="#BM91-反转字符串" class="headerlink" title="BM91 反转字符串"></a>BM91 反转字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-built_in">swap</span>(str[i], str[str.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM92-最长无重复子数组"><a href="#BM92-最长无重复子数组" class="headerlink" title="BM92 最长无重复子数组"></a>BM92 最长无重复子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> loc[<span class="hljs-number">100005</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span>; i++)<br>        loc[i] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; r &lt; arr.<span class="hljs-built_in">size</span>(); r++)&#123;<br>        <span class="hljs-keyword">if</span>(loc[arr[r]] != <span class="hljs-number">-1</span>)&#123;<br>            l = <span class="hljs-built_in">max</span>(l, loc[arr[r]]);<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, r - l);<br>        loc[arr[r]] = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓❗BM93-盛水最多的容器"><a href="#❓❗BM93-盛水最多的容器" class="headerlink" title="❓❗BM93 盛水最多的容器"></a>❓❗BM93 盛水最多的容器</h3><p>双指针+贪心。双指针分别指向数组的两端，表示从最宽的地方开始计算，每次舍弃掉容器较短的那边，向内部移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> cap = <span class="hljs-built_in">min</span>(height[left], height[right]) * (right - left);<br>        ans = <span class="hljs-built_in">max</span>(ans, cap);<br>        <span class="hljs-comment">//哪边小就舍弃哪边</span><br>        <span class="hljs-keyword">if</span>(height[left] &lt; height[right])<br>            left++;<br>        <span class="hljs-keyword">else</span><br>            right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓❗BM94-接雨水问题"><a href="#❓❗BM94-接雨水问题" class="headerlink" title="❓❗BM94 接雨水问题"></a>❓❗BM94 接雨水问题</h3><ul><li>step 1：检查数组是否为空的特殊情况</li><li>step 2：准备双指针，分别指向数组首尾元素，代表最初的两个边界</li><li>step 3：指针往中间遍历，遇到更低柱子就是底，用较短的边界减去底就是这一列的接水量，遇到更高的柱子就是新的边界，更新边界大小。</li></ul><p>两边的双指针框定了木桶的两边，具体能接多少水取决于短板，遍历时计算每一列能存多少水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxWater</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> maxL = <span class="hljs-number">0</span>, maxR = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        maxL = <span class="hljs-built_in">max</span>(maxL, arr[l]);<br>        maxR = <span class="hljs-built_in">max</span>(maxR, arr[r]);<br>        <span class="hljs-keyword">if</span>(maxL &gt; maxR)<br>            ans += maxR - arr[r--];<br>        <span class="hljs-keyword">else</span><br>            ans += maxL - arr[l++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br></code></pre></td></tr></table></figure><h3 id="BM98-螺旋矩阵"><a href="#BM98-螺旋矩阵" class="headerlink" title="BM98 螺旋矩阵"></a>BM98 螺旋矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> mc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">while</span> (cnt &lt; n * m) &#123;<br>        <span class="hljs-type">int</span> nr = r + mr[p];<br>        <span class="hljs-type">int</span> nc = c + mc[p];<br>        <span class="hljs-keyword">if</span> (nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; n &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; m &amp;&amp; !vis[nr][nc]) &#123;<br>            <span class="hljs-comment">// 什么也不做</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p = (p + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            nr = r + mr[p];<br>            nc = c + mc[p];<br>        &#125;<br>        vis[nr][nc] = <span class="hljs-literal">true</span>;<br>        cnt++;<br>        ans.<span class="hljs-built_in">push_back</span>(matrix[nr][nc]);<br>        r = nr;<br>        c = nc;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="❓BM99-顺时针旋转矩阵"><a href="#❓BM99-顺时针旋转矩阵" class="headerlink" title="❓BM99 顺时针旋转矩阵"></a>❓BM99 顺时针旋转矩阵</h3><p>这个做法需要背住，不然想不到。先沿着左对角线做反转，然后在根据中轴线做轴对称，结果就是顺时针旋转90度的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">rotateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; mat, <span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-built_in">swap</span>(mat[i][j], mat[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">reverse</span>(mat[i].<span class="hljs-built_in">begin</span>(), mat[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> mat;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并行公开课笔记</title>
    <link href="/Linux-C++/%E5%B9%B6%E8%A1%8C%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <url>/Linux-C++/%E5%B9%B6%E8%A1%8C%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>课程来源：<a href="https://www.bilibili.com/video/BV1fa411r7zp">【录播】现代C++中的高性能并行编程与优化（持续更新中）</a>]</p></blockquote><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_times</span><span class="hljs-params">(string msg)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123;<br>cout &lt;&lt; msg &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>N</code>作为模板参数和作为函数参数，有什么区别呢？</p><p>区别在于模板参数传入的<code>N</code>是一个<strong>编译期常量</strong>，对于每一个不同的N，编译器都会单独生成一份代码，从而可以做单独优化。</p><p>函数参数是<strong>运行期常量</strong>，编译器无法自动优化。</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><code>if constexpr (x)</code>可以指定x是编译时常量，但是有诸多限制。</p><ol><li>不能通过<strong>运行时变量</strong>组成的表达式决定，比如<code>if constexpr (x%2)</code>。x只能是编译期能确定的值。</li><li>即使作为模板参数，传入时也必须是字面量。如果要传入变量，则变量也需要<code>constexpr</code>来修饰。如果传入的变量初始化为函数的范围值，如<code>constexpr bool debug = isnegative(-1)</code>，那么这个函数也需要<code>constexpr</code>来修饰。<code>constexpr</code>函数不能调用<code>non-constexpr</code>函数。</li></ol><p><code>constexpr</code>函数必须是<code>inline</code>的，不能分离声明和定义。标准库中很多函数都是<code>constexpr</code>的（如std::min），可以放心使用。</p><h2 id="分离模板的声明和定义"><a href="#分离模板的声明和定义" class="headerlink" title="分离模板的声明和定义"></a>分离模板的声明和定义</h2><p>编译器对模板的编译时<strong>惰性</strong>的，只有当前的.cpp文件用到了模板，该模板才会被定义。</p><p>不建议分离，违背了开闭原则。</p><h2 id="auto和decltype"><a href="#auto和decltype" class="headerlink" title="auto和decltype"></a>auto和decltype</h2><p><code>auto</code>不能用与定义类成员，很奇怪。</p><p>函数返回值也可以用<code>auto</code>来推断，但是注意：</p><ol><li>函数的多个<code>return</code>语句返回类型必须<strong>一致</strong>。</li><li>如果没有<code>return</code>，则auto推断为<code>void</code></li><li>如果声明和实现分离了，则不能声明为<code>auto</code></li></ol><p><code>decltype(变量名)</code>和<code>decltype(表达式)</code>是不同的，可以通过<code>decltype((a))</code>来强制编译器使用表达式，得到一个引用类型。 </p><h3 id="万能推到decltype-auto"><a href="#万能推到decltype-auto" class="headerlink" title="万能推到decltype(auto)"></a>万能推到decltype(auto)</h3><p>如果是一个表达式，那么我们不知道它是可变引用（int &amp;），常引用（int const &amp;），右值引用（int &amp;&amp;），还是一个普通的值。</p><p>如果需要定义一个和表达式返回类型一样的变量， 可以用<code>decltype(auto)</code>来推导类型。</p><p><code>decltype(auto) p = func()</code></p><p>在<strong>代理模式</strong>中，可以用于完美转发函数返回值。</p><h2 id="标准库中判断类型"><a href="#标准库中判断类型" class="headerlink" title="标准库中判断类型"></a>标准库中判断类型</h2><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>现在的编译器都能自己决定要不要优化<code>inline</code>，程序员现在提供的都是<strong>建议</strong></p><h2 id="一致的函数"><a href="#一致的函数" class="headerlink" title="一致的函数"></a>一致的函数</h2><p><code>std::is_same_v&lt;T1, T2&gt;</code></p><h2 id="C-中的函数指针"><a href="#C-中的函数指针" class="headerlink" title="C++中的函数指针"></a>C++中的函数指针</h2><p>C++中可以不用函数指针，参数中使用<code>void func(int)</code>就可以了，但是这样还有参数类型的限制，可以使用模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_twice</span><span class="hljs-params">(Func func)</span></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>); <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模板可以lambda表达式一起使用，如果有捕获局部变量的话（使用了<strong>闭包</strong>），那么最好模板参数的Func使用常引用，避免不必要的拷贝，不然会把局部变量也拷贝。</p><h3 id="lambda作为返回值"><a href="#lambda作为返回值" class="headerlink" title="lambda作为返回值"></a>lambda作为返回值</h3><p>lambda表达式既可以作为参数，也可以作为返回值。由于lambda永远是<strong>匿名类型</strong>，所以必须将返回值类型声明为<code>auto</code>。</p><h3 id="lambda作为参数，切避免使用模板参数"><a href="#lambda作为参数，切避免使用模板参数" class="headerlink" title="lambda作为参数，切避免使用模板参数"></a>lambda作为参数，切避免使用模板参数</h3><p>lambda作为函数参数必须得使用模板，因为其匿名的特性。但是使用模板就不能分离声明和定义了。</p><p>如果有分离声明和定义的需求，可以使用<code>&lt;functional&gt;</code>中的<code>std::function&lt;ret_type(args)&gt;</code>。这是<strong>类型擦除技术</strong>，使用后把所有通过括号调用的函数变成虚函数。</p><p>性能不如模板，因为调用了虚函数。</p><p>如果是无捕获的lambda，可以传入为函数指针。</p><h3 id="lambda应用"><a href="#lambda应用" class="headerlink" title="lambda应用"></a>lambda应用</h3><p>有时我们要遍历数组查找某个特定值，如果找到了就赋值给变量，然后break。用lambda可以同时实现 break和赋值的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> index = [&amp;] &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">if</span>(arr[i] == tofind)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;();<br></code></pre></td></tr></table></figure><p>类似于上述的局部函数功能，还可以写出匿名递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;dfs, <span class="hljs-type">int</span> index) -&gt; <span class="hljs-type">void</span> &#123;<br><span class="hljs-built_in">dfs</span>(dfs, next);<br>&#125;;<br><span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>注意，返回值类型必须指定。</p><h1 id="4-从汇编角度看编译器优化"><a href="#4-从汇编角度看编译器优化" class="headerlink" title="4. 从汇编角度看编译器优化"></a>4. 从汇编角度看编译器优化</h1><p><a href="https://imgtu.com/i/b8JosH"><img src="https://s4.ax1x.com/2022/03/02/b8JosH.png" alt="b8JosH.png"></a></p><p>x64架构下的寄存器模型，白色部分是32位系统就有的，灰色部分是x64扩充的。</p><p>32位时代只有8个通用寄存器：eax, ecx, edx, ebx, esi, edi, esp, ebp<br>其中esp是堆栈指针寄存器，和函数的调用与返回有关。<br>其中eax是用于保存返回值的寄存器。</p><p>64位时代的x86架构的通用寄存器有图中最左列的16个。其中r8到r15是新增的寄存器，给了汇编程序员更大的空间。64位相比32位机器，除了突破内存4G的限制，也有一定性能优势。比如更多的局部变量可以存到寄存器里，比存在内存里更快。</p><p><a href="https://imgtu.com/i/b8JzQg"><img src="https://s4.ax1x.com/2022/03/02/b8JzQg.png" alt="b8JzQg.png"></a></p><p>x64和x32的通用寄存器会共用低地址位。</p><p>汇编语言大致分2种；Intel模式和AT&amp;T模式。GCC编译出来的<code>.S</code>汇编代码是AT&amp;T模式。开启<code>-O3</code>优化会让编译器从汇编层面进行优化，比如会发现函数传入的参数并不是都用到，就只复制用到的参数；发现参数直接当做返回值返回，就不复制到一个局部变量，而是直接复制到eax寄存器中。</p><p>编译器可以做的优化：</p><ol><li>代数简化：简化代数计算的过程</li><li>常量折叠：先定义两个常量在相加，会被优化成直接将定义常量的字面量相加。</li><li>写个循环从1累加到100，可以被优化到直接给寄存器写入答案</li><li>如果调用了外部函数（声明和定义分离，调用时该文件找不到定义），本来应该是有一个call指令，会被优化为jump指令。</li><li>如果调用了内部函数（调用时直接可以看到定义），且函数体足够简单的话，可以直接优化为内联函数。</li><li>合并写入。在数组两个相邻的位置写入两个32位的int，可以合并为向一个64位的寄存器写入。</li><li>数组清零：手动写for循环对数组清零，会被优化为标准库函数<code>memset</code></li><li>SIMD加速：假设有一个循环将<code>a[i]=i</code>，那么编译器会将循环的步长设为4，每次对4个int进行赋值。如果数组的长度不是4的倍数，会做边界特判，剩余的部分逐个写入。（所以推荐数组大小都是4的整数倍，或者先将数组长度处理为<code>n=n/4*4</code>）</li></ol><p>编译器的优化能力是有限度的，很难对储存在堆上的变量优化（往往是复杂的容器和对象），容易对存储在栈上的优化（往往是简单的数值）。</p><p><code>volatile</code>会禁止编译器优化某个变量的读写操作，防止优化编译器把变量从内存装入CPU寄存器中这样系统总是重新从它所在的内存读取数据，保证了多线程下一定使用内存中的变量，而不会同时使用寄存器和内存中的变量。</p><h2 id="restrict关键字"><a href="#restrict关键字" class="headerlink" title="__restrict关键字"></a>__restrict关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> *c)</span> </span>&#123;<br>*c = *a;<br>*c = *b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很好优化，因为第一条语句时没有用的，但是实际上编译器并不会优化，因为有潜在的风险。加入调用者是这么调用函数的：<code>func(&amp;a, &amp;b, &amp;b)</code>。看起来函数的效果是把第二参数的值赋给第三参数，但是这样调用会导致第一参数赋给了第三参数。，这就是<strong>指针别名现象</strong>。看起来函数的三个参数没有关系，但是实际调用的时候，他们可能指向同一个地址。编译器为了保证正确，不敢去优化这段代码。</p><p>如果我们可以保证这三个参数绝对不会相等，需要加上<code>__restrict</code>关键字，将函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *__restrict a, <span class="hljs-type">int</span> *__restrict b, <span class="hljs-type">int</span> *__restrict c)</span></span>;<br></code></pre></td></tr></table></figure><p>这样编译器就可以放心优化。</p><p>实际上，<code>__restrict</code>只需要加在具有写入访问的指针上，就可以优化成功，同样可以用<code>const</code>来禁止写入访问。因此，所有非<code>const</code>的指针都声明为<code>__restrict</code>就行了。</p><p><code>__restrict</code>是C99标准，但不是C++标准。</p><h2 id="循环中的矢量化"><a href="#循环中的矢量化" class="headerlink" title="循环中的矢量化"></a>循环中的矢量化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">float</span> *a, <span class="hljs-type">float</span> *b)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;<br>a[i] = b[i] + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们认为可以进行SIMD优化，但是编译器却会生成两个版本，因为它担心数组a和b有重叠，这样在改变a的时候也会改变b。因此编译器会对指针进行判断，看两个数组是否重叠，来决定调用哪个版本。这样不仅多了判断的消耗，还让代码膨胀。</p><p>这个问题也可以用<code>__restrict</code>来优化。</p><p>循环是热代码，是编译器优化的重点。</p><ul><li>如果编译器发现循环里有if分支，并且在循环外就可以决定，那么可能会根据不同分支分别生成循环代码，这样不用每次循环都判断一次，而是在循环外完成判断，然后调用对应的代码。</li><li>如果发现循环里有变量是循环外就可以确定的，也会将这个变量的计算在循环外完成。 </li><li>如果循环里调用了外部函数，那么编译器无法优化。因此尽量在循环内调用内部函数。</li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>进行结构体计算时，尽量让结构体的大小是2的整数幂，这样有利于SIMD优化。如果不是，那么结构体无法正好塞进寄存器。</p><p>可以给结构体加<code>char padding[n]</code>这样的内存对齐成员。</p><p>C++11有一个新增语法<code>alignas(n)</code>，可以指定结构体对齐到多少字节</p><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>结构体的内存布局有2种：</p><ul><li>AOS（Array of Struct）：单个对象的属性紧挨着存储在连续的内存上，中间可能有padding来补齐内存。</li><li>SOA（Struct of Array）：对于结构体的每个属性，分别保存在多段连续内存，这样比如有一个循环需要遍历该结构体的部分属性，就不需要访问全部的内存，也不需要跳跃地访问。</li></ul><p>AOS必须要对齐到2的幂才高效，SOA不复合直觉，但是通常高效。</p><h2 id="数学计算优化"><a href="#数学计算优化" class="headerlink" title="数学计算优化"></a>数学计算优化</h2><p>将<code>/2</code>优化为<code>*0.5</code>，因为乘法比除法快。</p><p><code>std::sqrt</code>比全局版本的sqrt性能更好，因为对float和double都进行了重载。其他类似的全局数学函数都是C的遗产，应该尽量使用C++的std提供的数学函数。</p><h2 id="优化方法总结"><a href="#优化方法总结" class="headerlink" title="优化方法总结"></a>优化方法总结</h2><ol><li>函数尽量写在同一个文件里</li><li>避免在for循环内调用外部函数</li><li>非<code>const</code>指针加上<code>__restrict</code>修饰</li><li>试着用SOA取代AOS</li><li>对齐到16或64字节</li><li>简单的代码，不要复杂化，否则编译器面对复杂的代码会直接放弃优化</li><li>试试看<code>#pragma omp simd</code></li><li>循环中不变的常量挪到循环外</li><li>对小循环体用<code>#progma unroll</code>，减小跳转和边界判断的开销比例</li><li><code>-ffast-math</code>和<code>-march=native</code></li></ol><h1 id="5-C-11多线程编程"><a href="#5-C-11多线程编程" class="headerlink" title="5. C++11多线程编程"></a>5. C++11多线程编程</h1><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><p>C语言处理时间依赖<code>&lt;time.h&gt;</code>库，有诸多问题：</p><ol><li>很不灵活。用<code>long</code>时间戳来表示从1970年开始过了多少秒，可以对这个值进行无意义的运算。<code>sleep</code>只能以秒为单位，想要睡眠毫秒级只能用Linux特有的API<code>usleep</code>。</li><li>C语言原始API没有类型区分，导致很容易弄错单位，混淆<strong>时间点</strong>和<strong>时间段</strong>。</li></ol><p>C++11引入时间标准库<code>std::chrono</code>。</p><p>利用C++强类型的特点，明确区分时间点和时间段，区分不同时间单位。<br>比如两个时间点类型相减，得到的就是时间段类型。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>C语言使用pthread库进行多线程编程，但是pthread的函数式编程不符合面向对象思想，C++11开始提供了<code>std::thread</code>，封装了pthread，从语言级别提供了多线程的支持。</p><p><code>std::thread</code>的构造函数的参数可以是<strong>任意</strong>lambda表达式。构造完成后即开始运行。</p><p>线程作为对象，遵循RAII原则，有自己的析构函数，删除了拷贝构造和拷贝赋值函数，提供了移动构造&#x2F;赋值函数。当thread需要被析构时，对应的pthread线程也会被销毁。</p><p><code>detach</code>函数会分离thread对象与pthread线程，使线程的生命周期不再由<code>std::thread</code>对象管理，而是线程退出后自动销毁自己。</p><h3 id="多个线程都结束后才退出"><a href="#多个线程都结束后才退出" class="headerlink" title="多个线程都结束后才退出"></a>多个线程都结束后才退出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br>vector&lt;thread&gt; m_pool;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(thread thr)</span> </span>&#123;<br>m_pool.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">move</span>(thr));<br>&#125;<br>~<span class="hljs-built_in">ThreadPool</span>() &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t: m_pool) t.<span class="hljs-built_in">join</span>();<br>&#125;<br>&#125;;<br>ThreadPool tpool;<br></code></pre></td></tr></table></figure><p>定义一个全局进程池，其声明周期和main函数一致。在main函数结束时，tpool的析构函数会被自动调用，将所有进程都join，这样就可以等待他们全部结束。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><code>std::async</code>接收一个带返回值的lambda，自身返回一个<code>std::future&lt;T&gt;</code>对象。lambda的函数体将在<strong>另一个线程</strong>里执行。</p><p>future的含义是由于这个lambda是异步执行的，所以这个返回值目前还没有，但将来一定会有。调用future的get()方法可以获得返回值。如果还没执行完，则会阻塞在这里。</p><p>wait()函数也有类似的功能，会阻塞等待lambda执行完，但是没有返回值。</p><p><code>wait_for()</code>可以指定一个最长等待时间，返回一个<code>future_status::timeout</code>或<code>future_status::ready</code>表示是否完成。</p><h3 id="推迟执行"><a href="#推迟执行" class="headerlink" title="推迟执行"></a>推迟执行</h3><p><code>std::async</code>的第一个参数可以设为<code>std::launch::deferred</code>，这样lambda就不会另起一个线程来执行，而是<strong>推迟</strong>到get()调用时才在主线程中执行，因此只是函数式编程范式意义上的异步，可以实现<strong>惰性求值</strong>。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>std::async</code>底层实现基于<code>std::promise</code>。如果不想让<code>std::async</code>自动创建线程，想手动创建，可以创建一个<code>std::promise</code>对象。把lambda的返回值处改为调用<code>std::promise</code>的<code>set_value()</code>，然后在主线程里调用<code>get_future()</code>获取其<code>std::future</code>对象，再调用<code>get()</code>。</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p><code>std::mutex</code>有lock()和unlock()两种操作。</p><ul><li>lock：获取锁，如果已经上锁则阻塞等待</li><li>try_lock：尝试上锁，返回bool表示成功或失败</li><li><code>std::timed_mutex</code>的try_lock_for：等到一段时间，超时返回false。</li></ul><h3 id="复合RAII的互斥锁"><a href="#复合RAII的互斥锁" class="headerlink" title="复合RAII的互斥锁"></a>复合RAII的互斥锁</h3><p>如果将互斥锁视为资源，上锁和解锁分别视为获取和释放，那么互斥锁也可以通过class来自动管理。</p><p><code>std::lock_guard</code>就是这样一个工具类，会在构造函数里传入一个<code>std::mutex</code>并调用lock，析构函数里调用unlock。</p><p>这样的类可以用空花括号来规定声明周期。把需要上锁的代码都放在一个花括号内。</p><h4 id="自由度更高的锁"><a href="#自由度更高的锁" class="headerlink" title="自由度更高的锁"></a>自由度更高的锁</h4><p><code>std::lock_guard</code>严格按照生命周期来解锁，但是如果我们需要<strong>提前unlock</strong>，可以使用<code>std::unique_lock</code>，它额外储存了一个<code>flag</code>表示是否已经被释放，在<strong>析构</strong>时检测这个<code>flag</code>，如果已经被释放则不调用unlock。</p><p><code>std::unique_lock</code>的构造函数还可以有一个额外的参数<code>std::defer_lock</code>，如果指定了该参数，那么<code>unique_lock</code>就不会在构造函数时上锁，而是需要<strong>手动上锁</strong>。</p><p><code>std::unique_lock</code>也可以用<code>std::try_to_lock</code>作为构造函数，这样就要调用try_lock()上锁和用<code>owns_lock()</code>判断是否上锁成功。</p><p>如果<code>std::unique_lock</code>或者<code>std::lock_guard</code>传入的参数mutex已经上锁，要在构造函数传入<code>std::adopt_lock</code>，那么依然可以自动解锁。</p><h4 id="概念（鸭子类型）"><a href="#概念（鸭子类型）" class="headerlink" title="概念（鸭子类型）"></a>概念（鸭子类型）</h4><p><code>std::unique_lock</code>也有lock和unlock函数，所以也可以作为<code>std::lock_guard</code>的参数。</p><p>只要具有特定名字的成员函数，就判断一个类是否满足某些功能，这种机制在Python中称为<strong>鸭子类型</strong>，在C++中称为<strong>概念</strong>。比起虚函数和动态多态的接口抽象，concept使实现和接口更加解耦，且没有性能损失。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li><strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li><li><strong>不剥夺条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li><li><strong>请求和保持条件</strong>：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li><strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ol><p>避免死锁最简单的方法：</p><ol><li>永远不要同时持有两个锁。</li><li>保证不同进程上锁的顺序一致。</li><li>使用<code>std::lock(mtx1, mtx2, ...)</code>，可以对多个mutex上锁且保证不会死锁。解锁则按照任意顺序对mutex调用unlock即可。</li></ol><p>就和mutex有RAII版本的<code>std::lock_guard</code>一样，<code>std::lock</code>的RAII版本是 <code>std::scoped_lock</code></p><h3 id="单线程也可以死锁"><a href="#单线程也可以死锁" class="headerlink" title="单线程也可以死锁"></a>单线程也可以死锁</h3><p>死锁不一定发生在并发环境中，单线程中调用了一个会加锁的函数，如果这个函数又调用了自己，那么就会死锁。</p><p>解决这种情况最好是不要在该函数内上锁，并在文档中说明：</p><blockquote><p>该函数不是线程安全的，调用本函数前请先保证mutex已经上锁。</p></blockquote><p>如果代码已经无法改动，可以改用<code>std::recursive_mutex</code>，它会自动判断是不会是在<strong>同一线程</strong>中多次对同一个mutex上锁，如果是则让计数器加一，解锁则减一，减到0才真正解锁。缺点是相比普通的<code>std::mutex</code>有性能损失。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><code>std::shared_mutex</code>是读写锁。</p><p>lock和unlock对应写锁，有修改数据的需求。<code>lock_shared</code>和<code>unlock_shared</code>对应读锁。</p><p><code>std::shared_lock</code>是符合RAII的<code>shared_mutex</code>，不同于<code>unique_lock</code>会调用lock，<code>shared_lock</code>调用的是<code>lock_shared</code>。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span> &#123;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>std::mutex m_mtx;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accessor</span> &#123;<br>MTVector &amp;m_that;<br>        std::unique_lock&lt;std::mutex&gt; m_guard;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Accessor</span>(MTVector &amp;that): <span class="hljs-built_in">m_that</span>(that), <span class="hljs-built_in">m_guard</span>(that.m_mtx) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> m_that.arr.<span class="hljs-built_in">push_back</span>(val);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> m_that.m_arr.<span class="hljs-built_in">size</span>();<br>        &#125;<br>&#125;<br>    <span class="hljs-function">Accessor <span class="hljs-title">access</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> &#123;*<span class="hljs-keyword">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>访问者模式可以很好地为了多线程上锁服务。如果我们自定义了一个线程安全的vector，在每次操作时都加锁，那么有很大的性能开销。</p><p>使用时只需要<code>auto axr = arr.access();</code>。访问者模式分离了数据的存储和访问，在需要访问时只加一次锁。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>等待特定条件，满足后被唤醒。<code>std::condition_variable</code>就是条件变量，必须和<code>std::unique_lock&lt;std::mutex&gt;</code>一起使用。</p><p><code>wait(lck)</code>会使线程陷入等待。<code>notify_one()</code>会唤醒那个陷入等待的线程。 <code>notify_all()</code>会唤醒所有等待该条件变量的线程。</p><p><code>wait(lck, lambda)</code>可以额外指定一个lambda作为参数，只有当返回值为true时才真正唤醒。这样就可以实现生产者-消费者模式。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>一个<code>counter += i</code>在CPU看来会变成3个指令：</p><ol><li>读取counter变量到rax寄存器</li><li>rax寄存器的值加上1</li><li>把rax写入到counter变量</li></ol><p>即使编译器优化为<code>add [counter], 1</code>也没用，因为现代CPU为了高效，会把一条汇编指令拆分为很多微指令，然后可能会重排、乱序执行、并行执行。</p><p>保证操作原子性的暴力解决方案是用mutex上锁，但是mutex是操作系统提供的，太过<strong>重量级</strong>，它会让线程被挂起，从而需要通过系统调用，进入<strong>内核态</strong>，调度到其他线程执行，有很大开销。</p><p>用<code>atomic</code>是更高效，更轻量的，它会被编译器转换为专门的硬件指令。</p><p>CPU在识别到该指令时，会锁住内存总线，放弃乱序执行等优化策略（将该指令视为一个同步点，强制同步之前所有的内存操作），从而保证该操作是<strong>原子</strong>的。</p><p>对于程序员而言，只需要把<code>int</code>改为<code>atomic&lt;int&gt;</code>即可，不需要mutex那样手动控制锁，也更加直观。</p><h3 id="注意运算符"><a href="#注意运算符" class="headerlink" title="注意运算符"></a>注意运算符</h3><p>注意，不是所有的运算都保证原子性，只有<code>+=</code>，<code>-=</code>，<code>&amp;=</code>，<code>|=</code>，<code>^=</code>，<code>++</code>，<code>--</code>可以。</p><p>用<code>=</code>赋值也不能保证原子，需要调用<code>store(val)</code>。<code>exchange</code>会在赋值的同时返回旧值。</p><p>除了调用重载运算符，还可以调用函数。<code>fatch_add</code>不仅能执行加法，还可以返回<strong>旧值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++, CUDA, 并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进行复杂的初始化时为什么要用do-while</title>
    <link href="/Linux-C++/%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8do-while/"/>
    <url>/Linux-C++/%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8do-while/</url>
    
    <content type="html"><![CDATA[<p><code>do-while(0)</code>这样的语句为什么存在？</p><p>在初始化线程池这样复杂的对象时，需要大量的内存分配工作以及其成员的初始化。如果是在C语言中，没有C++的析构函数，那么就应该在某一步出错时停止初始化，并进入销毁阶段。</p><p>为了避免写goto，我们可以将初始化代码放在<code>do-while(0)</code>中，这样可以使用<code>break</code>在任意出错位置跳出循环，进入销毁程序。</p><p><code>do-while(0)</code>应该在宏定义中还有一种使用技巧，以前看到过，待补充，等找到了补上。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode算法复健</title>
    <link href="/algorithm/leetcode/"/>
    <url>/algorithm/leetcode/</url>
    
    <content type="html"><![CDATA[<p>临近求职，面试手撕算法避无可避，不得不将搁置很久的算法题重新捡起来练习。这里算开个新坑，将LeetCode前几页的热门题目重新写一遍，最好能记录每次的用时。</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><p>进阶要求是时间复杂度小于 O(n^2^)，那么应该需要借助排序和二分查找，但是直接排序会打乱下标，因此借助map结构（unordered_map基于哈希表则更快）。</p><p>坑点：遍历的时候一定要先查找<code>nums[i]</code>对应的搭档在不在，然后再将其加入到map中，不然会出现自己和自己相加的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">find</span>(target - nums[i]) != m.<span class="hljs-built_in">end</span>())&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            tmp.<span class="hljs-built_in">push_back</span>(m[target - nums[i]]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        m[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><p>递推的写法比较直白，分成三段：两个链表合并、合并剩余的较长链表、把最后剩余的进位加上。这三段可以简化到一个while循环中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* cur = head;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 || l2 || tmp)&#123;<br>        <span class="hljs-type">int</span> sum = tmp;<br>        sum += l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>        sum += l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>        tmp = sum / <span class="hljs-number">10</span>;<br>        sum %= <span class="hljs-number">10</span>;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(l1)l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l2)l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>用map的数据结构可以很容易地统计词频，用上了之后这就是一道很简单的滑动窗口问题。</p><p>遍历时每次都强制把刚遇到的字符<code>s[i]</code>加入到字串中，然后如果该字符出现了2次，则持续右移<code>l</code>，直到遇到一个和<code>s[i]</code>相同的字符，将<code>s[i]</code>的频率减到1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        cnt[s[i]]++;<br>        len++;<br>        <span class="hljs-keyword">while</span>(cnt[s[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>            cnt[s[l++]]--;<br>            len--;<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h1><p>比较难的二分查找，边界处理很繁琐。数组元素数量是固定的，可以把两个有序的数组看做一个整体，由一个折现分别将X和Y分为两部分，左半部分和右半部分数量相等（或者左半边多一个，多出的那个即为中位数），规定左半边的所有数小于右半边的所有数。我们定义i分隔了X，j分隔了Y，由于左半边数量等于右半边，则只要i确定那么j也确定，因此对i进行二分查找。</p><p>如代码中注释所画，比较<code>X[i-1]</code>和<code>Y[j]</code>的大小关系即可，并不在乎<code>X[i-1]</code>和<code>Y[j-1]</code>的大小关系，只要i和j数量关系维持住即可，因为<code>Y[j-1]</code>一定比<code>Y[j]</code>小。由于X长度小于Y，所以只移动i是安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; X, vector&lt;<span class="hljs-type">int</span>&gt;&amp; Y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(X.<span class="hljs-built_in">size</span>() &gt; Y.<span class="hljs-built_in">size</span>())<span class="hljs-built_in">swap</span>(X, Y);  <span class="hljs-comment">//保证X长度小于Y</span><br>    <span class="hljs-type">int</span> sizeX = X.<span class="hljs-built_in">size</span>(), sizeY = Y.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> leftSize = (sizeX + sizeY + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">//中位数一定在左边</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = sizeX, i, j;<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-comment">/*  X[i-1] | X[i]</span><br><span class="hljs-comment">        *           --</span><br><span class="hljs-comment">        *      Y[j-1] | Y[j]</span><br><span class="hljs-comment">        */</span><br>        i = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, j = leftSize - i;<br>        <span class="hljs-keyword">if</span>(X[i<span class="hljs-number">-1</span>] &gt; Y[j]) r = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l = i;<br>    &#125;<br>    i = l, j = leftSize - i;<br>    <span class="hljs-comment">//如果i和j取到了边界，那么说明这两个数组没有交叉，要用int的极值排除边界的干扰</span><br>    <span class="hljs-type">int</span> XLeftMax = i == <span class="hljs-number">0</span> ? INT_MIN : X[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-type">int</span> XRightMin = i == sizeX ? INT_MAX : X[i];<br>    <span class="hljs-type">int</span> YLeftMax = j == <span class="hljs-number">0</span> ? INT_MIN : Y[j<span class="hljs-number">-1</span>];<br>    <span class="hljs-type">int</span> YRightMin = j == sizeY ? INT_MAX : Y[j];<br>    <span class="hljs-keyword">if</span>((sizeX + sizeY) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(XLeftMax, YLeftMax); <span class="hljs-comment">//如果是奇数个，那么中位数只有一个，一定是这两者中较大的</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 如果是偶数个，那么中位数由两个数算出：左区间最大值和右区间最小值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>((<span class="hljs-built_in">max</span>(XLeftMax, YLeftMax) + <span class="hljs-built_in">min</span>(XRightMin, YRightMin))) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h1><p><code>n</code>声明为<code>long</code>保证足够的空间，然后正常将其反转。最后判断强转为int后是否还等于自身，如果不是则说明溢出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        n = n * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-built_in">int</span>(n) ? <span class="hljs-built_in">int</span>(n) : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用</title>
    <link href="/Linux-C++/IO%E5%A4%8D%E7%94%A8/"/>
    <url>/Linux-C++/IO%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>返回值：就绪（可读、可写、异常）的文件描述符的总数。</p><ul><li><p><code>nfds</code>是指定被监听的文件描述符的总数，通常被设置为被监听的所有文件描述符中的最大值+1，因文件描述符从0开始计算。也就是说其实这个参数不一定代表数量。</p></li><li><p>后三个参数分别对应可读、可写、异常三种事件的文件描述符集合，类型为<code>fd_set</code>，内部是一个数组，总bit位受到<code>FD_SETSIZE</code>限制，有上限。这个数组的每一位表示对某个fd监听特定类型的事件。假设现在fd_set的数组一共8bit，我们要监听fd&#x3D;3的读事件，那么readfds内的数组为0000,1000。</p><p>  注意，这三个参数即是传入参数，也是传出参数。传入时表达用户希望监听的fd，穿出时表达就绪的fd。确实有发生对应事件的fd对应位置还是1，没有事件的bit位会被清0。</p></li><li><p><code>timeout</code>等待时间，null为阻塞等待。</p></li></ul><p>网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。</p><p><strong>什么是带外数据</strong>？</p><p>带外数据(out—of—band data)，有时也称为加速数据(expedited data)，是指连接双方中的一方发生重要事情，想要迅速地通知对方。这种通知在已经排队等待发送的任何“普通”(有时称为“带内”)数据之前发送。</p><p>带外数据设计为比普通数据有更高的优先级。</p><p>带外数据是映射到现有的连接中的，而不是在客户机和服务器间再用一个连接。</p><p>socket收到普通数据和带外数据都将使select返回，但是前者处于可读状态，后者处于异常装填。</p><p>以下是一个典型的基于select的服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//这两部是非常重要的，不可缺少的，缺少了有可能导致状态不会更新</span><br>  <span class="hljs-built_in">FD_ZERO</span>(&amp;fdsr); <span class="hljs-comment">//初始清0</span><br>  <span class="hljs-built_in">FD_SET</span>(sock_fd, &amp;fdsr); <span class="hljs-comment">//将监听连接fd加入集合</span><br><br>  <span class="hljs-comment">//将所有的连接全部加到这个这个集合中，可以监测客户端是否有数据到来</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; MAXCLINE; i++) <span class="hljs-built_in">FD_SET</span>(fd[i],&amp;fdsr);<br><br>  <span class="hljs-comment">//如果文件描述符中有连接请求 会做相应的处理，实现I/O的复用 多用户的连接通讯</span><br>  ret = <span class="hljs-built_in">select</span>(maxsock + <span class="hljs-number">1</span>,&amp;fdsr,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;tv);<br>  <span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//没有找到有效的连接 失败</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret ==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 指定的时间到，</span><br>  <span class="hljs-comment">//下面这个循环是非常必要的，因为你并不知道是哪个连接发过来的数据，所以只有一个一个去找。</span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;conn_amount;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(fd[i],&amp;fdsr))&#123;<br>      ret = <span class="hljs-built_in">recv</span>(fd[i],buf,<span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//如果客户端主动断开连接，会进行四次挥手，会出发一个信号，此时相应的套接字会有数据返回，告诉select，我的客户断开了，你返回-1</span><br><br>      <span class="hljs-keyword">if</span>(ret &lt;=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//客户端连接关闭，清除文件描述符集中的相应的位</span><br>      <span class="hljs-built_in">close</span>(fd[i]); <span class="hljs-built_in">FD_CLR</span>(fd[i],&amp;fdsr);<br>      fd[i]=<span class="hljs-number">0</span>; conn_amount--;<br>      &#125;<span class="hljs-keyword">else</span> &#123;&#125;<span class="hljs-comment">//否则有相应的数据发送过来 ，进行相应的处理</span><br>    &#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(sock_fd,&amp;fdsr))<span class="hljs-comment">//有用户连接</span><br>      new_fd = <span class="hljs-built_in">accept</span>(sock_fd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr,&amp;sin_size);<br><br>    <span class="hljs-comment">//添加新的fd 到数组中 判断有效的连接数是否小于最大的连接数，如果小于的话，就把新的连接套接字加入集合</span><br>    <span class="hljs-keyword">if</span>(conn_amount &lt; MAXCLINE)&#123;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; MAXCLINE; i++)&#123;<br><span class="hljs-keyword">if</span>(fd[i]==<span class="hljs-number">0</span>)&#123;<br>fd[i] = new_fd;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>conn_amount++;<br><span class="hljs-keyword">if</span>(new_fd &gt; maxsock) maxsock = new_fd;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 超过连接数量</span><br><span class="hljs-built_in">close</span>(new_fd);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：跨平台</p><p>缺点：</p><ul><li><p>监听上限受文件描述符限制，最大1024（这个因机器而异）</p></li><li><p>需要检测满足条件的fd，只能通过轮询和检查来判断事件，而且只能支持三种事件</p></li><li><p>每次监听fd的标志会被清0（如果没有事件就绪），需要重新设置</p></li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br>    <span class="hljs-type">int</span>  fd;     <span class="hljs-comment">/* file descriptor */</span><br>    <span class="hljs-type">short</span> events;   <span class="hljs-comment">/* requested events */</span><br>    <span class="hljs-type">short</span> revents;  <span class="hljs-comment">/* returned events */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>传入一个struct pollfd数组，指定其大小。结构体中包含文件描述符、传入的监听事件和传出的已触发事件。<code>nfds</code>指定被监听事件集合<code>fds</code>的大小，<code>timeout</code>指定超时值，单位是毫秒，-1时阻塞，0时立刻返回。</p><p>返回值是有多少fd有事件。</p><p>需要做轮询，将revent与特定事件做与运算，来判断事件是否发生。</p><p>以下是一个典型服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 设置监听连接的soclet</span><br>fds[<span class="hljs-number">0</span>].fd = listenfd;<br>fds[<span class="hljs-number">0</span>].events = POLLIN | POLLERR;<br>fds[<span class="hljs-number">0</span>].revents = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )&#123;<br>  ret = <span class="hljs-built_in">poll</span>( fds, user_counter+<span class="hljs-number">1</span>, <span class="hljs-number">-1</span> );<br>  <span class="hljs-keyword">if</span> ( ret &lt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; user_counter+<span class="hljs-number">1</span>; ++i )&#123;<br>    <span class="hljs-keyword">if</span>( ( fds[i].fd == listenfd ) &amp;&amp; ( fds[i].revents &amp; POLLIN ) )&#123; <span class="hljs-comment">// 如果是有新用户连接</span><br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>      <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>( client_address );<br>      <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( <span class="hljs-keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );<br>      <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span>( user_counter &gt;= USER_LIMIT )&#123;&#125;<span class="hljs-comment">//用户连接数超出上限</span><br>      user_counter++;<br>      <span class="hljs-comment">// 设置新用户的socket属性，加入fds数组</span><br>      users[connfd].address = client_address;<br>      <span class="hljs-built_in">setnonblocking</span>( connfd );<br>      fds[user_counter].fd = connfd;<br>      fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;<br>      fds[user_counter].revents = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLERR )&#123;&#125;<span class="hljs-comment">//遇到异常</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLRDHUP )&#123;<span class="hljs-comment">//用户断连</span><br>      users[fds[i].fd] = users[fds[user_counter].fd];<br>      <span class="hljs-built_in">close</span>( fds[i].fd );<br>      fds[i] = fds[user_counter];<br>      i--; user_counter--;<br>      <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;a client left\n&quot;</span> );<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLIN )&#123;<span class="hljs-comment">//用户发送数据到服务端</span><br>      <span class="hljs-type">int</span> connfd = fds[i].fd;<br>      <span class="hljs-built_in">memset</span>( users[connfd].buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>      ret = <span class="hljs-built_in">recv</span>( connfd, users[connfd].buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>      <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[connfd].buf, connfd );<br>      <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-keyword">if</span>( errno != EAGAIN )&#123;&#125;<span class="hljs-comment">//出错，与用户断连，关闭socket</span><br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )&#123;&#125;<span class="hljs-comment">//理论上不会到达这个分支</span><br>      <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= user_counter; ++j )&#123;<br>          <span class="hljs-keyword">if</span>( fds[j].fd == connfd )<span class="hljs-keyword">continue</span>;<br>          <span class="hljs-comment">//这段代码怪怪的</span><br>          fds[j].events |= ~POLLIN;<span class="hljs-comment">//这一步之后读状态不变，其他全部为1</span><br>          fds[j].events |= POLLOUT;<span class="hljs-comment">//在上一步基础上加上写事件，其他全部不变</span><br>          users[fds[j].fd].write_buf = users[connfd].buf;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLOUT )&#123;<span class="hljs-comment">//用户有写事件，表示服务器需要向该客户发送数据</span><br>      <span class="hljs-type">int</span> connfd = fds[i].fd;<br>      <span class="hljs-keyword">if</span>( ! users[connfd].write_buf )<span class="hljs-keyword">continue</span>;<br>      ret = <span class="hljs-built_in">send</span>( connfd, users[connfd].write_buf, <span class="hljs-built_in">strlen</span>( users[connfd].write_buf ), <span class="hljs-number">0</span> );<br>      users[connfd].write_buf = <span class="hljs-literal">NULL</span>;<br>      fds[i].events |= ~POLLOUT;<br>      fds[i].events |= POLLIN;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：自带数据结构，可以拓展监听上限，不像select需要结束fd_set（无法修改数组长度，只能1024，内核限制）；可以将监听事件集合和返回事件集合分离。</p><p>缺点：专属Linux，不能跨平台；无法直接满足监听事件的文件描述符。</p><h3 id="修改监听fd的1024上限"><a href="#修改监听fd的1024上限" class="headerlink" title="修改监听fd的1024上限"></a>修改监听fd的1024上限</h3><p> <code>cat /proc/sys/fs/file-max</code>这个命令可以查看当前计算机所能打开的最大文件个数。受硬件限制。</p><p><code>ulimit -a</code>查看当前用户下的进程，默认打开文件描述符的个数。默认为1024。</p><p><code>sudo vi /etc/security/limits.comf</code>来修改，软上限可以用命令修改，不能超过硬上限。硬上限只能在文件中修改。修改后需要重新登录来生效。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>Linux特有的IO复用函数。</p><p>实现和使用与select和poll有很大差异。首先，epoll使用一组函数来完成任务。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而避免像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用额外一个文件描述符，来唯一标识内核中的事件表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create1</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span></span>;返回值是一个epoll文件描述符（句柄），指向一个红黑树的根节点，每个节点都是一个要监听的fd。<br></code></pre></td></tr></table></figure><p>size是预计需要监听的节点数量，仅供内核参考，由内核创建红黑树，可以动态调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> &#123;<br>    <span class="hljs-type">uint32_t</span>     events;      <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data;        <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> &#123;<br>    <span class="hljs-type">void</span>        *ptr;<br>    <span class="hljs-type">int</span>          fd; <span class="hljs-comment">//联合体中fd用得最多</span><br>    <span class="hljs-type">uint32_t</span>     u32;<br>    <span class="hljs-type">uint64_t</span>     u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br></code></pre></td></tr></table></figure><p>该函数用来操作epoll的内核事件表。</p><ul><li><code>epfd</code>：epoll文件描述符</li><li><code>op</code>：操作，增改删，<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code>、<code>EPOLL_CTL_DEL</code></li><li><code>fd</code>：待监听的fd</li><li><code>event</code>：<code>struct epoll_event</code>的指针。<ul><li><code>events</code>：<code>EPOLLIN</code>、<code>EPOLLOUT</code>、<code>EPOLLERR</code></li><li><code>data</code>：<code>union</code>类型，<code>ptr</code>是泛型指针，可以是自定义的结构体（里面包含回调函数），<code>fd</code>是对应监听事件。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_pwait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *sigmask)</span></span>;<br></code></pre></td></tr></table></figure><p>主要接口，它在一段超过时间内等待一组文件描述符上的事件。</p><ul><li><code>events</code>：注意，<code>events</code>表示这是个数组，用来保存内核得到的事件的集合。<strong>传出参数</strong>，传出满足监听条件的fd。</li><li><code>maxevents</code>：数组元素的总个数，<code>events</code>的长度。</li></ul><p>返回满足监听的总个数，可以用作循环上限。<code>events</code>一定都是满足监听的事件，可以直接循环处理。与poll的对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//如何索引poll返回的就绪文件描述符</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br><span class="hljs-comment">//必须遍历所有已注册文件描述符并找到的其中的就绪者</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &gt; MAX_EVENT_NUMBER; ++i)&#123;<br>  <span class="hljs-keyword">if</span>(fds[i].revents &amp; POLLIN)&#123;<br>    <span class="hljs-type">int</span> sockfd = fds[i].fd;<br>    <span class="hljs-comment">//处理事件</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//如何索引epoll返回的就绪文件描述符</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENTS_NUMBER, <span class="hljs-number">-1</span>);<br><span class="hljs-comment">//仅遍历就绪的ret个文件描述符</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)&#123;<br>  <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>  <span class="hljs-comment">//直接处理事件，不需要再判断是否就绪</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适合使用场景：大量并发连接，但是只有少量活跃连接。</p><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>epoll有两种事件模型，<strong>默认是水平触发</strong>。修改为边缘触发则在<code>epoll_ctl</code>的参数<code>event.events</code>中用或运算加上<code>EPOLLET</code>。</p><ol><li><p>边缘触发（Edge Triggered，ET）：epoll在处理事件时，如果没有将缓冲区读取完，或者在处理过程中产生了新的触发，在ET模式下是不会触发的，只有下一次触发时再继续处理。</p></li><li><p>水平触发（Level Triggered，LT）</p></li></ol><p>用通信的知识来理解，假如只有电压发生变化才会产生触发，那么就是边缘触发。如果电压维持高水平，但是依然会触发，那么就是水平触发。</p><p>LT模式可应用与阻塞和非阻塞的文件描述符。ET是<strong>高速模式</strong>，只能用于非阻塞（给fd设置<code>O_NONBLOCK</code>）。</p><p>缺点：不能跨平台，只支持Linux（Unix也不行）</p><h3 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h3><p>ET模式+非阻塞模式+回调函数<code>void* ptr</code></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板与泛型</title>
    <link href="/Linux-C++/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B/"/>
    <url>/Linux-C++/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板定义以关键词<code>template</code>开始，后跟一个<strong>模板参数列表</strong>，由若干个用逗号分隔的<strong>模板参数</strong>组成。编译器会推断模板参数的类型，为不同的类型实例化出不同的版本。</p><p><strong>类型参数</strong>前必须使用关键词<code>class</code>或<code>typename</code>。在模板参数列表中这两者等价，<code>typename</code>更加贴切模板参数的含义（并且不暗示类型必须是类），是在<code>class</code>之后引入的。</p><p>模板中还可以定义<strong>非类型参数</strong>，表示一个特定类型的参数，因此模板中应该用类型名而非<code>typename</code>。这些值必须是<strong>常量表达式</strong>，因为在编译阶段就需要被替换，来源为用户指定或编译器推断。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> N, <span class="hljs-type">unsigned</span> M&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>);<br></code></pre></td></tr></table></figure><p>在调用时，编译器会使用<strong>字面值常量</strong>的大小来代替N和M。    </p><p>在<strong>模板参数列表</strong>后可以加<code>inline</code>或<code>constexpr</code>。</p><p>从上述例子中可以看到2个编写泛型代码的重要原则：</p><ul><li>模板中的函数参数是<code>const</code>引用：这样可以同时支持允许拷贝和不允许拷贝的版本，而且避免拷贝可以减少浪费。</li><li>函数体中的判断条件仅使用<code>&lt;</code>运算：因为模板是<strong>类型无关的</strong>，只对参数的所支持的操作由要求。这一点比较接近Python的鸭子类型或者Go的接口设计，他们想传达的想法都是用类的行为来区分类型，而不是类的名字和继承结构。限制模板使用的运算类型，是为了让该模板支持更多的类型。&#x3D;&#x3D;模板程序应该尽量减少对实参类型的要求。&#x3D;&#x3D;</li></ul><h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>在调用函数时，编译器只需要知道函数的声明；使用类类型的对象时，类定义是可用的，但是函数成员的定义可以不用。因此，我们将类定义和函数声明放在<strong>头文件</strong>，普通函数和类成员函数的定义放在<strong>源文件</strong>。</p><p>但是模板不同，编译器需要掌握函数模板或类模板成员函数的定义，才能生成一个实例化版本。因此模板的头文件中通常既包括声明也包括定义。</p><p>编译器可能会在模板编译的三个阶段报错：</p><ul><li>编译模板本身：只能检查语法错误，如忘记分号、变量名拼错</li><li>编译器遇到模板使用：对于函数模板调用，可以检查实参类型是否正确，参数类型是否匹配；对于类模板，检查模板实参的数量。总之查错有限。</li><li>模板实例化：直到该阶段才能发现类型相关的错误。</li></ul><p>由于模板是类型无关的，因此编译器会检查实参是否支持模板要求的操作，但是这些都只能等实例化后才能发现。</p><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>与函数模板不同，编译器不能为类模板推断模板参数类型。需要用户在模板名后的尖括号中提供额外信息，也就是<strong>显式模板实参</strong>，他们会被绑定到模板参数。类似于使用容器时指定的元素类型。</p><p>默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化。</p><p>在类模板的作用域内，可以省略模板类型，<code>A&amp;</code>等同于<code>A&lt;T&gt;&amp;</code>，因为在该作用域内编译器可以自动替换。可以直接使用模板名<code>T</code>而不必指定实参。<br>如果是在类模板之外，则一定要提供模板实参，才能进入对应模板的作用域。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类模板可以和另一个类模板，普通类，模板实参成为友元。可以和特定类型的类模板做友元，或者类模板的任何实例为友元。</p><h3 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h3><p>给定了模板实参的类模板会被实例化为一个类，可以用<code>typedef</code>来指定别名，但是<code>typedef</code>无法为模板创建别名。需要使用<code>using</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;<br></code></pre></td></tr></table></figure><p>接下来，<code>twin&lt;T&gt;</code>就等同于<code>pair&lt;T,T&gt;</code>。</p><p>在使用模板类型别名时，可以固定某些模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> partNo = pair&lt;T, <span class="hljs-type">unsigned</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h3><p>对于每一个T来说，模板都会生成一个不同的类。类模板的每个static成员必须<strong>有且仅有</strong>一个定义，但是类模板的每个实例（对于每个T）都有一个独有的static成员。在访问时，必须指定它所在的域。</p><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>模板参数会覆盖外层的同名变量，并且不允许重用（重新定义），也不允许在同一个模板参数列表中重复出现。</p><p>和函数声明类似，模板声明不在乎模板参数的名字，只在乎数量和种类（类型或非类型）。</p><p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p><p>模板参数可以有默认值，如果全都使用默认值，使用模板时也需要加上空的尖括号。</p><h3 id="类的类型成员"><a href="#类的类型成员" class="headerlink" title="类的类型成员"></a>类的类型成员</h3><p>对于一个类而言，使用作用域运算符<code>::</code>可以访问其static成员和类型成员，因为编译器知道该类的明确定义，知道访问的是一个数据成员还是类型。但是对于模板而言，如果遇到<code>T::size_type *p</code>的代码，编译器不知道是用T类型中的size_type类型定义一个指针，还是说用T中的size_type成员与p相乘。</p><p>因此，默认情况下C++假定通过<code>::</code>访问的是名字而不是类型。如果是类型，需要用<code>typename</code>显式指定，而且必须是<code>typename</code>而不能是<code>class</code>。<code>typename T::value_type</code>可以获取类型。</p><h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>一个类可以包含函数模板，这样的成员称为<strong>成员模板</strong>。不能是虚函数。</p><p>对于模板类的成员模板，需要给定模板类的模板参数，成员模板的参数通过参数类型推断。</p><h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有<code>const</code>转换和数组或函数到指针的转换。如果参数类型不是模板参数，则实参可以进行正常的类型转换。</p><p>对于函数模板而言，一般不需要用尖括号，因为可以通过实参类型来推断模板参数。但是有时我们需要用模板参数指定返回值类型，这时就无从推断了，需要提供<strong>显式模板实参</strong>，调用这样的函数需要尖括号。</p><p>有时返回值类型只能在运行时决定，比如一个模板函数传入一个容器的迭代器，返回容器内的元素的类型，只能在运行时通过<code>decltype</code>得知类型，那么就在返回值类型处先写<code>auto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(T a)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*p)</span></span>&#123;  <br>  <span class="hljs-keyword">return</span> *p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>用函数模板初始化一个函数指针，或者为函数指针赋值时，编译器用指针的类型来推断模板实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span><br><span class="hljs-built_in">int</span> (*pf1)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;) = compare;<br></code></pre></td></tr></table></figure><p>如果一些重载函数可以接收同个函数模板的不同实例，那么传入模板时需要用尖括号指定模板实参，否则编译器无法推断。</p><h3 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h3><p>将一个左值（例如<code>int i</code>）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如<code>T&amp;&amp;</code>）时，编译器推断模板类型参数为实参的<strong>左值引用类型</strong>。</p><p>中间跳过一大段解释</p><p>如果一个函数参数是指向模板参数类型的右值引用（如<code>T&amp;&amp;</code>），则可以传递给它任意类型的实参。如果将一个左值传递进去，则函数参数被实例化为一个普通的左值引用（<code>T&amp;</code>）。</p><p>![image-20211230194339414](&#x2F;Users&#x2F;jackzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211230194339414.png)</p><p>16.2.5 非常难</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>16.2.7跳过</p><p>关于<code>std::forward</code>，用来保持实参的细节。</p><h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>出现在模板参数内的叫<strong>模板参数包</strong>，函数参数内的叫<strong>函数参数包</strong>。用<code>...</code>来表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></td></tr></table></figure><p>用<code>sizeof</code>运算符可以知道参数数量，<code>sizeof...(Args)</code>。</p><p>与<code>initializer_list</code>只能接收相同类型的参数不同，可变参数可以接收不同类型的参数。</p><p>可变参数函数通常是递归的，每次递归处理一个参数，然后用剩余实参调用自身。为了能终止递归，还需要定义一个非可变参数的版本。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/Linux-C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/Linux-C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>内存管理</h1><ul><li>静态内存：局部静态变量，类静态成员，全局变量</li><li>栈内存：函数内局部变量</li><li>堆（自由空间）：动态分配的内存（new和delete）</li></ul><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><code>new</code>会返回一个指针，指向动态分配的内存。</p><p>如果<code>new</code>后面只跟了类型，如<code>new int</code>，那么对象是<strong>default initialized</strong>：内置类型和组合类型的值是<strong>未定义的</strong>，类类型使用<strong>默认构造函数</strong>。</p><p>如果需要<strong>value initialized</strong>，需要在类型后加上空括号，如<code>new int()</code>。因此，应该<strong>尽量使用</strong>带括号的版本，因为类类型无论如何都会调用默认构造函数，但是让内置类型的值未定义是<strong>危险</strong>的。</p><p>对于const，必须要让对象被初始化过，因此内置类型必须有括号。尽管const对象不能修改，但是其本身是可以销毁的。</p><p>编译器可以用initializer的类型来推断应该new什么类型：<code>auto p = new auto(obj);</code></p><p>如果无法分配内存，new会抛出<code>bad_alloc</code>异常。如果想要忽略异常，可以使用<code>placement new</code>：<code>int *p = new (nothrow) int;</code>。这种表达式相当于传递了参数给<code>new</code>，让其在分配失败时返回一个<code>nullptr</code>。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>如果想要new很多对象，就要在new时加上中括号：<code>int *p = new int[get_size()];</code>。还可以使用别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> arrT;<br></code></pre></td></tr></table></figure><p>尽管叫动态数组，但是其实new出来的不是数组类型，仅仅只是指向一块连续内存的头部的指针，而不是像array类型那样，数组大小也是类型的一部分。</p><p>动态数组的初始化情况和new一个对象是一样的，如果不带括号的话，内置类型会是未定义。除了带括号和不带括号两种初始化，还可以用列表初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure><p>当列表内的元素不够时，剩下的元素会值初始化；如果元素过多，则new失败，抛出<code>bad_array_new_length</code>异常。</p><p>动态数组的长度可以为0，不会报错，得到的指针类似于<code>end</code>迭代器，本身不应该解引用。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>能用来<code>delete</code>的必须是能<code>new</code>出来的东西，也就是指向动态分配内存的指针或者<code>nullptr</code>。<code>delete</code>一个普通的指针，或者把同一个动态分配指针<code>delete</code>2次，都是<strong>未定义</strong>操作，编译器不会察觉。</p><p>返回动态分配指针的函数，相当于把<code>delete</code>的职责交给了调用者。</p><p>对于动态数组的<code>delete</code>，必须要带上<code>delete [] p;</code>，否则只有数组的第一个会被delete。</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>几种常见的使用<code>new</code>的错误：</p><ol><li>忘记<code>delete</code>，也就是俗称的“内存泄漏”</li><li>在<code>delete</code>后仍然使用</li><li><code>delete</code>同一块内存2次。</li></ol><p>这些问题都可以通过使用<strong>智能指针</strong>解决。</p><h3 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h3><p>当<code>delete</code>一个指针后，指针已经失效了，但是在很多机器中，指针仍然保存了地址，哪怕那块地址已经被释放了，这样就成了<strong>空悬指针</strong>，这种指针的隐患等同于为<strong>未初始化</strong>的指针。</p><h3 id="多指针指向同一处的问题"><a href="#多指针指向同一处的问题" class="headerlink" title="多指针指向同一处的问题"></a>多指针指向同一处的问题</h3><p>动态内存的一个基本问题就是多个指针指向相同的内存。任意其中一个<code>delete</code>之后，其他指针都指向了一片非法的内存。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>的智能之处在于无论是赋值还是复制，每个<code>shared_ptr</code>内部都会有个引用计数（计数器），记录了还有多少个其他<code>shared_ptr</code>指向相同的对象。当一个对象没有被引用时，<code>shared_ptr</code>就会自动销毁该对象（调用该对象的析构函数）。</p><p>当一个局部的<code>shared_ptr</code>离开作用域时就会被销毁，相应的计数器就会减一。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>shared_ptr</code>有三种获得方法：</p><ul><li><code>make_shared&lt;T&gt;(args)</code>会使用参数自动创建一个对象，并返回一个指向它的指针。这是最<strong>安全</strong>的方法。</li><li><code>shared_ptr&lt;T&gt;p(q)</code>用另一个<code>shared_ptr</code>来构造一个指针</li><li><code>p = q</code> 用另一个<code>shared_ptr</code>来赋值</li></ul><p>可以用<code>auto</code>来简化语句。</p><p><code>shared_ptr&lt;T&gt; p1;</code>这样默认初始化得到的智能指针，内部持有的是<code>nullptr</code>。<strong>注意</strong>：智能指针内部持有的是<code>T*</code>的指针。</p><p>与动态内存结合：<code>shared_ptr&lt;int&gt; p(new int(42));</code>。我们不能<strong>隐式</strong>地将普通指针变成智能指针，而是必须用初始化。</p><p>由于智能指针默认用<code>delete</code>来释放管理的对象，因此用来初始化智能指针的指针必须是<strong>动态分配</strong>的。如果我们想要让它指向其他类型的资源，则需要传入自定义的<code>deleter</code>来规定资源如何安全释放。</p><h3 id="不要混用普通指针和智能指针"><a href="#不要混用普通指针和智能指针" class="headerlink" title="不要混用普通指针和智能指针"></a>不要混用普通指针和智能指针</h3><p>以下是我的猜测：智能指针如果使用<code>make_shared</code>方法创建，那么内部是调用了<code>new</code>的。如果是用构造器的话，会判断初始器的类型，从而有不同的操作。</p><p><code>shared_ptr</code>生效的前提是不能让引用计数失效。<code>shared_ptr</code>能够正确地协调对象的析构，仅限于其自身的拷贝。</p><p>之所以推荐使用<code>make_shared</code>而不是先new在初始化，就是因为希望将分配内存和绑定操作合并，这样就可以避免无意中将一块内存绑定到多个<strong>独立创建</strong>（不是拷贝）的<code>shared_ptr</code>上。如果先new了一块内存，再用它来独立创建2个<code>shared_ptr</code>，每个智能指针都有独立的引用计数，且都为1。无论那个先被释放，都会导致第二个非法。</p><p>还有种情况，我们分别给一个普通指针和智能指针用new出来的指针赋值（或初始化），然后加入智能指针先失效，那么就会自动释放动态分配内存，导致普通指针称为空悬指针。当我们把一块内存交个智能指针时，等于我们把内存管理的职责分给了智能指针，那么接下来就不要再使用普通指针指向那块区域了。</p><h3 id="不要用get去创建别的智能指针"><a href="#不要用get去创建别的智能指针" class="headerlink" title="不要用get去创建别的智能指针"></a>不要用get去创建别的智能指针</h3><p><code>get()</code>成员可以得到内置指针，指向智能指针管理的成员。如果我们拿着这个内置指针去创建另一个智能指针，然后这个智能指针销毁了，就会把内存释放，最开始的调用get的智能指针就指向了非法空间了。</p><h3 id="常见错误-1"><a href="#常见错误-1" class="headerlink" title="常见错误"></a>常见错误</h3><ol><li>不要用相同的内置指针初始化（或reset）多个智能指针</li><li>不要<code>delete</code> <code>get()</code>返回的指针</li><li>不要使用<code>get()</code>初始化或<code>reset</code>另一个智能指针</li><li>如果使用<code>get()</code>返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变得无效了。</li><li>如果你使用智能指针管理的资源不是new分配的内存，记住传递个它一个删除器</li></ol><p>删除器简单来说就是一个函数，所谓初始化参数，规定了该如何释放内存。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>release</code>会返回<code>unique_ptr</code>保存的指针，并把<code>unique_ptr</code>设为<code>null</code>。注意，返回的指针相当于把内存管理的任务交给了程序员。</p><p>不支持拷贝或赋值，因为要保证唯一性。仅有一个例外：当<code>unique_ptr</code>马上要被销毁时。典型的场景是作为函数的局部变量返回的时候，编译器可以得知这个对象马上就要被销毁了，所以允许拷贝。</p><p><code>auto_ptr</code>是早期标准库的产物，它只包含部分<code>unique_ptr</code>的特性，尤其是无法再容器中保存<code>auto_ptr</code>，也无法作为返回值。因此，尽管它还是标准库的内容，编程时应尽量使用<code>unique_ptr</code>。</p><p>不同于<code>shared_ptr</code>，<code>unique_ptr</code>的删除器不因要作为构造器的参数，还要在尖括号中写出类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fcn)</span></span>;<br><span class="hljs-function">unique_ptr&lt;connection, <span class="hljs-title">decltype</span><span class="hljs-params">(end_connection)</span>*&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br></code></pre></td></tr></table></figure><p>注意，删除器的类型是函数指针，所以还加上*。</p><h3 id="用智能指针管理动态数组"><a href="#用智能指针管理动态数组" class="headerlink" title="用智能指针管理动态数组"></a>用智能指针管理动态数组</h3><p>标准库提供了<code>unique_ptr</code>的版本来管理动态数组，提供了比其他两种智能指针更方便的使用，可以直接用下标访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[])</span></span>;<br></code></pre></td></tr></table></figure><p>其他两种指针需要先解引用，而且必须传入删除器。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr</code>并不控制对象的声明周期，它只是指向<code>shared_ptr</code>所管理的对象，且不会改变引用计数。因此，<code>weak_ptr</code>在使用时并不知道指向的对象是否还存在，因此在访问时，需要使用<code>lock</code>。如果对象存在，则返回一个<code>shared_ptr</code>，如果不存在则返回一个null的<code>shared_ptr</code>。经典用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(shared_ptr&lt;<span class="hljs-type">int</span>&gt; np = wp.<span class="hljs-built_in">lock</span>())&#123; ... &#125;<span class="hljs-comment">//如果对象不存在，无法进入if</span><br></code></pre></td></tr></table></figure><h1 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h1><p><code>new</code>以及依赖<code>new</code>的智能指针总是将内存分配和构造对象的操作绑定在一起。这样是很方便，但是在某些情况下会导致浪费。比如我现在申请了一个数组，但是我希望元素在需要时再构造，而不是直接全部构造。</p><p><code>allocator</code>分配的内存是未构造的。它可以按照类型的大小指定内存，并且可以重用析构过的内存，或将内存还给系统。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象</title>
    <link href="/Linux-C++/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/Linux-C++/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1>面向对象</h1><h1 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h1><p>一般来说，需要析构函数的场景会比需要拷贝构造或拷贝赋值运算符更容易识别。如果一个类需要析构函数，那么它大概率需要拷贝赋值运算符和拷贝构造函数。</p><p>如果一个类需要拷贝构造，那么它大概率需要拷贝赋值运算符。反之亦然。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>只有当类没有声明<strong>任何</strong>构造函数时，编译器才会自动生成一个<strong>默认构造函数</strong>，其初始化类成员的规则：</p><ul><li>优先使用类内初始值</li><li></li><li>没有初始值的成员将被默认初始化（undefined）。这样很危险。</li></ul><p><code>= default</code>加在函数列表后，可以要求编译器生成默认构造函数。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说把它的一些职责委托给了其他构造函数。</p><h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p>如果构造函数只接收一个实参，则它实际上定义了转换为此类类型的隐式转换机制。</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>一般第一个参数是该类型的const引用，以及一些有默认值的参数，总之保证这个构造函数只需要一个同类对象就可以调用。</p><p>由于需要被隐式调用，所以<strong>不能是</strong><code>explicit</code>。</p><p><code>string s1(s2);</code>也属于<strong>直接初始化</strong>，即让编译器根据参数类型匹配构造函数。使用赋值符号才是拷贝初始化。<br>编译器可以（但不是必须）略过拷贝&#x2F;移动构造函数，直接创建对象（使用直接初始化），但是在这个程序点上，拷贝&#x2F;移动构造函数必须存在且可以访问。</p><p>拷贝初始化发生的时机：</p><ul><li><p>用<code>=</code>定义变量</p></li><li><p>将一个对象作为实参传递给一个非引用类型的形参。</p></li><li><p>从一个返回类型为非引用类型的函数返回一个对象</p></li><li><p>用花括号列表初始化一个数组中的元素，或一个聚合类中的成员</p></li><li><p>容器初始化，<code>push</code>，<code>insert</code>时</p></li></ul><h3 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h3><p>与默认构造函数不同，哪怕有其他构造函数，编译器还是会默认生成一份默认拷贝构造。其作用是将对象的成员悉数拷贝。</p><p>具体拷贝操作取决的成员的类型：</p><ul><li>对于<code>class</code>成员，调用其拷贝构造函数。</li><li>内置类型直接拷贝</li><li>数组：逐一拷贝元素</li></ul><h3 id="拷贝赋值符号"><a href="#拷贝赋值符号" class="headerlink" title="拷贝赋值符号"></a>拷贝赋值符号</h3><p>重载<code>=</code>符号，左操作符隐式传为<code>this</code>，一般要求返回一个左操作符的引用。</p><p>默认生成的拷贝赋值符号，会将所有non-static成员复制，数组成员会被全部复制。</p><p>在重载拷贝赋值时，一定要注意处理的顺序，避免在对象自我赋值的时候出错。要先将右操作符复制一份，再释放左操作数。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>如果一个类有自己的·swap·时，调用std::swap可能会出错。</p><p>自定义的·swap·可以帮助重载拷贝赋值。将右操作数设置为传值，这样形参会被复制，然后再赋值给左操作符。这样做会很安全，如果在形参复制阶段出现问题，一定发生在swap之前。</p><h3 id="避免拷贝，-x3D-delete"><a href="#避免拷贝，-x3D-delete" class="headerlink" title="避免拷贝，&#x3D;delete"></a>避免拷贝，&#x3D;delete</h3><p>大部分的类需要显式的或者隐式的默认构造，拷贝构造和拷贝赋值运算。但是有一些类，必须被定义为无法拷贝或者赋值，比如<code>iostream</code>类。如果需要避免生成默认的以上函数，可以使用<code>=delete</code>。</p><p><code>=default</code>可以用在类内或者类外，在类外再次使用可以让默认函数不是<code>inline</code>。但是<code>=delete</code>不同，只能用在首次定义的时候。</p><p><code>=default</code>只能用在编译器可以生成默认版本的函数上，但是&#x3D;delete可以用在任何函数上。</p><p>注意：不应该删除析构函数，因为编译器不允许创建一个无法销毁的对象。在第631页有许多关于<code>=delete</code>的使用规则，但他们的原则都是基于这个。</p><p>早期C++用<code>private</code>控制可见性来达到类似效果。</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在构造函数中，在参数列表和函数体中间有一块初始化部分。构造函数会先执行成员的初始化，再执行构造函数体。析构函数则是相反，先执行函数体，再将所有成员析构，后一步是隐式的。</p><p>由于释放成员的原理是调用成员的析构函数，因此析构行为取决于成员的类型和他们的析构函数。比如一个内置指针就只会释放本身，不会将指向的内存空间一并释放。</p><p>一般来说，一个对象离开了作用域就会被析构，但是对象的指针或者引用失效不会导致本身被析构。</p><h3 id="默认析构函数"><a href="#默认析构函数" class="headerlink" title="默认析构函数"></a>默认析构函数</h3><p>默认析构函数的函数体是<strong>空的</strong>，相当于是直接调用成员的析构，而不做更多操作。</p><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>当我们在使用拷贝赋值时，会先把数据复制一份，然后再拷贝，但是这个复制其实是多余的。赋值可以将右操作符的内存直接搬到左操作符上。标准库引入了两种机制，为了避免<strong>不必要的拷贝</strong>。</p><ol><li>移动构造函数：具体实现未公开，作用是将资源从给定对象<strong>移动</strong>而不是拷贝到正在创建的对象。标准库保证<strong>移后源</strong>仍是有效的，可析构的状态。目前可以理解为拷贝了指针，而不是拷贝的整块内存。</li><li><code>move</code>标准库函数：在<code>utility</code>头中，在用<code>allocator</code>的<code>construct</code>时必须调用<code>move</code>来表示希望使用移动构造函数，如果漏掉了就会变回拷贝构造函数。其次，通常不会为<code>move</code>提供一个<code>using</code>声明，<strong>原因待补充</strong>，因此调用时应该使用<code>std::move</code>。</li></ol><p>在编写自定义的移动构造函数时，要在形参列表和函数体之间加上<code>noexcept</code>，因为移动操作不分配新内存，所以不应该抛出异常（移动赋值运算符同理）。如果我们不声明，编译器会为了可能存在的异常做额外的工作。同时，允许函数抛出异常说明如果异常发生时，我希望调用者的状态恢复到调用前的状态，而不是被改变。比如<code>vector</code>的<code>push_back</code>操作，如果分配新的空间失败，会抛出异常，旧元素还在原地没变，只需要将申请的内存释放即可。但是移动操作会改变对象本身的状态，如果在操作到中途时发生问题，无法回到最初的状态。因此，除非<code>vector</code>知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存时就不该使用移动构造函数。如果希望它使用，则必须显式地告诉编译器，我们的移动构造函数是安全的。</p><p>移后源对象在函数体中应该将成员指针都设为<code>nullptr</code>，否则之后在析构的时候，会把所指向的内存（现在已经被移动到被赋值对象中）也析构掉。</p><h3 id="默认的移动操作"><a href="#默认的移动操作" class="headerlink" title="默认的移动操作"></a>默认的移动操作</h3><p>编译器不会为已经有自己的拷贝构造等大三样的类合成移动操作。只有当一个类没有定义任何<strong>自定义</strong>的拷贝控制成员，且类的美和<strong>非static</strong>成员都<strong>可以移动</strong>时，才会为它合成默认的移动构造函数或移动赋值运算符。<code>build-in</code>类型<strong>默认可以移动</strong>。</p><p>与拷贝操作不同，移动操作<strong>不会</strong>隐式定义为<code>delete</code>。但是，如果显式地要求生成<code>=default</code>的移动操作，且编译器不能移动所有成员时，移动操作会被定义为<code>=delete</code>。</p><p><strong>注意</strong>：定义了一个移动构造函数或移动赋值运算符的类，必须也定义自己的拷贝操作，否则这些成员默认被定义为是<code>=delete</code>的。</p><h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p>一个类如果既有拷贝构造又有移动构造，那么具体调用那么符合函数匹配原则，匹配参数最接近的。</p><p>如果类仅有拷贝构造，但是试图调用move，由于<code>Type&amp;&amp;</code>可以转换为<code>const Type&amp;</code>，因此还是会调用拷贝构造函数。一般情况下，拷贝构造代替移动构造是安全的。</p><p>成员函数也可以同时定义拷贝和移动两种版本，从而提升性能：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> &amp;X)</span></span>;<span class="hljs-comment">//拷贝版本：绑定到任意类型的X</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(X&amp;&amp;;)</span><span class="hljs-comment">//移动版本：只能绑定到类型X的可修改的右值</span></span><br></code></pre></td></tr></table></figure><p>右值引用会精确匹配到第二种函数上，如果无法匹配才会使用第一种性能较差的成员。</p><h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>这是一种适配器，改变给定迭代器的<strong>解引用运算符</strong>的行为来适配，让解引用得到右值引用。通过标准库的<code>move_move_iterator</code>将一个普通迭代器转换为移动迭代器。</p><p>注意：一定要在确定原容器的元素不再使用的前提下使用。</p><h3 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a>引用限定符</h3><p>参数列表后面可以放引用限定符<code>&amp;</code>或<code>&amp;&amp;</code>，表示该方法或者运算符只能由左值或者右值来调用（<code>this</code>必须是左值还是右值）。</p><p>引用限定符只能出现在<code>const</code>之后。</p><p>一个成员函数是否有const是两个不同的重载函数，有无引用限定也是类似。</p><p>如果一个函数有引用限定符，那么所有具有相同参数列表的重载版本都要有引用限定符。</p><h2 id="move语义"><a href="#move语义" class="headerlink" title="move语义"></a>move语义</h2><p>有些时候，对象在被复制后就马上被销毁了，这种情况下，<strong>移动</strong>它会有更好的性能。还有些情况下，对象不应该被复制，比如IO。</p><p>容器，<code>string</code>，<code>shared_ptr</code>支持复制和移动；IO和<code>unique_ptr</code>只支持移动。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用必须绑定在右值上，使用的符号是<code>&amp;&amp;</code>而不是<code>&amp;</code>。由于右值是马上要被销毁的，所以可以<strong>移动</strong>右值引用。</p><p>左值表示的是对象的<strong>身份</strong>，右值表示对象的<strong>值</strong>。左值拥有持久的状态，而右值要么是字面值常量，要么是表达式求值过程中创建的临时对象。</p><p>之前学的常规引用可以看做<strong>左值引用</strong>，我们不能把左值引用绑定到要求转换的表达式，字面常量或返回右值的表达式。右值引用则相反，可以绑定到这些表达式上，但是不能直接绑定到左值上。</p><ul><li><p>返回左值的表达式：返回左值引用的函数，赋值、下标、解引用和前置递增、递减运算符。</p></li><li><p>返回右值的表达式：返回非引用类型的函数，算术、关系、位以及后置递增、递减运算符。</p></li></ul><p>左值引用不能直接绑定在右值上，但是可以将一个<code>const</code>的左值引用绑定到右值上。</p><p>由于右值引用只能绑定到临时对象上，可以得出：</p><ul><li>引用对象马上要销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用对象的资源。</p><p>单独的变量作为表达式时，是左值，因此右值引用不能绑定到变量上，也不能绑定到一个右值引用类型的变量上。</p><p>注意：右值引用只是说绑定的对象是右值，绑定完后就会消失，但是右值引用本身是一种<strong>左值</strong>，因为它本身不会马上消失，在作用域内可以继续使用。</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>右值引用不能直接绑定在左值上，但是可以使用<code>utility</code>中的<code>move</code>函数，告诉编译器：我有一个左值，但是我希望像一个右值一样处理它。这相当于成果：除了对该变量的赋值和销毁它之外，我将不再使用它，但是它必须是<strong>可析构</strong>，<strong>有效的</strong> 的状态。该变量在移动过后，可以对它赋值，或者销毁它，但是不能使用它，因为它的值已经不确定了。</p><p>标准库中move的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>move()的参数<code>T&amp;&amp;</code>是一个指向模板类型参数的<strong>右值引用</strong>，通过<strong>引用折叠</strong>，此参数可以与任何类型的实参匹配。</p><h4 id="用右值调用move"><a href="#用右值调用move" class="headerlink" title="用右值调用move"></a>用右值调用move</h4><p>如果move()的参数是一个<strong>右值</strong>，如<code>std::move(string(&quot;Hello&quot;));</code>，那么函数运行如下：</p><ul><li><p>推断出T的类型为<code>string</code></p></li><li><p>因此，<code>remove_reference</code>用<code>string</code>进行实例化</p></li><li><p><code>remove_reference&lt;string&gt;::type</code>是<code>string</code></p></li><li><p><code>move</code>的返回类型是<code>string&amp;&amp;</code></p></li><li><p><code>move</code>的函数参数<code>t</code>类型为<code>string&amp;&amp;</code></p></li></ul><p>因此，相当于这个调用实例化<code>move&lt;string&gt;</code>，即函数<code>string&amp;&amp; move(string &amp;&amp;t)</code>。由于t的类型和<code>static_cast</code>的类型一直，所以<code>static_cast</code>不需要做什么。</p><h4 id="用左值调用move"><a href="#用左值调用move" class="headerlink" title="用左值调用move"></a>用左值调用move</h4><p>如果move()的参数是一个<strong>左值</strong>，如<code>std::move(str));</code>，那么函数运行如下：</p><ul><li><p>推断出T的类型为<code>string&amp;</code></p></li><li><p>因此，<code>remove_reference</code>用<code>string&amp;</code>进行实例化</p></li><li><p><code>remove_reference&lt;string&amp;&gt;::type</code>是<code>string</code></p></li><li><p><code>move</code>的返回类型是<code>string&amp;&amp;</code></p></li><li><p><code>move</code>的函数参数<code>t</code>类型为<code>string&amp; &amp;&amp;</code>，会折叠为<code>string&amp;</code></p></li></ul><p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即函数<code>string&amp;&amp; move(string &amp;t)</code>。这正是我们想要的结果，将一个左值转换为右值，用<code>static_case&lt;string&amp;&amp;&gt;(t)</code>将<code>string&amp;</code>转换为<code>string&amp;&amp;</code>。</p><p>通常<code>static_cast</code>只能用于其他合法的类型转换，但是允许将左值显式地转换为右值引用是<code>static_cast</code>的一个特例。一方面因为这种转换是安全的，另一方面C++通过强制使用<code>static_cast</code>来阻止意外地进行这种转换。</p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="class和struct的区别"><a href="#class和struct的区别" class="headerlink" title="class和struct的区别"></a>class和struct的区别</h3><p>唯一区别就是默认的访问权限：class默认public，struct默认private。</p><h3 id="用户的身份"><a href="#用户的身份" class="headerlink" title="用户的身份"></a>用户的身份</h3><p>在面向对象和继承的场景下，应该考虑2种用户：</p><ul><li>普通用户：使用类的对象，只能访问类的公有成员。</li><li>实现者：编写类的成员和友元，这两者能同时访问类的公有和私有部分。</li><li>派生类：基类把它希望派生类能够使用的部分声明成<code>protect</code>的，普通用户不能访问<code>protect</code>成员，派生类及其友元<strong>不能访问私有成员</strong>。</li></ul><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或函数访问它的非<code>public</code>成员，只要另其它类或函数成为它的<strong>友元</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">friend</span> return_type <span class="hljs-title">namespace::func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>友元只能出现在类定义的内部，但是在类内的具体位置不限。一般来说，最好在类定义开始或结束前的位置集中声明友元，并且一般把友元的声明和类本身放置在同一个头文件中。</p><p>友元的声明仅仅指定了访问权限，并不是函数声明。</p><h4 id="友元和继承"><a href="#友元和继承" class="headerlink" title="友元和继承"></a>友元和继承</h4><p>友元的关系没有传递性，朋友的朋友不是朋友。重载函数必须分别声明友元。</p><p>基类的友元在访问派生类时没有特权，反过来，派生类友元也不能随意访问基类成员。但是<strong>每个类负责自己成员的访问权限</strong>，基类的友元哪怕是访问子类中的基类成员，也是可以的。</p><h3 id="派生访问说明符"><a href="#派生访问说明符" class="headerlink" title="派生访问说明符"></a>派生访问说明符</h3><p>派生访问说明符对<strong>派生类的成员</strong>（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与<strong>基类中的访问说明符有关</strong>。</p><p>派生访问说明符的目的是控制派生类用户（包括子类的子类）对<strong>基类成员</strong>的访问权限。</p><ul><li>派生访问说明符影响：子类的对象能否使用父类的成员</li><li>基类中的访问说明符：子类的成员能否使用父类的成员</li></ul><p>可以这么理解，如果派生访问说明符是<code>private</code>，那么在代码中可能这样展示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Priv_Derv</span> : <span class="hljs-keyword">private</span> Base&#123;&#125;<br></code></pre></td></tr></table></figure><p>这样的意思就是，在子类中如果需要调用父类的成员，那么是通过<code>Base.member</code>来调用，但是这时的<code>Base</code>是<code>private</code>，所以不允许。</p><h3 id="对自身的访问说明符"><a href="#对自身的访问说明符" class="headerlink" title="对自身的访问说明符"></a>对自身的访问说明符</h3><p>基类应该将接口成员声明为<code>public</code>，将属于其实现的部分分为2组：</p><ul><li>可供派生类访问的：应声明为<code>protect</code>。</li><li>只能由基类和基类友元访问的：声明为<code>private</code>。</li></ul><p>在对自身成员的访问说明符中，<code>protect</code>的级别介于<code>public</code>和<code>private</code>之间，用于希望与派生类分享，但是不给其他公共访问的成员。注意这是一个单向的关系，只是父类分享<strong>自己的</strong>成员给子类，子类自己的<code>protect</code>成员基类无法访问。</p><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>派生类向基类的转换能否成功，由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假设D继承自B：</p><ul><li>只有当D<code>public</code>继承B时，<strong>用户代码</strong>才能使用转换；如果D继承B的方式是<code>protect</code>或<code>private</code>，则用户代码不能使用。</li><li>不管D以什么方式继承B，D的<strong>成员函数和友元</strong>都能使用转换；派生类向其<strong>直接基类</strong>的类型转换对于派生类的<strong>成员函数和友元</strong>来说<strong>永远</strong>可访问。</li><li>如果D继承B的方式是<code>public</code>或<code>protect</code>，D的派生类的<strong>成员和友元</strong>可以使用转换；如果是<code>private</code>则不行。</li></ul><p>总体上将，对于代码中某个给定节点来说，如果基类的公有成员是可访问的，则派生类想基类的类型转换也是可访问的；反之不行。</p><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>重载的运算符本质是具有<strong>特殊名字</strong>的函数，名字有关键字<code>operator</code>和后面的符号组成。如果重载运算符时成员函数的话，第一个（左侧）运算对象会<strong>隐式</strong>绑定为<code>this</code>指针。</p><p>作用与内置类型的运算符无法重载。</p><p>由于重载运算符本质上是函数调用，所以会是去原有的运算优先级，比如<code>&amp;&amp;</code>和<code>||</code>会是去<strong>短路</strong>的性质，所以一般来说，不应该重载逗号，取地址，逻辑与和逻辑或运算符。</p><p>除了一些别无选择的情况，运算符必须是成员，其他情况下运算符作为普通函数更好：</p><ul><li>赋值<code>=</code>，下标<code>[]</code>，调用<code>()</code>，和成员访问箭头<code>-&gt;</code><strong>必须是</strong>成员。</li><li>复合运算符一般来说是成员，不必须。</li><li>改变对象状态的运算符，或者与给定类型密切相关的运算符，如迭代器的递增，递减和解引用，一般是成员。</li><li>具有<strong>对称性</strong>的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是非成员函数。</li></ul><p>通常输出运算符应该负责<strong>打印</strong>而非<strong>控制格式</strong>，不应该打印换行符。</p><p>输入运算符必须要处理可能出现的输入异常，但是输出不用。<br>在数据读入过程中，可能在一步步初始化对象，如果中途出现了输入异常，必须要有相应的处理机制，避免出现<code>undefined</code>，比如把剩余的变量值初始化。</p><p>如果类同时定义了算术运算符，和对应的复合赋值运算符，通常应该用复合运算符来实现算术运算符。用<code>+=</code>来实现<code>+</code>。</p><p>如果存在唯一一种逻辑合理的<code>&lt;</code>，则应该考虑为这个类定义<code>&lt;</code>。如果类同时还有<code>==</code>，当且仅当<code>&lt;</code>的定义和<code>==</code>不冲突时才定义。</p><p>赋值运算符必须是成员函数，复合赋值运算符通常应该是成员函数，都应该返回左侧运算类型的引用。</p><p>下标运算符必须是成员函数。如果一个类应该有下标运算符，那么应该定义2种版本：返回常量引用和非常量引用。</p><p>递增和递减运算符必须是成员函数。必须同时定义前置和后置版本。为了区分，后置版本接受额外的（不适用）的<code>int</code>形参，没有变量名，编译器会提供一个0作为实参。如果要显式调用，则要自己传入0。</p><p>成员访问箭头必须是成员函数，解引用不强制但一般是成员函数。重载箭头时，箭头获取成员一定会发生。</p><p>函数调用符<code>()</code>必须是成员函数。函数对象可以有自己的成员，以此作为自定义。经常用来作为泛型算法的参数。</p><h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>一个类型转换函数必须是成员函数，没有返回类型，形参列表为空，函数类型通常为<code>const</code>，函数名即为想要转换成为的类型。</p><p>在实践中，类很少提供转换运算符。在隐式转换发生时，用户往往觉得奇怪而不是被帮助了。尤其是对于内置算术类型的转化，因为内置算术类型之间有很丰富的转换，容易让人迷惑。比如在早期标准中对一个cin使用<code>cin &lt;&lt; 42</code>，cin会被转换成<code>bool</code>然后执行左移。</p><p>为了解决上述问题，引入了<code>explicit</code>，需要用<code>static_cast</code>或者构造转换进行显式转换。<code>bool</code>是一个例外，因为经常需要那里作为判断条件，所以还是会隐式转换。</p><h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><ol><li>A中有接收B类型的转换构造函数，B中有转换为A的转换运算符。</li><li>定义了多个转换规则，这些转化涉及到的类型本身可以通过其他类型转换联系起来。最典型的就是算术转换符，对于一个给定的类，最好只定义最多一个与算术类型有关的转换规则。</li></ol><p>注意：无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。</p><p>函数接收参数的时候可以有一次转换，如果2个重载函数的参数要求的都不是参数传入的，且参数转换的级别一致，也会有二义性。</p><p>对于一个运算符来说，成员函数、非成员函数、内置运算符，都有可能被调用。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>子类可以隐式转换成父类，因为子类其实包含了父类完整的功能。因此，子类对象或引用可以用在需要<strong>父类引用</strong>的地方，子类对象的指针可以用在需要<strong>父类指针</strong>的地方。</p><p>注意，对象本身的静态类型<strong>不能改变</strong>，只有<strong>指针</strong>和<strong>引用</strong>才有隐式转换。如果基类中含有虚函数，可以使用<code>dynamic_cast</code>请求类型转换，检查安全后执行。如果确定转换是安全的，可以使用<code>static_cast</code>来强制覆盖编译器的检查工作。</p><p>用一个子类对象作为父类对象初始化或赋值时，只有该子类对象中的基类部分会被拷贝、移动或赋值，子类部分会被忽略。因为这些本质上都是<strong>函数调用</strong>，传入的隐式参数&#96;this的类型决定了调用的是谁的函数，如果参数要求的父类，那么只会调用父类的函数。</p><p>总结：</p><ol><li>从派生类向基类的类型转换只对指针或者引用有效。</li><li>基类向派生类不存在隐式类型转换。</li><li>和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而不可行。</li></ol><p>父类希望每个子类有自己的专属的实现方式。</p><p>派生类列表：<code>class Type: public Base&#123;&#125;</code>。格式为在类名后面有一个冒号，冒号之后是所有的基类，基类前可以有访问说明符。用上了<code>public</code>之后，子类可以完全代替父类。但是注意，派生类声明的时候<strong>不需要</strong>冒号后面的东西。</p><p>作为基类，必须已经被定义，不能只是声明。因为子类中需要包含父类，需要知道父类有什么数据和功能。</p><p>如果不希望被继承，需要在冒号前加<code>final</code>关键字。</p><p>每个子类只能初始化他们的直接基类，间接基类由他们对应的直接基类来负责，在构造时行程一个链。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>子类必须在内部对所有重新定义的虚函数进行声明。</p><p>与虚函数一起发挥作用的是<strong>动态绑定</strong>，指被调用的虚函数时与绑定到<strong>指针或引用</strong>上的对象的<strong>动态类型</strong>想匹配的那个。强调，运行时决定；只对指针和引用生效，也只有在这种情况下， 对象的动态类型<strong>才有可能</strong>和静态类型不同。为了保持多态性，只有虚函数的返回值是自身类型的指针或者引用时，返回值也具有多态性（只要允许隐式转换）。</p><h3 id="虚函数的覆盖"><a href="#虚函数的覆盖" class="headerlink" title="虚函数的覆盖"></a>虚函数的覆盖</h3><p>继承的虚函数天然就是<code>virtual</code>的。派生类可以在它覆盖的函数前也使用<code>virtual</code>，表示这个派生类仍然可能被继承，函数可能会被覆盖。</p><p>覆盖要求子类的函数与要覆盖的父类虚函数不仅函数名一致，形参列表也要一致，如果不一致就会被编译器认为是一个新的函数。典型错误就是以为覆盖了虚函数，但实际上因参数不一致而并没有覆盖。</p><p>C++11允许派生类显式注明它使用某个成员函数覆盖了它继承的虚函数，要在形参列表、<code>const</code>关键词、引用限定符<code>&amp;或&amp;&amp;</code>后面加上关键词<code>override</code>。这样可以增加可读性，方便查错，如果该函数无法覆盖已存在的虚函数，编译器就会报错。</p><p>如果把一个函数设为<code>final</code>则可以避免被覆盖。</p><p>虚函数也可以有默认实参，并且实参的版本取决于多态性，因此实践中尽量基类和派生类中的默认实参一致。</p><h3 id="虚函数的回避"><a href="#虚函数的回避" class="headerlink" title="虚函数的回避"></a>虚函数的回避</h3><p>如果需要指定某个版本的虚函数，则要在函数名前带着类名和<code>::</code>。</p><p>通常情况下，只有成员函数（或友元）中的代码才需要用作用域运算符来会比虚函数的机制。</p><p>最典型的场景：基类虚函数中进行了一些前置操作，子类虚函数需要先调用父类的虚函数（类似于Java中调用<code>super</code>的方法），在其基础上完成自己进一步的操作。如果不回避虚函数机制，则因多态性不会调用到基类的方法，而是调用子类的方法，导致<strong>无限递归</strong>。</p><h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><p>在函数体的位置写<code>=0</code>即可声明为纯虚函数，不需要定义，表示这个函数没有意思，必须要覆盖才可以调用。</p><p>含有纯虚函数的类是<strong>抽象基类</strong>，该类型无法实例化，类似于Java中的<code>interface</code>。</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>每个基类都应该有虚析构函数。</p><p>一个类如果定义了析构函数，即使是编译器生成的默认版本，编译器也不会为这个类合成移动操作。移动操作会去使用默认的拷贝构造。</p><h2 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h2><p>如果一个派生类是<code>private</code>继承，那么所有基类成员到他这里就都变成了私有成员，他的派生类无法访问。可以使用<code>using</code>来改变可访问性，用法是将基类的成员再声明一遍：<code>using Base:: x;</code>，但是注意，派生类只能这样声明他本身能访问到的基类成员。</p><h2 id="删除的拷贝控制"><a href="#删除的拷贝控制" class="headerlink" title="删除的拷贝控制"></a>删除的拷贝控制</h2><p>如果基类有删除的或者无法访问的拷贝控制函数，那么子类的相关函数（需要调用父类的）会被设置为<code>delete</code>。也就是说编译器不会为已经删除的函数再合成，也不会让子类只完成部分的操作。</p><p>实际编程中，如果基类没有默认、拷贝或移动构造函数，一般派生类也不会定义。</p><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>类不能继承默认、拷贝和移动构造函数，只能由编译器自动生成。</p><p>如果想要继承，需要用<code>using</code>声明语句，让编译器来给派生类生成与基类一样的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">derived</span>(parms) : <span class="hljs-built_in">base</span>(args)&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>using</code>生成的构造函数不会改变访问级别；不能改变<code>explicit</code>和<code>constexpr</code>；不能继承默认实参，而是会获得多个版本的构造函数，每个构造函数分别省略一个含有默认实参的形参。</p><p>继承的构造函数不会作为用户自定义的构造函数，所以编译器还是会生成合成函数。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="成员函数与inline"><a href="#成员函数与inline" class="headerlink" title="成员函数与inline"></a>成员函数与inline</h2><p>所有的成员函数会被自动标记为<code>inline</code>，但是<code>inline</code>只是一种建议，最终决定权在于编译器。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>类似于Python中成员函数的第一个参数必须是<code>self</code>那样，任何对成员函数的调用都会将对象隐式传入为<code>this</code>，并且在成员函数内部使用成员变量时，也隐式使用了<code>this</code>。<code>this</code>是一个const指针。</p><h2 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h2><p>重载是对于在同一作用域声明的函数而言的。内部作用域声明的成员，会直接覆盖而不是重载外部的成员，既是形参列表不一致。</p><p>因为在较小的作用域中查找时，编译器能直接找到同名的函数，并认为这就是自己想要的，不再继续向更外层的作用域查找。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL</title>
    <link href="/Linux-C++/STL/"/>
    <url>/Linux-C++/STL/</url>
    
    <content type="html"><![CDATA[<h1>C++ STL</h1>  <p>模板本身不是类或函数，而是为编译器生成类或函数而编写的说明书。</p><h1 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1. 顺序容器"></a>1. 顺序容器</h1><h2 id="1-1-共通的知识"><a href="#1-1-共通的知识" class="headerlink" title="1.1. 共通的知识"></a>1.1. 共通的知识</h2><h3 id="1-1-1-assign和赋值的区别"><a href="#1-1-1-assign和赋值的区别" class="headerlink" title="1.1.1. assign和赋值的区别"></a>1.1.1. assign和赋值的区别</h3><p>用等号赋值的时候，左右两边的类型要完全一致（包括容器的类型和元素的类型）。  </p><p>用<code>assign</code>的时候，允许元素类型隐式转换，是<strong>拷贝并替换</strong>到被赋值的容器中。</p><h3 id="1-1-2-swap的本质"><a href="#1-1-2-swap的本质" class="headerlink" title="1.1.2. swap的本质"></a>1.1.2. swap的本质</h3><p><code>swap(con1, con2)</code>可以交换两个容器的内容。注意，<code>swap</code>的速度<strong>很快</strong>，因为不是交换容器内的所有元素，而是直接交换容器内部的数据结构。  </p><p>除了<code>array</code>，<code>swap</code>并不复制&#x2F;删除&#x2F;插入任何元素,并保证会在常数时间内完成。 <code>array</code>的<code>swap</code>确实会交换元素，运行时间和元素数量成正比。 <code>swap</code>之后，迭代器&#x2F;引用&#x2F;指针还指向原来的元素，但是元素的值已经变了。  </p><p>由于元素本身的位置并未移动，因此除了<code>string</code>，容器的迭代器&#x2F;引用&#x2F;指针不会失效。但是，在<code>swap</code>之后，所有元素已经在对方容器中了。</p><p>早期版本只有成员版本的<code>swap</code>， 但是现代C++应该尽量使用<strong>非成员</strong>版本的<code>swap</code>。</p><h3 id="1-1-3-容器的比较"><a href="#1-1-3-容器的比较" class="headerlink" title="1.1.3. 容器的比较"></a>1.1.3. 容器的比较</h3><p>容器之间也可以用<code>&lt;</code>和<code>=</code>等关系符进行大小比较，但是仅限于容器和元素类型都一致的情况下。</p><h3 id="1-1-4-容器元素是拷贝"><a href="#1-1-4-容器元素是拷贝" class="headerlink" title="1.1.4. 容器元素是拷贝"></a>1.1.4. 容器元素是拷贝</h3><p>用来初始化和插入容易的元素，都是实参的拷贝，完成后就和实参无关了。</p><h3 id="1-1-5-insert操作"><a href="#1-1-5-insert操作" class="headerlink" title="1.1.5. insert操作"></a>1.1.5. insert操作</h3><p><code>insert</code>操作在指定位置前插入，返回插入元素的迭代器。</p><p>容器在插入操作后，容量如果达到一定程度，会触发扩容机制，届时内部数据结构会搬到一块新的内存，原来定义的迭代器就失效了。 对于<code>remove</code>也是类似，在进行任何可能导致迭代器失效的操作之后，都需要注意及时更新迭代器。</p><p>在C++11标准下，接收元素个数或范围的<code>insert</code>版本会返回指向第一个新加入元素的迭代器。（在旧版本中，返回的是<code>void</code>。）利用这个机制，可以在容器中的一个特定位置反复插入元素。</p><h3 id="1-1-6-emplace"><a href="#1-1-6-emplace" class="headerlink" title="1.1.6. emplace"></a>1.1.6. emplace</h3><p>在C++中，<code>push</code>都有对应版本的<code>emplace</code>，元素类型对应的构造器所需的参数被传入，<code>emplace</code>利用这些参数在插入位置直接构造出一个元素，因此性能会比<code>push</code>一个临时对象略好，因为后者多了一步拷贝构造。</p><h3 id="1-1-7-用index还是at"><a href="#1-1-7-用index还是at" class="headerlink" title="1.1.7. 用index还是at?"></a>1.1.7. 用index还是at?</h3><p>程序需要保证下标是合法的，<code>[]</code>本身不会检查是否下标越界。如果想要更安全，可以使用<code>at</code>成员，在下标越界时会抛出异常。</p><h3 id="1-1-8-resize"><a href="#1-1-8-resize" class="headerlink" title="1.1.8. resize"></a>1.1.8. resize</h3><p>调用<code>resize()</code>时，如果当前大小大于要求大小，那么多余部分被截断；如果当前大小小于要求，那么会填充默认元素或者指定元素。</p><h3 id="1-1-9-容器的容量"><a href="#1-1-9-容器的容量" class="headerlink" title="1.1.9. 容器的容量"></a>1.1.9. 容器的容量</h3><p><code>capacity</code>返回容器的容量。</p><p><code>reserve</code>可以指定容器的容量，只在指定的容量大于当前容量的时候才会生效，而且注意指定的容量表示的是容器<strong>最低容量</strong>，实际上编译器可能会分配<strong>多于要求</strong>的容量。</p><p>在C++11中，<code>shrink_to_fit</code>可以让<code>deque</code>, <code>vecotr</code>, <code>string</code>归还用不到的容量，但是具体要不要归还，归还多少，都取决于编译器。</p><h3 id="1-1-10-顺序容器的依赖关系"><a href="#1-1-10-顺序容器的依赖关系" class="headerlink" title="1.1.10. 顺序容器的依赖关系"></a>1.1.10. 顺序容器的依赖关系</h3><p>顺序容器中，有些容器时基于其他容器的操作接口实现的，是一种适配器模式。</p><p>默认情况下，<code>stack</code>和<code>queue</code>由<code>deque</code>实现。这两种数据结构都只会在头尾处增减元素，用<code>deque</code>这样的在两端都可以用O(1)增减元素的结构来实现，<code>vector</code>在插头时很慢。</p><p><code>priority_queue</code>由<code>vector</code>实现。理由是因为<code>priority_queue</code>基于<code>heap</code>，堆是一种完全二叉树，可以用数组来代替树结构，这样的话<code>vector</code>就很合适。</p><h2 id="1-2-数组"><a href="#1-2-数组" class="headerlink" title="1.2. 数组"></a>1.2. 数组</h2><h3 id="1-2-1-数组维度是类型的一部分"><a href="#1-2-1-数组维度是类型的一部分" class="headerlink" title="1.2.1. 数组维度是类型的一部分"></a>1.2.1. 数组维度是类型的一部分</h3><p>数组的维度必须是常量表达式。维度是数组类型的一部分，用<code>decltype</code>推断数组会得到数组的大小。  </p><p>数组类型可以用来定义形参的类型，但是由于维度也是类型的一部分，所以这会限制函数的可用性。</p><h3 id="1-2-2-其他"><a href="#1-2-2-其他" class="headerlink" title="1.2.2. 其他"></a>1.2.2. 其他</h3><p>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。  </p><p>数组会被<code>auto</code>推断为指针，而非数组。</p><p>C++11引入了<code>begin()</code>和<code>end()</code>函数，可以得到数组的首尾指针。  </p><p>标准库限定了下标必须是无符号类型，但是内置数组的下标没有这个限制。 </p><h3 id="1-2-3-多维数组"><a href="#1-2-3-多维数组" class="headerlink" title="1.2.3. 多维数组"></a>1.2.3. 多维数组</h3><p>列表初始化多维数组时，内部的花括号可有可无。</p><p>使用for-each遍历多维数组时，除了最内层的循环之外，其他循环的控制变量都应该是引用类型。</p><h3 id="1-2-4-链表"><a href="#1-2-4-链表" class="headerlink" title="1.2.4. 链表"></a>1.2.4. 链表</h3><p><code>list</code>和<code>forward_list</code>有很多为链表专用的成员函数，建议使用这些而不是公用算法。</p><p>这些链表专用操作，与公用算法不同，是会改变底层容器的。比如<code>unique</code>会把重复元素删除，而不是推到容器尾部。</p><h2 id="1-3-vector"><a href="#1-3-vector" class="headerlink" title="1.3. vector"></a>1.3. vector</h2><h3 id="1-3-1-vector初始化选择？"><a href="#1-3-1-vector初始化选择？" class="headerlink" title="1.3.1. vector初始化选择？"></a>1.3.1. vector初始化选择？</h3><p>C++要求vector能在运行时高效地添加元素，因此除非需要初始化一个有大量重复值的vector，否则尽量先定义一个空的vector，再在运行时添加元素。</p><h3 id="1-3-2-扩容策略"><a href="#1-3-2-扩容策略" class="headerlink" title="1.3.2. 扩容策略"></a>1.3.2. 扩容策略</h3><p>每种<code>vector</code>的实现可以选择自己的扩容策略，但是原则是只有在必须的时候才扩容。</p><h1 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2. 关联容器"></a>2. 关联容器</h1><h2 id="2-1-Ordered版本"><a href="#2-1-Ordered版本" class="headerlink" title="2.1. Ordered版本"></a>2.1. Ordered版本</h2><p>关联容器默认版本基于红黑树，内部是有序的。<code>unordered</code>前缀表示基于哈希表，内部是无序的。如果有<code>multi</code>则表示允许重复的key。注意，无论是<code>set</code>还是<code>map</code>，本质上可以看做同一种东西：<code>set</code>就是只有key没有value的<code>map</code>。</p><p>默认情况下，关联容器要求元素重载小于号，以此来定义其他的比较运算，并且能排序。如果不想用重载运算符，可以传入比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">multiset&lt;Sales_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareIsbn)</span>*&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(compareIsbn)</span></span><br></code></pre></td></tr></table></figure><p>map保存的键值对是用<code>pair</code>，内部有两个公共成员<code>first</code>和<code>second</code>。<code>pair</code>是map的<code>value_type</code>，key的类型是<code>key_type</code>，值的类型是<code>mapped_type</code>。迭代器得到的pair，<code>key</code>是const的，不允许改变。在C++11中，创建<code>pair</code>不用字使用<code>make_pair</code>或者<code>pair&lt;T1, T2&gt;(v1, v2)</code>这样的方式，而是直接用列表初始化<code>&#123;v1, v2&#125;</code>就可以代表一个匿名的<code>pair</code>。</p><p>注意，对map的迭代器解引用得到的是<code>pair</code>，用下标得到的是<code>value</code>。</p><p>由于key是const，所以一般不对关联容器使用泛型算法。由于关联容器的内部结构特殊，导致他的成员函数性能一般会比泛型算法好。实践中，我们一般把关联容器用作数据源或者目的地。</p><p><strong>inset</strong></p><p>在向普通关联容器插入元素时，我们需要知道这个key是否已经存在，insert是否成功。<code>insert</code>和<code>emplace</code>都会返回一个<code>pair</code>，<code>first</code>是指向新插入的元素的迭代器，<code>second</code>是一个bool值，表示插入是否成功。</p><p><strong>erase</strong></p><p><code>erase</code> return s a count of how many elements were removed.</p><p><strong>equal_range</strong></p><p><code>equal_range</code>得到的是一个pair，<code>first</code>是<code>lower_bound</code>的值，<code>second</code>是<code>upper_bound</code>的值，这样正好凑成了一个范围可以用来迭代，遍历所有key等于特定值的范围。一个常用的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pos = authors.<span class="hljs-built_in">equal_range</span>(search_item); pos.first!=pos.second; ++pos.first)<br></code></pre></td></tr></table></figure><h2 id="2-2-Unordered"><a href="#2-2-Unordered" class="headerlink" title="2.2. Unordered"></a>2.2. Unordered</h2><p>unordered版本基于哈希表，拥有更快的查找的插入性能，要求元素重载<code>==</code>运算符和拥有哈希函数。如果Key值类型是无序的，或者性能测试说明哈希表可以更好，那么可以使用unordered版本。</p><p>哈希表的结构是一系列桶，每个桶对应一个链表。相同哈希值的元素会被分配到同一个桶里，相当于是哈希碰撞了，要在链表里顺序查找，这是就需要重载的<code>==</code>来判断是否相同了。因此，哈希函数的设计会直接影响性能。</p><p>内置类型一般都有设计好的哈希函数，对于自定义类型，我们一般有两种方法提供自定义的哈希函数：</p><ol><li>用对象中的某些unique的属性作为哈希值，类似于用数据表中的主键或者多个属性组合成一个主键。</li><li>另外设计一种。</li></ol><h1 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h1><p>需要解引用迭代器并调用所指对象的成员时，形式必须是<code>(*it).method()</code>，括号必不可少，因为解引用的优先级很低。为了方便使用，C++增加了箭头运算符<code>-&gt;</code>。</p><h2 id="3-1-尽量使用const迭代器"><a href="#3-1-尽量使用const迭代器" class="headerlink" title="3.1. 尽量使用const迭代器"></a>3.1. 尽量使用const迭代器</h2><p>就和形参和变量类型要求尽量使用const那样，迭代器也应遵循类似原则。要尽量避免不经意的修改。</p><h1 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h1><p>根据STL的设计原则，算法不直接操作容器，而是通过迭代器作为中介和接口。算法不会<strong>调用容器的成员函数</strong>，更不会改变<strong>容器的容量</strong>。</p><h2 id="4-1-算法的已经接口"><a href="#4-1-算法的已经接口" class="headerlink" title="4.1. 算法的已经接口"></a>4.1. 算法的已经接口</h2><p>STL中的算法大致有几种接口</p><ul><li>接收一对范围和一个目的地迭代器</li><li>接收两对范围：</li><li>接收一对范围和另一个起点迭代器</li></ul><p>他们都有基本的假设：程序员给定的范围是可靠的，容量是足够的。</p><p>带有后缀<code>_if</code>的算法一般可以接受一个<code>predicate</code>，来处理符合特定条件的元素。</p><p>带有后缀<code>_copy</code>的算法是不改变原容器的，而是会多接收一个目的地迭代器，把改变后的值写到那里。</p><h2 id="4-2-lambda"><a href="#4-2-lambda" class="headerlink" title="4.2. lambda"></a>4.2. lambda</h2><p>基本形式<code>[capture lsit] (parameter list) -&gt; return type &#123; function body &#125;</code></p><p>参数列表和返回值类型可以省略，但是捕获列表和函数体必须有，也就是最简形式为<code>auto f = [] &#123; return 0; &#125;;</code></p><p>如果函数体里只有一个<code>return</code>语句的话，可以不用写返回值类型，会自动推断返回值类型。但是如果不止一条语句，并不指定返回值类型时，默认<code>return void</code>。</p><p>当我们定义了一个lambda时，编译器自动生成了一个匿名的类来表示。和类一样，在lambda对象被创建时，需要捕获的局部变量就像成员变量一样被初始化。</p><h3 id="4-2-1-捕获列表"><a href="#4-2-1-捕获列表" class="headerlink" title="4.2.1. 捕获列表"></a>4.2.1. 捕获列表</h3><p>如果lambda想要使用所调用函数内的非静态局部变量，那么必须在捕获列表中指出。<code>local static</code>变量和函数体外的变量可以直接使用。</p><p>捕获的局部变量可以是by-value或者by-reference。但是和函数参数不同的时，捕获变量的值是在lambda被<strong>创建</strong>的时候复制，而不是在<strong>调用</strong>的时候。</p><p>如果是传引用，我们需要保证在lambda执行的时候，捕获的局部变量<strong>还存在</strong>。</p><ul><li>捕获列表默认传值</li><li><code>[=]</code>: 捕获列表都以传值的方式</li><li><code>[&amp;]</code>: 捕获列表都以传引用的方式</li><li><code>[=, &amp;a, &amp;b]</code>: 除了指定的变量用传引用，其他都是传值</li><li><code>[&amp;, a, b]</code>: 除了指定的变量用传值，其他都是传引用</li></ul><h3 id="4-2-2-mutable"><a href="#4-2-2-mutable" class="headerlink" title="4.2.2. mutable"></a>4.2.2. mutable</h3><p>默认情况下，lambda不匀速改变捕获变量的值，如果一定要改变的话，需要加上<code>mutable</code>关键字。</p><h3 id="4-2-3-与bind结合"><a href="#4-2-3-与bind结合" class="headerlink" title="4.2.3. 与bind结合"></a>4.2.3. 与bind结合</h3><p><code>bind</code>可以给函数绑定参数，构造出一种新的函数。</p><h2 id="4-3-一些具体算法"><a href="#4-3-一些具体算法" class="headerlink" title="4.3. 一些具体算法"></a>4.3. 一些具体算法</h2><ul><li>unique：每个重复的元素之保留一份，返回一个指向unique部分的尾部的迭代器。注意，容器剩余部分不是空的，重复的元素也不是被删除了，而是被塞到了最后。</li><li>stable_sort：不会改变相等元素的原本顺序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/Linux-C++/C++%E5%9F%BA%E7%A1%80/"/>
    <url>/Linux-C++/C++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>C/C++基础</h1><h1 id="1-字面值"><a href="#1-字面值" class="headerlink" title="1. 字面值"></a>1. 字面值</h1><h2 id="1-1-字符串字面值"><a href="#1-1-字符串字面值" class="headerlink" title="1.1. 字符串字面值"></a>1.1. 字符串字面值</h2><p>字符串字面值常量（string literal），是用一堆双引号包围的字符串序列。它应该被视作某种常量，某种匿名对象。  </p><p>因为历史原因和为了与C兼容，C++中的字符串字面值不是string类型，因此对于字符串字面量的操作会产生限制。比如在做字符串相加时，加号两侧至少要有一个运算对象是string。两个字符串字面量无法直接相加。</p><h2 id="1-2-字面值常量"><a href="#1-2-字面值常量" class="headerlink" title="1.2. 字面值常量"></a>1.2. 字面值常量</h2><ul><li>十进制：20</li><li>八进制：024</li><li>十六进制：0x14<br>八进制和十六进制字面值的类型是能容纳其数值的<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>和<code>unsigned long long</code>中尺寸最小者。</li></ul><p>严格来说，十进制字面值不会是负数，形如-42的负数之所以会被正确识别，是因为现将42作为字面量，再对结果去负值。<br>浮点型字面值表现为小数或者科学计数法，其中指数部分用E或e标识。默认的，浮点型字面值是<code>double</code>。  </p><h2 id="1-3-布尔字面值"><a href="#1-3-布尔字面值" class="headerlink" title="1.3. 布尔字面值"></a>1.3. 布尔字面值</h2><p>当我们写出<code>val == true</code>这样的代码时，如果val不是bool类型，那么编译器不会将val转换为bool类型来比较，而是把<code>true</code>转换为1来比较。<br>因此，进行比较运算时，除非比较的对象是bool类型，否则不要使用布尔字面值true和false作为运算对象。</p><h1 id="2-关于string与C-style字符串"><a href="#2-关于string与C-style字符串" class="headerlink" title="2. 关于string与C-style字符串"></a>2. 关于string与C-style字符串</h1><p>在需要使用字符数组的地方可以使用string，因为有隐式转换，但是反过来不行。C风格字符串不会自动转换为string。<br><code>c_str()</code>返回的数组不一定会一直有效，如果想要长期使用，建议拷贝一份。</p><p>现代C++程序应该尽量使用vector和迭代器而非内置数组和指针；尽量使用string而非字符数组。</p><h1 id="3-输入与输出"><a href="#3-输入与输出" class="headerlink" title="3. 输入与输出"></a>3. 输入与输出</h1><h2 id="3-1-endl"><a href="#3-1-endl" class="headerlink" title="3.1. endl"></a>3.1. endl</h2><p><code>endl</code>是某种操作符，写入<code>endl</code>的效果是结束当前行，并将于设备关联的buffer中的内容flush到设备中。因此不应该把<code>endl</code>看做与<code>\n</code>等价。</p><h2 id="3-2-转义序列"><a href="#3-2-转义序列" class="headerlink" title="3.2. 转义序列**"></a>3.2. 转义序列**</h2><p>有2类字符程序员不能直接使用，一类是不可打印的字符，二类是在C++中有特殊含义的字符。这两种字符需要使用转义序列。转义序列除了用反斜杠加字符外，还可以使用泛化的转义序列，形式是在<code>\x</code>后紧跟1个或多个十六进制数字，或者<code>\</code>后紧跟1或2或3个八进制数字。<br>注意，如果反斜线后面跟着的八进制数字超过3个，只有前三个与<code>\</code>构成转义序列。 </p><h2 id="3-3-gt-gt-string与getline的区别"><a href="#3-3-gt-gt-string与getline的区别" class="headerlink" title="3.3. &gt;&gt;string与getline的区别"></a>3.3. &gt;&gt;string与getline的区别</h2><p>在读取时，string对象会自动忽略开头的空白（空格符，换行符，制表符等），从第一个真正的字符开始，直到下一处空白。<br><code>getline</code>会把换行符也读入。  </p><h2 id="3-4-IO类不能是const"><a href="#3-4-IO类不能是const" class="headerlink" title="3.4. IO类不能是const"></a>3.4. IO类不能是const</h2><p>IO对象在读写后会改变自身的状态，所以他们不能是const。</p><h2 id="3-5-写操作不会立刻执行"><a href="#3-5-写操作不会立刻执行" class="headerlink" title="3.5. 写操作不会立刻执行"></a>3.5. 写操作不会立刻执行</h2><p>对于计算机来说，CPU运算会比调度打印机快很多，出于效率考量，程序不会在调用打印语句时立刻打印，而是将要打印的内容放入buffer，等时机成熟时一次性调用输出设备。以下几种情况会flush buffer:</p><ul><li>程序正常退出。在执行<code>main()</code>的return时，缓冲区会清空。</li><li>buffer满时，会先清空，再放入新数据。</li><li>使用<code>endl</code>或<code>flush</code>这样的操作符。</li><li>使用<code>unitbuf</code>操作符，清空缓冲区。</li><li>输出流对应的输入流要读取时。因此交互系统一定要把输出流和输入流绑定，这样就能保证需要用户输入的时候，该展示的信息都已经输出了。</li></ul><h2 id="3-6-输出调试的弊端"><a href="#3-6-输出调试的弊端" class="headerlink" title="3.6. 输出调试的弊端"></a>3.6. 输出调试的弊端</h2><p>由于上述的性质，可知输出调试未必总是管用。如果程序不是正常退出，那么本该输出的内容可能会停留在缓冲区内，给程序员造成了错误的判断，以为该运行到的输出调试语句没有运行（但其实已经运行了）。</p><h2 id="3-7-永远要检查打开文件是否成功"><a href="#3-7-永远要检查打开文件是否成功" class="headerlink" title="3.7. 永远要检查打开文件是否成功"></a>3.7. 永远要检查打开文件是否成功</h2><h2 id="3-8-当一个文件流对象被销毁，close会自动调用。"><a href="#3-8-当一个文件流对象被销毁，close会自动调用。" class="headerlink" title="3.8. 当一个文件流对象被销毁，close会自动调用。"></a>3.8. 当一个文件流对象被销毁，close会自动调用。</h2><h1 id="4-项目组织和文件管理"><a href="#4-项目组织和文件管理" class="headerlink" title="4. 项目组织和文件管理"></a>4. 项目组织和文件管理</h1><h2 id="4-1-How-to-include-headers？Use-lt-gt-or-“”"><a href="#4-1-How-to-include-headers？Use-lt-gt-or-“”" class="headerlink" title="4.1. How to include headers？Use &lt;&gt; or “” ?"></a>4.1. How to include headers？Use &lt;&gt; or “” ?</h2><p>包含来自标准库的头文件用<code>#include&lt;&gt;</code>，对于不属于标准库的头文件使用<code>#include&quot;&quot;</code>。</p><h2 id="4-2-在头文件中进行函数声明"><a href="#4-2-在头文件中进行函数声明" class="headerlink" title="4.2. 在头文件中进行函数声明"></a>4.2. 在头文件中进行函数声明</h2><p>函数应该在头文件中声明，在源文件中定义。</p><h2 id="4-3-多行注释的推荐写法"><a href="#4-3-多行注释的推荐写法" class="headerlink" title="4.3. 多行注释的推荐写法"></a>4.3. 多行注释的推荐写法</h2><p>多行注释的推荐写法是注释内的每行都以一个星号开头。</p><h2 id="4-4-命名空间的using声明"><a href="#4-4-命名空间的using声明" class="headerlink" title="4.4. 命名空间的using声明"></a>4.4. 命名空间的using声明</h2><p>如果只需要命名空间内的某个名字：<code>using _namespace_::_name_;</code><br>位于头文件的代码一般不应该使用using声明。因为头文件的内容会被拷贝到所有引用它的文件中去，如果使用了using声明，那么每个文件中都有了这个声明，可能导致不经意的名字冲突。</p><h2 id="4-5-预处理变量"><a href="#4-5-预处理变量" class="headerlink" title="4.5. 预处理变量"></a>4.5. 预处理变量</h2><p>一般把预处理变量的名字全部大写。 </p><h1 id="5-算术类型选择指南"><a href="#5-算术类型选择指南" class="headerlink" title="5. 算术类型选择指南"></a>5. 算术类型选择指南</h1><ul><li>当明确知道数值不可能为负时，使用<code>unsigned</code>类型。</li><li>使用<code>int</code>或者<code>long long</code>执行整数运算。<code>short</code>常常太小，<code>long</code>一般和<code>int</code>一样尺寸。</li><li>在算术表达式中不要使用<code>char</code>或<code>bool</code>。<code>char</code>在不同的机器上，既可以是有符号的，也可以是无符号的。</li><li>浮点运算选用<code>double</code>，<code>float</code>常常精度不够，而且两者计算代价差别不大，甚至某些机器上<code>double</code>更快。</li></ul><h1 id="6-类型转换注意点"><a href="#6-类型转换注意点" class="headerlink" title="6. 类型转换注意点"></a>6. 类型转换注意点</h1><ul><li>非bool的算术值赋值给bool时，0 for false, otherwise true.</li><li>When assigning bool to non-bool, false for 0 and true for 1.</li><li>当把整数赋值给浮点数时，小数部分记为0。如果整数所占空间超过了浮点类型的容量，精度会有损失。</li><li>赋值给带符号类型一个超出范围的值时，结果是<strong>未定义的</strong>。</li></ul><h1 id="7-为什么标准库中有size-type"><a href="#7-为什么标准库中有size-type" class="headerlink" title="7. 为什么标准库中有size_type?"></a>7. 为什么标准库中有size_type?</h1><p>当一个算术表达式中既有<code>unsigned int</code>又有<code>int</code>时，那个<code>int</code>的值会被转换成无符号的值。<br>对一个为0的<code>unsigned int</code>减1，结果为-1所对应的<code>unsigned int</code>值，这是一个非常大的<code>int</code>。<br><code>size_type</code>体现了标准库类型与机器无关的特性。标准库中表示size的类型一般是无符号的，尽量用无符号的整数与size进行比较，因为一个负数会被自动转换为一个很大的无符号整数。  </p><h1 id="8-变量定义语句的阅读"><a href="#8-变量定义语句的阅读" class="headerlink" title="8. 变量定义语句的阅读"></a>8. 变量定义语句的阅读</h1><p>在同一条定义语句中，执行顺序从左到右，先已定义的变量值可以用来初始化后定义的其他变量。  </p><h1 id="9-列表初始化"><a href="#9-列表初始化" class="headerlink" title="9. 列表初始化"></a>9. 列表初始化</h1><p>C++11的新标准中，花括号初始化普及，被称为列表初始化。当其被用于内置类型的初始化时，如果初始值存在丢失信息的风险，编译器将报错。<br>​<br>在初始化容器时使用花括号，编译器会优先使用列表初始化，如果无法执行，则会尝试用列表中的参数进行其他初始化方式。</p><h1 id="10-默认初始化"><a href="#10-默认初始化" class="headerlink" title="10. 默认初始化"></a>10. 默认初始化</h1><p>内置类型的变量未被显式初始化，它的值酱油定义的位置决定。定义与任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将<strong>不被初始化</strong>，即它的值为<code>undefined</code>。</p><h1 id="11-变量声明和定义的关系"><a href="#11-变量声明和定义的关系" class="headerlink" title="11. 变量声明和定义的关系"></a>11. 变量声明和定义的关系</h1><p>为了支持分离式编译，C++将声明和定义区分开。<br>声明：使名字被程序所知。<br>定义：创建于名字相关的实体。<br>变量声明规定了变量的类型和名字。定义在该作用之上，还申请了内存空间，也可能为变量赋一个初始值。<br>如果只想声明，不想定义，则需要<code>extern</code>关键字。<br><code>extern int i; //声明i而非定义i</code><br><code>int j; //声明并定义j</code><br><code>extern double pi = 3.14 //定义pi</code><br>任何包含了<strong>显式初始化的声明</strong>即成为<strong>定义</strong>。能给<code>extern</code>标记的变量赋初始值，但是这会抵消掉<code>extern</code>的作用，因此包含初始值的<code>extern</code>语句就不是声明，而是定义了。</p><h1 id="12-标识符"><a href="#12-标识符" class="headerlink" title="12. 标识符"></a>12. 标识符</h1><p>C++的标识符由字母、数字、下划线组成，也就是俗称的<strong>变量名</strong>。</p><h1 id="13-如何显式访问全局变量？"><a href="#13-如何显式访问全局变量？" class="headerlink" title="13. 如何显式访问全局变量？"></a>13. 如何显式访问全局变量？</h1><p>如果局部变量覆盖了全局变量，可以显式地访问全局变量：<code>::var</code></p><h1 id="15-异常处理"><a href="#15-异常处理" class="headerlink" title="15. 异常处理"></a>15. 异常处理</h1><h2 id="15-1-如果捕获不到异常？"><a href="#15-1-如果捕获不到异常？" class="headerlink" title="15.1. 如果捕获不到异常？"></a>15.1. 如果捕获不到异常？</h2><p>当异常抛出时，首先搜索抛出该异常的函数，如果没有找到匹配的<code>catch</code>，那就终止该函数，并向上层函数继续寻找。如果最终还是找不到，程序会转到名为<code>terminate</code>的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p><h2 id="15-2-stdexcept"><a href="#15-2-stdexcept" class="headerlink" title="15.2. stdexcept"></a>15.2. stdexcept</h2><p>在标准库<code>&lt;stdexcept&gt;</code>中，定义了一些异常类。其中的<code>exception</code>, <code>bad_alloc</code>和<code>bad_cast</code>对象只能使用默认初始化，其他的类可以接收字符串来初始化。<br>异常类型只定义了一个名为<code>what</code>的成员函数，没有参数，返回一个指向C风格字符串的<code>const char*</code>。</p><h1 id="16-运算"><a href="#16-运算" class="headerlink" title="16. 运算"></a>16. 运算</h1><h2 id="16-1-左值和右值"><a href="#16-1-左值和右值" class="headerlink" title="16.1. 左值和右值"></a>16.1. 左值和右值</h2><p>在C语言中，两者区别比较简单：左值可以位于赋值语句的左侧，而右值不行。<br>在C++中，区别变复杂了。简单归纳：</p><ul><li>当对象被用作右值的时候，用的是对象的值（内容）</li><li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li></ul><p>运算对象和求值结果都是右值<br>赋值运算时，无论左侧运算对象是什么类型，初始值列表都可以为空。</p><h2 id="16-2-为什么a-x3D-b比a-x3D-a-b更快？"><a href="#16-2-为什么a-x3D-b比a-x3D-a-b更快？" class="headerlink" title="16.2. 为什么a+&#x3D;b比a&#x3D;a+b更快？"></a>16.2. 为什么a+&#x3D;b比a&#x3D;a+b更快？</h2><p><code>+=</code>这种复合运算符只求值一次，而普通运算符求值两次，包括一次加法运算和一次赋值运算。</p><h2 id="16-3-用i-还是-i"><a href="#16-3-用i-还是-i" class="headerlink" title="16.3. 用i++还是++i?"></a>16.3. 用i++还是++i?</h2><p>除非必要，否则不要用递增递减运算符的后置版本。<br>前置版本避免了不必要的运算，它直接改变变量本身的值。后置版本需要先将原始值拷贝，再修改值，返回原始值的拷贝。如果我们用不到原始值，那么后置版本就产生了浪费。</p><h2 id="16-4-运算对象可按任意顺序求值"><a href="#16-4-运算对象可按任意顺序求值" class="headerlink" title="16.4. 运算对象可按任意顺序求值"></a>16.4. 运算对象可按任意顺序求值</h2><p><code>*beg = toupper(*beg++)</code><br>这样的代码会产生未定义行为。编译器不一定先计算左边还是右边，所以最后可能赋值到<code>*beg</code>上，也可能是<code>*(beg+1)</code>上。</p><h1 id="17-显式类型转换"><a href="#17-显式类型转换" class="headerlink" title="17. 显式类型转换"></a>17. 显式类型转换</h1><h2 id="17-1-static-cast"><a href="#17-1-static-cast" class="headerlink" title="17.1. static_cast"></a>17.1. static_cast</h2><h2 id="17-2-const-cast"><a href="#17-2-const-cast" class="headerlink" title="17.2. const_cast"></a>17.2. const_cast</h2><h2 id="17-3-reinterpret-cast"><a href="#17-3-reinterpret-cast" class="headerlink" title="17.3. reinterpret_cast"></a>17.3. reinterpret_cast</h2><h2 id="17-4-dynamic-cast"><a href="#17-4-dynamic-cast" class="headerlink" title="17.4. dynamic_cast"></a>17.4. dynamic_cast</h2><h1 id="18-流程控制"><a href="#18-流程控制" class="headerlink" title="18. 流程控制"></a>18. 流程控制</h1><h2 id="18-1-悬垂else"><a href="#18-1-悬垂else" class="headerlink" title="18.1. 悬垂else"></a>18.1. 悬垂else</h2><p>C++规定else与离它最近的尚未匹配的if匹配。</p><h2 id="18-2-switch语句"><a href="#18-2-switch语句" class="headerlink" title="18.2. switch语句"></a>18.2. switch语句</h2><ul><li>和<code>case</code>关键字对应的是case标签，必须是<strong>整形常量表达式</strong>。</li><li>C++的switch是瀑布流式的，如果没有<code>break</code>关键字，会执行匹配到的case之后所有的case。</li><li>由于需要通过<code>break</code>来控制代码指定范围，所以理论上不需要花括号，但是还是建议使用，因为这样可以限定局部变量的作用域。</li></ul><h2 id="18-3-for语句头中的多重定义"><a href="#18-3-for语句头中的多重定义" class="headerlink" title="18.3. for语句头中的多重定义"></a>18.3. for语句头中的多重定义</h2><p>和其他声明一行，for语句中的init-statement只能有一条声明语句。因此，可以同时声明多个变量，但是类型必须相同。</p><h2 id="18-4-do-while"><a href="#18-4-do-while" class="headerlink" title="18.4. do while"></a>18.4. do while</h2><p><code>do while</code>至少会执行一次循环。</p><h1 id="19-位运算"><a href="#19-位运算" class="headerlink" title="19. 位运算"></a>19. 位运算</h1><h2 id="19-1-关于符号位"><a href="#19-1-关于符号位" class="headerlink" title="19.1. 关于符号位"></a>19.1. 关于符号位</h2><p>当左移一个带符号且为负数的整数时，如何处理符号位是取决于机器的，算是未定义。因此建议仅将位运算用于处理<code>unsigned</code>类型。</p><h1 id="20-复合类型"><a href="#20-复合类型" class="headerlink" title="20. 复合类型"></a>20. 复合类型</h1><h2 id="20-1-引用"><a href="#20-1-引用" class="headerlink" title="20.1. 引用"></a>20.1. 引用</h2><p>引用必须被初始化，即定义的时候必须明确并立刻指出要引用哪个变量，而且引用只能在初始化时绑定一次，不能重复绑定。<br>因为引用本身不是对象，所以不能定义引用的引用。<br>因为引用本身不是对象，所以不能定义指向引用的指针。</p><h2 id="20-2-指针"><a href="#20-2-指针" class="headerlink" title="20.2. 指针"></a>20.2. 指针</h2><p>过去的程序中会用到<code>NULL</code>的预处理变量来给指针赋值，这个变量定义在头文件<code>cstdlib</code>中，值为0。预处理变量会被预处理器自动替换为实际值，所以用<code>NULL</code>初始化指针和用0是一样的。但是，直接把int变量赋值给指针是错误的行为，既是int变量的值恰好等于0也不行。<br>在新标准下，推荐使用<code>nullptr</code>，同时尽量避免使用<code>NULL</code>。<br><code>void*</code>指针可以指向任何类型的对象。因此，不应该直接操作<code>void*</code>指针指向的对象，因为该对象的类型是未知的，允许的操作也是未知的。<br>面对一条复杂的指针或引用的声明语句时，从右往左读比较容易。</p><h2 id="20-3-const"><a href="#20-3-const" class="headerlink" title="20.3. const"></a>20.3. const</h2><p><code>const</code>对象一旦创建后其值就不能再改变了，所以<code>const</code>对象必须初始化。<br>当以编译时初始化的方式定义一个对象时：<br><code>const int buf = 512;</code><br>编译器在编译过程中就会将所有用到该变量的地方全部替换成512。凡是使用了<code>const</code>对象的文件都要求能访问到<code>const</code>对象，因此在默认状况下，<code>const</code>对象仅在文件内有效。多个文件中的同名<code>const</code>对象相当于分别定义在不同文件中的独立变量。<br>但是有时，我们需要<code>const</code>变量的初始值不是一个常量表达式，又有必要在文件间共享，则需要避免编译器为每个文件生成独立的变量。解决方法是对于<code>const</code>变量，不管是声明还是定义，都添加<code>extern</code>关键字。</p><h2 id="20-4-const的引用"><a href="#20-4-const的引用" class="headerlink" title="20.4. const的引用"></a>20.4. const的引用</h2><p>“常量引用”指对const的引用。<br>常量引用只对引用做出了限制，并不限制引用的对象本身。即我们无法通过常量引用来修改引用对象，但是引用对象本身可以修改自己。</p><h2 id="20-5-指针和const"><a href="#20-5-指针和const" class="headerlink" title="20.5. 指针和const"></a>20.5. 指针和const</h2><p>指向常量的指针允许指向一个非常量对象。和常量引用一样，所谓的指向常量的引用和指针，只是他们自以为自己指向了常量，限制了自己不去改变本体，但并没有限制本体。<br>把*放在<code>const</code>之前，表示这个指针是一个常量，指这个指针不能改变自己的值，即<strong>不能更换所指的对象</strong>，但是<strong>可以修改所指的对象的值</strong>。</p><h2 id="20-6-顶层const"><a href="#20-6-顶层const" class="headerlink" title="20.6. 顶层const"></a>20.6. 顶层const</h2><p>顶层const：指针本身是一个常量<br>底层const：指针所指的对象是一个常量</p><h2 id="20-7-constexpr和常量表达式"><a href="#20-7-constexpr和常量表达式" class="headerlink" title="20.7. constexpr和常量表达式"></a>20.7. constexpr和常量表达式</h2><p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。在一个复杂系统中，很可能定义了一个const变量， 但是它的值不是一个常量表达式。C++11中，允许将变量声明为<code>constexpr</code>以便由编译器来严重变量是否为一个常量表达式（是否可以在编译阶段就被替换）。<br>推荐写法：如果认定某个变量是常量表达式，那么就把它声明为<code>constexpr</code>类型。</p><h1 id="21-处理类型"><a href="#21-处理类型" class="headerlink" title="21. 处理类型"></a>21. 处理类型</h1><h2 id="21-1-类型别名"><a href="#21-1-类型别名" class="headerlink" title="21.1. 类型别名"></a>21.1. 类型别名</h2><p>传统方法：使用关键字<code>typedef</code><br>新标准：使用别名声明，<code>using alias = original;</code><br>注意，在阅读使用了<code>typedef</code>的代码时，不要把类型别名替换回去，会导致const的层级发生错乱。</p><h2 id="21-2-auto类型说明符"><a href="#21-2-auto类型说明符" class="headerlink" title="21.2. auto类型说明符"></a>21.2. auto类型说明符</h2><p><code>auto</code>能够根据初始值自动推断类型，相应的，auto定义的变量必须有初始值。<br>编译器会适当地改变推断类型，而不是和初始值的类型一模一样：</p><ul><li>用一个引用作为初始值，推断出来的类型不是引用，而是引动的对象的类型。</li><li>auto一般会忽略顶层const，保留底层const。也就是说推断更基于值。<h2 id="21-3-decltype类型指示符"><a href="#21-3-decltype类型指示符" class="headerlink" title="21.3. decltype类型指示符"></a>21.3. decltype类型指示符</h2>C++11中引入<code>decltype</code>，作用是选择并返回操作数的数据类型。<br>与auto不同，如果<code>decltype</code>使用的表达式是一个变量，那么<code>decltype</code>会保留顶层const和引用等类型。<br>如果表达式的内容是解引用，则得到引用类型。<code>decltype(*p)</code>的结果是<code>int&amp;</code>。<br><code>decltype((var))</code>的结果永远是引用（注意<strong>双层括号</strong>）。</li></ul><h1 id="22-函数"><a href="#22-函数" class="headerlink" title="22. 函数"></a>22. 函数</h1><h2 id="22-1-得到实参的顺序"><a href="#22-1-得到实参的顺序" class="headerlink" title="22.1. 得到实参的顺序"></a>22.1. 得到实参的顺序</h2><p>编译器能以任何可行的顺序对实参求值。</p><h2 id="22-2-形参同名问题"><a href="#22-2-形参同名问题" class="headerlink" title="22.2. 形参同名问题"></a>22.2. 形参同名问题</h2><p>任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能和形参同名。<br>由此可见，形参的作用域等同与还是最外层作用域。</p><h2 id="22-3-函数的返回值类型不能是什么？"><a href="#22-3-函数的返回值类型不能是什么？" class="headerlink" title="22.3. 函数的返回值类型不能是什么？"></a>22.3. 函数的返回值类型不能是什么？</h2><p>函数的返回值类型不能是<strong>数组类型</strong>或者<strong>函数类型</strong>，但是可以是**指向数组或函数的指针。</p><h2 id="22-4-局部静态对象"><a href="#22-4-局部静态对象" class="headerlink" title="22.4. 局部静态对象"></a>22.4. 局部静态对象</h2><p>定义在函数体内部的都是局部变量，加上<code>static</code>就是局部静态变量，这种变量在第一次执行时初始化，并直到冲虚终止才销毁。</p><h2 id="22-5-无返回值的函数"><a href="#22-5-无返回值的函数" class="headerlink" title="22.5. 无返回值的函数"></a>22.5. 无返回值的函数</h2><p>返回类型是void的函数，可以直接写return，还可以返回一个返回void的函数。</p><h2 id="22-6-重载与const形参"><a href="#22-6-重载与const形参" class="headerlink" title="22.6. 重载与const形参"></a>22.6. 重载与const形参</h2><p>一个拥有顶层const的形参无法和另一个普通形参区分开来，<del>因为一个普通类型的实参可以隐式转换为const版本</del>，所以这样的重载不可以。  </p><div class="code-wrapper"><pre><code class="hljs">Record lookup(Phone)Record lookup(const Phone)Record lookup(Phone*)Record lookup(Phone* const)</code></pre></div><p>但是，如果形参是<strong>指针或引用</strong>，那么通过区分其指向的是常量对象，还是说他本身是const但是指向普通对象，可以实现函数重载。  </p><div class="code-wrapper"><pre><code class="hljs">Record lookup(Account&amp;)Record lookup(const Account&amp;)Record lookup(Account*)Record lookup(const Account*)</code></pre></div><h2 id="22-7-const-cast与重载"><a href="#22-7-const-cast与重载" class="headerlink" title="22.7. const_cast与重载"></a>22.7. const_cast与重载</h2><p>假设我们已经有一个函数，参数和返回值都是const，现在需要一个接收非常量并返回非常量的版本，可以在内部用<code>const_cast</code>做转换，调用常量版本的函数。</p><h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><p>当函数的参数是若干同类型数据时，可以使用<code>initializer_list</code>作为形参，在调用函数的时候使用花括号即可。</p><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p><code>lambda</code>会被编译器自动转换为匿名类的匿名对象，并行为如同函数，<code>lambda</code>捕获的局部变量的引用会被直接使用，但是传值捕获的变量会被转化为匿名类的成员。</p><p>函数的签名：<code>返回值类型(参数类型,...)</code>。</p><p>由于每个<code>lambda</code>都是不同的匿名类，所以如果需要用容器来保存<code>lambda</code>时，无法用模板来表示，需要转换为标准库<code>functional</code>中的<code>function</code>。</p><p>有重载函数的时候，在要存入function的地方会有歧义，可以使用函数指针或者<code>lambda</code>。</p><h1 id="24-暂未归类"><a href="#24-暂未归类" class="headerlink" title="24. 暂未归类"></a>24. 暂未归类</h1><h2 id="24-1-lt-lt-运算符的顺序"><a href="#24-1-lt-lt-运算符的顺序" class="headerlink" title="24.1. &lt;&lt;运算符的顺序"></a>24.1. <code>&lt;&lt;</code>运算符的顺序</h2><p><code>&lt;&lt;</code>运算符没有明确规定何时以及如何对运算对象求值。<br><code>cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl</code>这样一行代码是未定义的，编译器不一定先求i的值或者++i的值。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>guide</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

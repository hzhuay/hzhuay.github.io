

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JackZhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="6000O Cloud Computing Note1. Cloud Pricing and Economics三种计费模式 Reservation-based Cost(t) &#x3D; Upfront + discount * R(On-demand rate) * t 作用：Guaranteed availability，无论数据中心多么繁忙都能保证资源可用 适合stable worklo">
<meta property="og:type" content="article">
<meta property="og:title" content="6000O Cloud Computing Note">
<meta property="og:url" content="http://example.com/college/6000O-cloud-computing/index.html">
<meta property="og:site_name" content="JackZhu&#39;s Blog">
<meta property="og:description" content="6000O Cloud Computing Note1. Cloud Pricing and Economics三种计费模式 Reservation-based Cost(t) &#x3D; Upfront + discount * R(On-demand rate) * t 作用：Guaranteed availability，无论数据中心多么繁忙都能保证资源可用 适合stable worklo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbnnvd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbu2Y8.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/18/qkkGK1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/18/qkEQXR.png">
<meta property="article:published_time" content="2022-03-13T05:51:28.000Z">
<meta property="article:modified_time" content="2022-09-01T12:41:22.196Z">
<meta property="article:author" content="JackZhu">
<meta property="article:tag" content="云计算">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/03/13/bbnnvd.png">
  
  
  <title>6000O Cloud Computing Note - JackZhu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"PWUY6L4sCMxvtPwVBSD0BIvw-MdYXbMMI","app_key":"XY7eP0VTgdPSguOqoldnhp5e","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jack Zhu</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/wallhaven-57jlo1_1280x720.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="6000O Cloud Computing Note">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-13 13:51" pubdate>
        2022年3月13日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      122 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">6000O Cloud Computing Note</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年9月1日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="6000O-Cloud-Computing-Note"><a href="#6000O-Cloud-Computing-Note" class="headerlink" title="6000O Cloud Computing Note"></a>6000O Cloud Computing Note</h1><h2 id="1-Cloud-Pricing-and-Economics"><a href="#1-Cloud-Pricing-and-Economics" class="headerlink" title="1. Cloud Pricing and Economics"></a>1. Cloud Pricing and Economics</h2><h2 id="三种计费模式"><a href="#三种计费模式" class="headerlink" title="三种计费模式"></a>三种计费模式</h2><ul>
<li><p>Reservation-based</p>
<p>Cost(t) &#x3D; Upfront + discount * R(On-demand rate) * t</p>
<p>作用：Guaranteed availability，无论数据中心多么繁忙都能保证资源可用</p>
<p>适合stable workload</p>
</li>
<li><p>Spot pricing</p>
<p>用户提交一个竞标（bid），云定期查看出价，出价最高的用户竞标成功</p>
<p>通常比on-demand便宜很多，因为没有No service guarantee。用户的bid不会超过on-demand的价格。</p>
<p>偶尔会有spot price很高的情况，是因为服务器把空间资源用spot pricing卖掉，用出价这种方式来回收。</p>
</li>
<li><p>On-demand</p>
</li>
</ul>
<p>为什么要有不同计费模式：</p>
<p>Market segmentation：每种模式适合的用户不同</p>
<p>供应方的问题：</p>
<ul>
<li><p>资源有限</p>
</li>
<li><p>每种类型分配多少资源</p>
</li>
<li><p>每种类型如何定价</p>
</li>
</ul>
<p>用户方的问题：</p>
<ul>
<li>需要预测需求</li>
<li>需要预测spot price的价格，并且想办法活用</li>
</ul>
<p>Cloud brokerage service：专门的公司来解决以上客户问题</p>
<h2 id="Total-Cost-of-Ownership-TCO"><a href="#Total-Cost-of-Ownership-TCO" class="headerlink" title="Total Cost of  Ownership (TCO)"></a>Total Cost of  Ownership (TCO)</h2><p>决定要自己部署本地机房还是用云服务。</p>
<p>Total cost of ownership (TCO)：系统直接和间接成本的估算</p>
<h2 id="提供者如何盈利"><a href="#提供者如何盈利" class="headerlink" title="提供者如何盈利"></a>提供者如何盈利</h2><p>提供者使用资源池和multi-tenant model来服务客户。用不同的物理和虚拟资源来动态分配。</p>
<ul>
<li><p>Location Independence：用户不知道自己的服务是在哪里被实现的。</p>
</li>
<li><p>资源池可以实现很高的资源利用率。</p>
</li>
<li><p>规模经济：机房越大，单价越省</p>
</li>
<li><p>Statistical multiplexing：灵活满足不同的用户在不同时间的资源需求</p>
</li>
</ul>
<h2 id="2-Service-Models-and-Challenges"><a href="#2-Service-Models-and-Challenges" class="headerlink" title="2. Service Models and Challenges"></a>2. Service Models and Challenges</h2><h4 id="Cloud-deployment-models"><a href="#Cloud-deployment-models" class="headerlink" title="Cloud deployment models"></a>Cloud deployment models</h4><ul>
<li>Public</li>
<li>Private：安全、没有网络带宽和可用性问题</li>
<li>Hybrid</li>
</ul>
<h4 id="Cloud-Service-Models"><a href="#Cloud-Service-Models" class="headerlink" title="Cloud Service Models"></a>Cloud Service Models</h4><p>架构：硬件、虚拟化、基础设施、平台、应用</p>
<ul>
<li><p>IaaS</p>
<p>提供者将硬件资源虚拟化，用户得到一台虚拟机，可以完全控制操作系统、存储和网络。典型案例：Netflix</p>
</li>
<li><p>PaaS</p>
<p>提供软件平台，或者中层，来供应用运行。用户要维护和部署他们的应用在平台上。</p>
<p>硬件资源自动分配，用户无法指定。</p>
<p>可以自动扩展，但是用户无法控制操作系统、存储和网络。</p>
</li>
<li><p>SaaS</p>
<p>提供软件和应用，并且来维护。用户只管使用。</p>
</li>
</ul>
<p>从上到下，灵活性和定制性增强，但是便利性和易管理性减弱。</p>
<p>XaaS：</p>
<ul>
<li><p>FaaS（function）</p>
<p>用户通过云函数的形式编写应用，规定触发函数执行的事件。然后云平台接管一切，包括资源分配、自动伸缩、容错等。用户只用根据<strong>CPU时间</strong>来付费。用户不管理服务器，因此也叫<strong>serverless computing</strong></p>
<p>好处：不用管理服务器，全由云提供者来维护；省钱，不用为空闲时间付费；灵活伸缩，由云提供者配置；高可用和高容错</p>
</li>
<li><p>MLaaS</p>
</li>
</ul>
<h4 id="Issues-of-Cloud"><a href="#Issues-of-Cloud" class="headerlink" title="Issues of Cloud"></a>Issues of Cloud</h4><ul>
<li>availability：停电等故障会导致损失</li>
<li>数据丢失</li>
<li>Vendor lock-in：某个云中的应用无法迁移到另一个</li>
<li>安全性</li>
<li>隐私性：云服务商会偷窥数据吗</li>
</ul>
<h4 id="Challenges-facing-cloud-providers"><a href="#Challenges-facing-cloud-providers" class="headerlink" title="Challenges facing cloud  providers"></a>Challenges facing cloud  providers</h4><ul>
<li>storage：大数据集无法存在本地，持久存储必须分布式；本地存储是脆弱的。</li>
<li>Scale：</li>
<li>Faults and failures：机器难免出问题</li>
<li>Networking：带宽、公平性、如何保证网络又快又稳定</li>
<li>Machine heterogeneity：每个机器的硬件都不同，如何保证性能；难以提供可预测和稳定的服务；难以监控系统，识别性能瓶颈，和掉队者的原因；难以达成用户之间的<strong>公平共享</strong>。</li>
</ul>
<p>目标：</p>
<ul>
<li>可以运行在各种规模上</li>
<li>容错</li>
<li>可预测的服务</li>
<li>高利用率</li>
<li>高上行和下行带宽</li>
<li>尽量少的人工干预</li>
</ul>
<h2 id="3-Virtualization"><a href="#3-Virtualization" class="headerlink" title="3. Virtualization"></a>3. Virtualization</h2><p>虚拟化是一个宽泛的术语。它可以应用于所有类型的资源（CPU、内存、网络等）</p>
<p>通过跨多个环境共享一台计算机的资源，允许一台计算机“看起来”像多台计算机，执行多个作业。</p>
<ul>
<li><p>Host：底层的物理机器</p>
</li>
<li><p>Virtual Machine Manger (VMM) or hypervisor：通过提供与主机相同的接口创建和运行虚拟机（半虚拟化情况除外）</p>
</li>
<li><p>virtual machine (VM)：基于软件实现的计算机，可用于运行通用的操作系统</p>
</li>
<li><p>Guest：通常是操作系统</p>
</li>
</ul>
<h3 id="Implementation-of-VMMs"><a href="#Implementation-of-VMMs" class="headerlink" title="Implementation of VMMs"></a>Implementation of VMMs</h3><ul>
<li><p>Type-0 hypervisors</p>
<p><strong>基于硬件</strong>的解决方案，通过固件（firmware）支持虚拟机的创建和管理。常见于大型机和大中型服务器中。</p>
</li>
<li><p>Type-1 hypervisors</p>
<p>类似操作系统的软件，直接在纯粹的基于x86的系统上提供虚拟化层。比如VMWare ESX。本身就类似于OS，其上可以有各种Guest OS。</p>
<p>还包括提供标准功能和VMM功能的通用操作系统。通常没有专用的1型虚拟机监控程序功能丰富</p>
</li>
<li><p>Type-2 hypervisors</p>
<p>VMM本身是一个进程（程序），由主机运行和管理。比如Virtual Box，运行在Host OS之上。</p>
<p>非常易用。由于是通过Host OS来间接访问硬件，性能不好，需要host OS授权，一般是个人使用。</p>
</li>
<li><p>Other variations</p>
<ul>
<li>Para-virtualization：将Guest OS修改为与VMM协作以优化性能的技术。Guest OS知道自己是虚拟机。</li>
<li>Programming-environment virtualization：VMM不会虚拟化真正的硬件，而是创建一个优化的虚拟系统，例如JVM</li>
<li>Emulators：允许为一个硬件环境（如iOS，Android）编写的应用程序在不同的硬件环境中运行</li>
</ul>
</li>
</ul>
<p>Type-1 hypervisors和Para-virtualization是云计算中最流行的。</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>早期的大型机有很多问题：只能是batch-oriented；架构不兼容，升级硬件必须修改软件</p>
<p>MIT研发MAC (Multiple Access Computer)，是一种分时系统</p>
<ul>
<li>隔离：主机系统受VM保护；虚拟机相互保护</li>
<li>冻结、暂停、运行虚拟机：VM可以暂停和拷贝</li>
<li>有利于研究OS和系统开发</li>
<li>实时迁移</li>
</ul>
<p>计算机有一系列硬件：CPU，内存，IO设备，其他</p>
<p>OS：提供应用软件访问硬件资源的特殊软件层。与任何其他程序一样运行，但以特权（内核）CPU模式运行，将自己保护与用户程序中。可以访问硬件，执行敏感指令。</p>
<ul>
<li>为应用程序提供高级编程接口（系统调用接口），OS实现接口来调用底层设备。</li>
<li>与硬件互动，代表硬件控制程序的指令</li>
</ul>
<p>Application：</p>
<ul>
<li>依赖于系统调用接口的程序，在用户态运行。通过特殊指令来调用OS</li>
<li>MMU硬件允许操作系统给程序提供<strong>虚拟地址空间</strong>，让程序认为自己内存充足</li>
</ul>
<h3 id="How-does-virtualization-work"><a href="#How-does-virtualization-work" class="headerlink" title="How does virtualization work?"></a>How does virtualization work?</h3><p>如果将OS（比如Windows）当做用户态的程序运行，大部分时间是可行的，但是：</p>
<ul>
<li>如果需要进入内核态执行敏感指令？</li>
<li>Guest OS该用那个硬件？</li>
<li>如何保护Guest OS上的程序不会伤害GuestOS</li>
</ul>
<h4 id="Trap-and-emulate"><a href="#Trap-and-emulate" class="headerlink" title="Trap-and-emulate"></a>Trap-and-emulate</h4><p>Guest OS必须运行在用户态。Guest VM需要virtual user mode 和  virtual kernel mode，让Guest以为自己在正常运行，但实际上这两个模式都运行在<strong>用户态</strong>。只有VMM可以运行在<strong>内核态</strong>。</p>
<p>GuestOS中导致切换到内核模式的操作必须导致VM切换到虚拟内核模式。</p>
<p>如何从虚拟用户模式切换到虚拟内核模式？</p>
<ol>
<li>Trap：Guest在用户模式下尝试特权指令会导致错误——主机陷阱到内核模式</li>
<li>Emulate：VMM获得控制权，分析错误，模拟Guest尝试的指令的效果。VMM为Guest提供了一个虚拟硬件&#x2F;软件接口</li>
<li>Return：VMM在用户模式下将控制权返回给Guest</li>
</ol>
<h4 id="Correctness-requirement"><a href="#Correctness-requirement" class="headerlink" title="Correctness requirement"></a>Correctness requirement</h4><p>指令有两种：</p>
<ul>
<li>Privileged instructions：当CPU处于用户态时，被trap（需要内核态）</li>
<li>Sensitive instructions：修改（虚拟）硬件配置或资源的指令，以及行为依赖于（虚拟）硬件配置的指令，比如读写，设置寄存器</li>
</ul>
<p>Emulation is only needed for sensitive instructions</p>
<p>Popek &amp; Goldberg要求：如果敏感指令集是特权指令的子集，则可以高效且安全地构造VMM。这是对CPU架构的要求，但好多CPU不支持，有些敏感指令会运行在用户态。</p>
<h4 id="How-about-the-performance"><a href="#How-about-the-performance" class="headerlink" title="How about the performance?"></a>How about the performance?</h4><p>如果Popek &amp; Goldberg要求达到，那么性能会如何？</p>
<ul>
<li><p>Non-sensitive instructions：几乎没有开销，虚拟机和真机几乎一样快。</p>
</li>
<li><p>Sensitive instructions：如果引发trap，必须被引导到VMM并被其模拟。每一条指令可能需要数十条本机指令来模拟。</p>
<p>I&#x2F;O或系统调用密集型应用程序受到重创。</p>
</li>
</ul>
<h4 id="Trap-and-emulate并不总是管用（重点）"><a href="#Trap-and-emulate并不总是管用（重点）" class="headerlink" title="Trap-and-emulate并不总是管用（重点）"></a>Trap-and-emulate并不总是管用（重点）</h4><p>Trap-and-emulate依赖CPU error来捕获特权指令，如果所有的敏感指令都是特权指令，那么VMM可以提前预知到所有的敏感指令。</p>
<p>Intel架构不符合要求。popf指令，从堆栈内容加载CPU标志寄存器。</p>
<ul>
<li>如果CPU在内核态：所有flag都被替换</li>
<li>如果CPU在用户态：只有部分flag被替换，并且不会陷入内核态。</li>
</ul>
<p>Prof是敏感但不特权的指令，不能用Trap-and-emulate来虚拟化。</p>
<p>有些CPU没有明确区分特权指令和非特权指令，这使得一些特殊指令无法虚拟化。英特尔CPU直到1998年才被认为是可虚拟化的。</p>
<p>3种解决方法：</p>
<ul>
<li><p>Full virtualization：Emulate + binary translation</p>
</li>
<li><p>Para-virtualization：修改GuestOS以避免不可虚拟化的指令</p>
</li>
<li><p>Hardware-assisted virtualization：修复CPU</p>
</li>
</ul>
<h4 id="Full-virtualization"><a href="#Full-virtualization" class="headerlink" title="Full virtualization"></a>Full virtualization</h4><p><strong>x86 protection rings</strong></p>
<p>Intel x86架构有4个保护级别，从高到底为ring0-3。ring0对应内核态，ring3对应用户态，ring1和ring2在现代OS中不使用。ring0可以执行所有指令。</p>
<p>另Guest OS kernel运行在ring1，每当Guest要运行敏感指令时，Hypervisor会发现，并用binary translation将CPU从ring1陷入ring0，模拟运行结果然后返回。</p>
<p>注意：Full virtualization并不依赖与x86架构</p>
<p>binary translation的思路很简单，但是实现很复杂。</p>
<ul>
<li><p>如果Guest VCPU处于用户模式，guest可以以本机方式运行指令</p>
</li>
<li><p>如果Guest VCPU处于（虚拟）内核模式，hypervisor会检查Guest将要执行的每一条指令</p>
<ul>
<li>非特殊指令自然运行</li>
<li>将特殊指令转换为新的指令集，在仿真硬件中执行等效任务</li>
</ul>
</li>
</ul>
<p>hypervisor向VM的Guest OS提供一整套模拟硬件。无论主机系统上的实际物理硬件是什么，模拟硬件都保持不变。</p>
<p>binary translation的步骤：</p>
<ol>
<li>trapping I&#x2F;O calls：每当GuestPS请求硬件时，例如请求BIOS提供硬件列表，它都会被hypervisor捕获</li>
<li>emulate&#x2F;translate：无法虚拟化的指令被翻译为安全指令</li>
</ol>
<p>GuestOS被欺骗，以为它在ring0中运行特权代码。它实际上运行在主机的ring1中，hypervisor模拟硬件并捕获特权代码。</p>
<p>优点：</p>
<ul>
<li>不需要修改GuestOS</li>
<li>防止不稳定的虚拟机影响系统性能</li>
<li>VM移植性</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有优化，性能就不好。可能的解决方案是：缓存特殊指令的翻译，以避免将来再次翻译</li>
</ul>
<h4 id="Para-virtualization"><a href="#Para-virtualization" class="headerlink" title="Para-virtualization"></a>Para-virtualization</h4><p>旨在通过硬件仿真克服完全虚拟化带来的性能损失。要求修改GuestOS的内核。最著名的实现是<strong>Xen</strong>。云计算中<strong>事实上</strong>的虚拟化技术。</p>
<p>指出Full virtualization是错误方向：对Full virtualization的支持从来都不是x86体系结构设计的一部分。</p>
<ul>
<li>为了实现正确的虚拟化，VMM必须处理某些监控器指令，但在权限不足的情况下执行这些指令会以静默方式失败，而不会造成方便的trap。</li>
<li>高效虚拟化x86 MMU也很困难（需要维护一个影子页表）</li>
<li>这些问题是可以解决的，但代价是复杂性增加和性能降低</li>
</ul>
<p>在某些情况下，GuestOS希望看到真实的和虚拟的资源：</p>
<ul>
<li>提供实时和虚拟时间可以让GuestOS更好地支持对时间敏感的任务，并正确处理TCP超时和RTT估计</li>
<li>公开真实的机器地址允许GuestOS通过使用超级页面或页面着色来提高性能</li>
</ul>
<p>Paravirtualization：权衡对GuestOS的小改动，与性能和VMM简单性方面的大提升。</p>
<p>Modified GuestOS kernel也运行在ring1，通过hypercall来调用Xen Hypervisor。</p>
<h5 id="VM-Memory-Interface"><a href="#VM-Memory-Interface" class="headerlink" title="VM Memory Interface"></a>VM Memory Interface</h5><p>虚拟化内存很难，但如果架构有以下部分则会变简单：</p>
<ul>
<li>一个由软件管理的TLB（转译后备缓冲区），可以有效地虚拟化</li>
<li>标记的TLB（带有地址空间标识符的TLB），不需要在每次转换时刷新</li>
</ul>
<p>不幸的是，这两种功能在x86中都不受支持。VMware的解决方案（full virtualization）使用shadow page  tables，这可能非常慢！</p>
<p>Xen的解决方案（直接页表访问）</p>
<ul>
<li><p>GuestOS允许对<strong>真实页表</strong>进行<strong>只读</strong>访问。<strong>对页表（PT）的更新必须由hypervisor验证</strong>，这确保来GuestOS只能映射到分配给它的物理内存。</p>
</li>
<li><p>GuestOS使用hypercall分配和管理自己的PTs</p>
</li>
<li><p><strong>Xen存在于每个OS地址空间顶部的64MB区域中</strong>，因此在进入和离开虚拟机监控程序时避免了TLB刷新</p>
</li>
</ul>
<h5 id="VM-CPU-Interface"><a href="#VM-CPU-Interface" class="headerlink" title="VM CPU Interface"></a>VM CPU Interface</h5><p>trap&#x2F;expection （系统调用、页面错误）处理程序向Xen注册以进行验证。</p>
<p>GuestOS可能会为系统调用安装一个“快速”异常处理程序，允许应用程序直接调用其GuestOS，并避免在每次调用时通过Xen间接调用</p>
<h5 id="Control-Transfer"><a href="#Control-Transfer" class="headerlink" title="Control Transfer"></a>Control Transfer</h5><p>在Xen中没有硬件中断，都是由软件事件来实现的。Xen用事件来告知GuestOS发生了什么。</p>
<p>Hypercalls：从GuestOS到Xen的同步调用（类似于系统调用）</p>
<h4 id="Para-vs-Full-Virtualization"><a href="#Para-vs-Full-Virtualization" class="headerlink" title="Para vs. Full Virtualization"></a>Para vs. Full Virtualization</h4><p>Full Virtualization</p>
<ul>
<li>不要更改操作系统，除非在运行时（二进制翻译）</li>
<li>性能缓慢（有时不正确）</li>
</ul>
<p>Para Virtualization：</p>
<ul>
<li>对操作系统的更改最少</li>
<li>更好的性能和操作系统与虚拟硬件之间更快的交互</li>
</ul>
<h3 id="Cloud-infrastructures"><a href="#Cloud-infrastructures" class="headerlink" title="Cloud infrastructures"></a>Cloud infrastructures</h3><p>云计算通常与虚拟化有关</p>
<ul>
<li>“高度弹性”</li>
<li>在虚拟化环境中启动新虚拟机既便宜又快速</li>
<li>将多个虚拟机整合到一台物理机器上可以提高利用率</li>
</ul>
<p>云基础设施实际上是一个虚拟机管理基础设施</p>
<p>IaaS:</p>
<ol>
<li>客户端选择一个映像文件来启动VM</li>
<li>控制器选择服务器来承载VM</li>
<li>数据传输</li>
<li>启动VM</li>
</ol>
<p>公有云总是需要虚拟技术，对于私有云而言不一定，谷歌的集群都是建立在裸机之上的：高效而无性能损失。Container</p>
<h2 id="4-Container-Virtualization"><a href="#4-Container-Virtualization" class="headerlink" title="4. Container Virtualization"></a>4. Container Virtualization</h2><p>Configure once, run anything。一次配置，到处运行。</p>
<p>VM vs. Containers：容器是隔离的，但是共享OS、bins&#x2F;库</p>
<p>虚拟机系统调用路径：</p>
<ul>
<li>虚拟机内部的应用程序进行系统调用</li>
<li>陷入Hypervisor（或主机操作系统）</li>
<li>把trap还给GuestOS</li>
</ul>
<p>容器虚拟化系统调用路径</p>
<ul>
<li>容器内的应用程序进行系统调用</li>
<li>陷入OS</li>
<li>操作系统将结果返回给应用程序</li>
</ul>
<p>从高层看，容器就是轻量的VM</p>
<ul>
<li>有自己的进程空间</li>
<li>自己的网络接口</li>
<li>可以以root运行</li>
<li>可以有自己的 &#x2F;sbin&#x2F;init</li>
</ul>
<p>从底层看：容器就是一个隔离的进程</p>
<p>容器的实现利用Linux内核机制</p>
<ul>
<li>namespace：每个进程的资源独立</li>
<li>cgroups：管理流程组的资源</li>
<li>seccomp：限制可用的系统调用</li>
<li>capabilities：限制可用权限</li>
<li>CRIU：checkpoint&#x2F;restore (w&#x2F; kernel support)</li>
</ul>
<p>什么name需要虚拟化：</p>
<ul>
<li>进程ID：<code>top</code>指令在容器中只显示容器中的进程。在容器外部，<code>top</code>指令可能会显示容器内的进程ID，但是可能不同。</li>
<li>文件名：容器内的进程可能对装载的文件系统有有限的不同视图。文件名可能会解析为不同的名称，容器外的一些文件名可能会被删除。</li>
<li>用户名：容器可能有不同的用户和不同的角色。容器内的<code>root</code>不一定是外部的<code>root</code></li>
<li>主机名和IP地址：容器内的进程在执行网络操作时可能会使用不同的主机名和IP地址。</li>
</ul>
<p>在进程粒度上限制内核端<strong>名称</strong>和数据结构的范围。</p>
<p>三个系统调用来管理：clone(), unshare(), setns(int fd, int nstype)</p>
<p>资源管理：操作系统可能希望确保整个容器，或其中运行的所有东西，消耗的能量不能超过一定量的CPU时间、内存、硬盘或者网络带宽。</p>
<p><strong>cgroups：Linux控制组</strong></p>
<p>控制组子系统为一组流程提供资源管理解决方案。<br>每个子系统都有一个层次结构（树），CPU、内存、块I&#x2F;O有独立的层次结构。每个进程都位于每个层次结构中的一个节点中，每个节点都是一组共享资源的进程。</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Container：一种基于cgroup和名称空间等内核机制的轻量级资源虚拟化。<br>多个容器在同一个内核上运行，并误以为它们是唯一使用资源的容器。</p>
<h2 id="5-Distributed-Storage-System"><a href="#5-Distributed-Storage-System" class="headerlink" title="5. Distributed Storage System"></a>5. Distributed Storage System</h2><p>就算能把单个硬盘做得足够大，也无法解决IO瓶颈，伸缩性很差。<br>CPU运算速度远高于硬盘读取速度。<br>建造一台高端超级计算机的成本非常非常高。<br>将所有数据存储在一个位置会增加硬件故障的风险。</p>
<p>Google的解决方式：向外扩展，而不是向上扩展。增加更多机器，而不是把机器做大。</p>
<p>许多廉价的、商品化的PC，每台都有磁盘和CPU。<br>高总存储容量，而不是增加单个硬盘的容量。<br>在多台机器上分散搜索处理：高I&#x2F;O带宽，与机器的数量成比例；并行化数据处理。</p>
<p>注意：机器越多，每个时刻可能有机器出问题的概率越大。</p>
<p>在大范围内，超级花哨的可靠硬件仍然会失败，尽管失败的频率较低。</p>
<p>可靠性必须来自<strong>软件</strong>！</p>
<p>GFS：建立在高度不可靠硬件之上的高度可靠的存储系统</p>
<h3 id="Target-environment（系统假设）"><a href="#Target-environment（系统假设）" class="headerlink" title="Target environment（系统假设）"></a>Target environment（系统假设）</h3><p>大量机器、分布式、出错时正常的<br>文件很大，但是数量不多。&gt;100M，一般是几个G大，几百万个文件。<br>一次写入，多次读取。文件通过追加来修改。大的流式读取和小的随机读取是典型的。<br>I&#x2F;O带宽比延迟更重要。适用于批处理和日志分析。<br>如果文件系统为并发附件提供同步，这会很有帮助。</p>
<h3 id="Design-Decisions"><a href="#Design-Decisions" class="headerlink" title="Design Decisions"></a>Design Decisions</h3><p>文件存储被分为数据块，大小为64MB。小于单个块的文件<strong>不会</strong>占用整个块的存储空间。</p>
<p>为什么使用大块：将磁盘搜索的成本降至最低；将文件传输速率提高到磁盘传输速率（传输时间远大于检索时间，2者相加等于文件传输时间 ）</p>
<p><strong>通过复制实现可靠性</strong><br>3-way replication：每个区块在3个以上的区块服务器上复制，同一个rack有一个副本，其他rack上有2+副本。</p>
<p>单master协调访问：维护元数据（文件名、权限、区块索引、文件夹层次结构等）。<br>文件数据存储在其他服务器上。访问数据需要向master申请。</p>
<p>添加<strong>记录追加</strong>操作，支持实时追加。</p>
<h3 id="General-Architecture"><a href="#General-Architecture" class="headerlink" title="General Architecture"></a>General Architecture</h3><p>Single master, Multiple chunkservers</p>
<ol>
<li>用file name和chunk index，向GFS Master查询</li>
<li>Master返回chunk的信息（chunk handle和locations）</li>
<li>客户向chunk server发送chunk句柄和byte range</li>
<li>chunkserver返回data</li>
</ol>
<p>可能的问题：</p>
<ol>
<li><p>Single point of failure：如果master掉线怎么办、</p>
<p>增加<strong>shadow master</strong></p>
</li>
<li><p>Scalability bottleneck：如果master遇到瓶颈怎么办</p>
<p>尽量减少主机参与，以解决可扩展性问题</p>
<ul>
<li>不参与数据传输，只用做元数据</li>
<li>大chunk：最小化搜索&#x2F;索引时间</li>
<li><strong>chunk leases</strong>：master将权限委托给数据中的主副本</li>
</ul>
</li>
</ol>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>三种元数据都保存在内存中</p>
<ul>
<li>文件和chunk的命名空间</li>
<li>从文件到chunk的映射（每个chunk都有一个唯一的ID）</li>
<li>每个chunk副本的位置</li>
</ul>
<p>前2种类型通过<strong>操作日志</strong>持久化。</p>
<p>第3种操作通过在启动时轮询chunkservers获得的区块副本位置。Chunkserver是其持有的区块的最终仲裁者 </p>
<h4 id="Master的职责"><a href="#Master的职责" class="headerlink" title="Master的职责"></a>Master的职责</h4><ul>
<li>元数据存储</li>
<li>命名空间管理&#x2F;锁定</li>
<li>与服务器的定期通信：给出指示、收集状态、跟踪群集运行状况</li>
<li>区块创建、重新复制、重新平衡<ul>
<li>在racks上分散副本，减少错误</li>
<li>如果冗余低于阈值，则重新复制数据</li>
</ul>
</li>
<li>垃圾回收：比传统的文件删除更简单、更可靠<ul>
<li>master记录删除，将文件重命名为隐藏名称，惰性回收隐藏文件</li>
</ul>
</li>
<li>过时副本删除：使用ckunk版本号检测“过时”副本</li>
</ul>
<h4 id="Chunkserver"><a href="#Chunkserver" class="headerlink" title="Chunkserver"></a>Chunkserver</h4><ul>
<li>在本地磁盘上存储64 MB的文件块，每个块都有<strong>版本号</strong>和校验和。</li>
<li>读&#x2F;写请求指定块<strong>句柄</strong>和<strong>字节范围</strong>。</li>
<li>在可配置数量的Chunkserver上复制的区块（默认：3-way复制）</li>
<li>无文件数据缓存</li>
</ul>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><ul>
<li>向master发出控制（元数据）请求，比如<code>ls</code>命令</li>
<li>直接向服务器发出数据请求，比如<code>cat</code>命令</li>
<li>缓存的不是文件数据，而是元数据，这样可以减少与master的交互</li>
</ul>
<h3 id="File-read-and-write"><a href="#File-read-and-write" class="headerlink" title="File read and write"></a>File read and write</h3><p>文件读取：</p>
<ol>
<li>应用程序发起读取请求</li>
<li>GFS客户端翻译请求并将其发送给master </li>
<li>Master使用块句柄和副本位置进行响应</li>
<li>客户端选择“<strong>最近</strong>”的位置并发送请求（chunk句柄，比特范围）</li>
<li>Chunkserver将请求的数据发送到客户端</li>
<li>客户端将数据转发给应用程序</li>
</ol>
<p>文件写入：</p>
<ol>
<li>申请发起请求</li>
<li>GFS客户端翻译请求并将其发送给master </li>
<li>Master使用块句柄和副本位置进行响应</li>
<li>客户端将写入数据推送到所有位置。数据存储在区块服务器的内部缓冲区中。buffer满了就写入到disk。<ul>
<li>客户可能同时向3个服务器发送数据，也可能使用管道，向最近的服务器发送数据，该服务器再把数据复制到其他服务器。</li>
</ul>
</li>
<li>客户端向primary发送写命令</li>
<li>Primary确定其缓冲区中数据突变的顺序，并按顺序写入数据块。</li>
<li>Primary将串行命令发送给Secondary，并告诉它们执行写操作</li>
<li>Secondary回应primary</li>
<li>primary回应客户</li>
</ol>
<h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><p>如果是写入出错，就重写。通过检查checksum跳过不一致的文件区域。</p>
<p>chunkserver定时要向master报告状态。Master检测到chunkserver出现故障的“心跳”</p>
<p>如果chunkserver出错：</p>
<ul>
<li>Master会减少dead chunkserver上所有区块的副本数。</li>
<li>Master将丢失副本的块重新复制到其他地方</li>
</ul>
<p>特点：</p>
<ul>
<li>高可用性<ul>
<li>快速恢复：master和纯看server可以在几秒内重启</li>
<li>区块副本：默认情况下为3个副本</li>
<li>Shadow master</li>
</ul>
</li>
<li>数据完整性：每个chunk中每64KB块就有一个checksum</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>读取可以达到网络上限的75-80%，写入可以达到50%，客户越多带宽越大。</p>
<p>GFS演示了如何在商品硬件上支持大规模处理工作负载</p>
<ul>
<li>容忍频繁的组件故障（故障是常态，而不是例外）</li>
<li>优化主要附加然后按顺序读取的大型文件</li>
<li>为许多并发读写器提供高聚合吞吐量</li>
</ul>
<p>限制：</p>
<ul>
<li>假设一次写入，多次读取</li>
<li>假设大文件数量适中：large chunk会导致，如果许多客户端访问同一个文件，小文件会在chunkserver上形成热点。</li>
</ul>
<h2 id="6-Hadoop-Distributed-File-System"><a href="#6-Hadoop-Distributed-File-System" class="headerlink" title="6. Hadoop Distributed File System"></a>6. Hadoop Distributed File System</h2><h3 id="HDFS-overview"><a href="#HDFS-overview" class="headerlink" title="HDFS overview"></a>HDFS overview</h3><p>HDFS是GFS的<strong>开源</strong>实现，是一种<strong>文件系统</strong>，用于存储具有<strong>流式数据访问模式</strong>的<strong>非常大的文件</strong>，运行在<strong>商用硬件</strong>集群上</p>
<p>设计假设：</p>
<ul>
<li>廉价的商品机器：在大型集群中，错误是常态而不是意外</li>
<li>“适度”数量的非常大的文件：几百万个大于100MB的文件</li>
<li>批处理：<ul>
<li>一次写入，大部分追加（可能同时）</li>
<li><strong>流式读取</strong>，而不是随机数据访问</li>
<li><strong>高持续吞吐量</strong>优于低延迟</li>
</ul>
</li>
</ul>
<p>HDFS的设计和GFS很像：</p>
<ul>
<li><p>NameNode：用于管理文件系统元数据的单个主机</p>
</li>
<li><p>DataNode (chunkserver)</p>
<ul>
<li><p>多个DataNode用于存储和检索数据</p>
</li>
<li><p>向NameNode报告托管的块列表</p>
</li>
</ul>
</li>
<li><p>SecondaryNameNode (shadow master)：执行checkpointing</p>
</li>
<li><p>整个集群的单个命名空间</p>
</li>
<li><p>数据一致性：写入一次，读取多次</p>
</li>
<li><p>文件被分成块：每块<strong>128MB</strong>，每个块在多个数据节点上复制</p>
</li>
<li><p>智能客户端：客户端可以找到块的位置；客户端直接从数据节点访问数据</p>
</li>
</ul>
<p>不同点：</p>
<ul>
<li>早期版本的每个文件只有一个编写器</li>
<li>更早的版本不支持记录附加操作</li>
<li>开源，为不同的文件系统提供了许多接口和库</li>
</ul>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><ul>
<li>管理文件系统名称空间<ul>
<li>将文件名映射到一组块</li>
<li>将块映射到其所在的数据</li>
</ul>
</li>
<li>节点群集配置</li>
<li>管理复制引擎用于块</li>
</ul>
<p>metadata：存储在内存中，记录了文件列表、每个文件的区块列表、文件属性、每个block在哪些DataNode。</p>
<p>事务日志：记录文件创建、文件删除等（metadata的前三项）</p>
<h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><ul>
<li>在本地文件系统中保存数据</li>
<li>保存区块的metadata</li>
<li>向用户提供数据和元数据</li>
<li>定期向NameNode报告“心跳”</li>
<li>报告Block report：定期（默认情况下为1小时）向NameNode发送所有现有块的报告</li>
<li>促进数据的管道化：将数据转发到其他指定的DataNode</li>
</ul>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>和GFS类似。但是如何选择最近的chunkserver呢？</p>
<p>不同的racks由Rack switch连接，Rack switch由Aggregation switch连接，形成一个树形结构。</p>
<ul>
<li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r1&#x2F;n1) &#x3D; 0 (在同一个节点)</li>
<li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r1&#x2F;n2) &#x3D; 2 (同一个rack的不同节点)</li>
<li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d1&#x2F;r2&#x2F;n3) &#x3D; 4 (同一个数据中心的不同rack)</li>
<li>dist(&#x2F;d1&#x2F;r1&#x2F;n1, &#x2F;d2&#x2F;r3&#x2F;n4) &#x3D; 6 (不同的数据中心)</li>
</ul>
<p>区块放置：当前策略（可替换为定制策略）</p>
<ul>
<li>本地节点上有一个副本</li>
<li>同一远程机架的两个节点上有第二个和第三个副本</li>
<li>随机放置其他副本</li>
</ul>
<p>一旦选择了复制副本位置，就会构建一个<strong>管道</strong>。</p>
<h3 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h3><p>错误处理：每三秒，DataNodes将心跳发送到NameNode。NameNode使用心跳来检测DataNode故障，10分钟内没有响应被视为失败。</p>
<p><strong>复制引擎</strong>在检测到数据节点故障时，选择一个新的DataNode放置副本，平衡磁盘用量，平衡负载。</p>
<p>数据纠错：</p>
<ul>
<li>验证数据的校验和（CRC32）</li>
<li>文件创建：客户端计算每512字节的校验和，DataNode保存校验和。</li>
<li>文件访问：客户端从DataNodes检索数据和校验和，如果验证失败就寻求其他副本。</li>
</ul>
<p>NameNode failure：单点故障</p>
<ul>
<li>事务日志存储在多个目录中：本地文件系统目录、远程文件系统目录</li>
<li>加入secondary NameNode<ul>
<li>非备用&#x2F;备份名称节点：仅用于检查点，具有FSImage的非实时副本</li>
<li>复制NameNode的FSImage和事务日志，将它们合并到一个新的FSImage</li>
<li>将新的FSImage上载到NameNode并清除事务日志</li>
</ul>
</li>
</ul>
<h3 id="限制（不满足）"><a href="#限制（不满足）" class="headerlink" title="限制（不满足）"></a>限制（不满足）</h3><ul>
<li>低延迟数据访问：数十毫秒范围。HDFS更强调吞吐量而不是延迟</li>
<li>很多小文件：文件数量很多时，所有元数据都在内存中，发生溢出。</li>
<li>多个写入者，随机导致文件修改。</li>
</ul>
<h3 id="Programming-APIs"><a href="#Programming-APIs" class="headerlink" title="Programming APIs"></a>Programming APIs</h3><p><code>org.apache.hadoop.fs</code></p>
<h2 id="7-Map-Reduce"><a href="#7-Map-Reduce" class="headerlink" title="7. Map Reduce"></a>7. Map Reduce</h2><p>并行化问题源于</p>
<ul>
<li>“工作人员之间的通信（如状态交换）”</li>
<li>对共享资源（如数据）的访问</li>
</ul>
<p>因此，我们需要<strong>同步机制</strong>。</p>
<ul>
<li>semaphores（上锁，解锁）</li>
<li>条件变量（wait, notify, broadcast）</li>
<li>barriers（一项工作在完成前置条件之前无法开始）</li>
</ul>
<p>编程模型：shared memory (pthreads)、message passing (MPI)</p>
<p>设计模式：master-slaves、producer-consumer flows、shared work queues</p>
<p>解决典型的大数据问题，涉及5步：</p>
<ul>
<li>对大量记录进行迭代</li>
<li>从每个迭代上提取感兴趣的东西</li>
<li>对中间结果进行洗牌和排序</li>
<li>汇总中间结果</li>
<li>生成最终输出</li>
</ul>
<p>其中前2步是Map，后3步是Reduce。</p>
<p>关键思想：为这两个操作提供一个功能抽象</p>
<p>函数式编程：函数式操作从不修改现有的数据集，但会创建新的数据集。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbnnvd"><img src="https://s1.ax1x.com/2022/03/13/bbnnvd.png" srcset="/img/loading.gif" lazyload alt="bbnnvd.png" style="zoom:50%;" /></a></p>
<p>如果中间有一个worker出问题了，那么它的计算就要重新进行一次，然后重新fold。</p>
<p>map函数可以任意，但是fold函数如果是有顺序要求的，那么不同节点的先后完成顺序会影响到结果。</p>
<p>因此要求fold函数有交换性（Commutativity）和结合性（Associativity）</p>
<p><strong>MapReduce的编程模型借鉴了函数式编程</strong></p>
<p>来自数据源的记录作为<strong>键值对</strong>提供</p>
<ul>
<li>map (k, v) → [&lt;k2, v2&gt;] </li>
<li>reduce (k2, [v2]) → [&lt;k3, v3&gt;]</li>
</ul>
<p>具有<strong>相同键</strong>的<strong>所有值</strong>都被发送到同一个reducer。执行框架来处理<strong>其他事情</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbu2Y8"><img src="https://s1.ax1x.com/2022/03/13/bbu2Y8.png" srcset="/img/loading.gif" lazyload alt="bbu2Y8.png" style="zoom:50%;" /></a></p>
<p>什么是其他事情？</p>
<ul>
<li>调度：分配worker、负载均衡</li>
<li>处理数据分布：将处理器移向数据、自动并行</li>
<li>处理同步：收集、排序、洗牌中间数据；网络和硬盘传输优化</li>
<li>处理错误：发现worker失败和重启</li>
</ul>
<p>除了Map和Reduce函数，程序员还可以（可选）指定combiner和partitioner</p>
<p><code>combine (k, [v]) → &lt;k, v&gt;</code><br>mini-reducer，在内存中运行，在map后立刻运行，只处理本次map得到的数据。</p>
<p><code>partition (k, # of partitions) → partition for k</code><br>为并行reduce操作划分密钥空间。通常是密钥的简单散列，例如<code>hash(k) mod n</code></p>
<p><strong>Barrier</strong>在map和reduce之间。<br>map都完成了，reduce才能开始。但我们可以更早地开始将中间数据传输到执行map的管道shuffling中。</p>
<p>Key按照排序顺序到达每个reducer。reducer之间没有强制排序。类似于归并排序，每个reducer内按照key顺序到达和处理，但是互相没有排序关系。 </p>
<h2 id="8-Hadoop"><a href="#8-Hadoop" class="headerlink" title="8. Hadoop"></a>8. Hadoop</h2><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><ul>
<li><code>void setup(Mapper.Context context)</code>：任务开始前初始化 </li>
<li><code>void map(K key, V value, Mapper.Context context)</code>: 对每个键值对调用</li>
<li><code>void cleanup(Mapper.Context context)</code>: 结束时调用</li>
</ul>
<h4 id="Reducer-x2F-Combiner"><a href="#Reducer-x2F-Combiner" class="headerlink" title="Reducer&#x2F;Combiner"></a>Reducer&#x2F;Combiner</h4><ul>
<li><code>void setup(Reducer.Context context)</code></li>
<li><code>void reduce(K key, Iterable value, Reducer.Context  context)</code>：每个key调用一次</li>
<li><code>void cleanup(Reducer.Context context)</code></li>
</ul>
<h4 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h4><ul>
<li><code>int getPartition(K key, V value, int numPartitions)</code></li>
</ul>
<h4 id="terminology"><a href="#terminology" class="headerlink" title="terminology"></a>terminology</h4><p>Jobs：</p>
<ul>
<li>打包Hadoop程序提交到集群</li>
<li>需要指定输入和输出路径</li>
<li>需要指定输入和输出格式</li>
<li>需要指定映射器、还原器、组合器、分区器</li>
<li>需要指定中间&#x2F;最终键&#x2F;值类</li>
<li>需要指定还原器的数量（但不是映射器，为什么？）</li>
</ul>
<p>Task：在数据片上执行Map或Reduce，也称为Task-In-Progress（TIP）</p>
<p>Task attempt：试图在机器上执行任务的特定实例。某个特定任务将至少尝试一次，如果崩溃，可能会尝试更多次。</p>
<h4 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h4><p>Writable -&gt; WritableComparable -&gt; IntWritable&#x2F;LongWritable&#x2F;Text</p>
<ul>
<li>Writable：定义反序列化&#x2F;序列化协议。Hadoop中的每种数据类型都是Writable。<br>如同java中<code>Object</code>是最原始的基类，<code>Writable</code>是Hadoop中的原始类。</li>
<li>WritableComparable ：定义排序顺序。所有键都必须是这种类型（但不是值）。</li>
<li>IntWritable等：不同数据类型的具体类。</li>
<li>SequenceFile：键值对序列的二进制编码。Java自带的序列化太重了，Hadoop自己用了轻量的。</li>
</ul>
<p>技巧：</p>
<ul>
<li>尽可能避免对象创建——重用可写对象，更改有效负载</li>
<li>执行框架重用reducer中的值对象</li>
<li>通过类静态传递参数</li>
</ul>
<p>如果遇到复杂数据类型，需要想办法用Hadoop支持的类型来表示，或者自己实现Writable接口。</p>
<h2 id="Anatomy-of-Hadoop"><a href="#Anatomy-of-Hadoop" class="headerlink" title="Anatomy of Hadoop"></a>Anatomy of Hadoop</h2><p>基本概念</p>
<p>每个cluster：</p>
<ul>
<li>NameNode：HDFS的master节点</li>
<li>JobTracker：作业提交的master节点</li>
</ul>
<p>每个从属机器需要设定：</p>
<ul>
<li>DataNode：作为HDFS的数据块</li>
<li>TaskTracker：包含多个任务曹</li>
</ul>
<p>Hadoop&#x3D;HDFS+MapReduce</p>
<p>Hadoop有自己的RPC协议。</p>
<p>所有的交流都由slave发起：避免循环等待的死锁；slave周期性报告状态</p>
<p>所有的类都要提供显式的序列化方法，所以Hadoop数据类型必须继承自<code>Writable</code>。</p>
<p>Master节点运行JobTracker实例，接收client的作业申请。</p>
<p>Slave节点运行TaskTracker实例，分配java进程给任务。</p>
<p>Hadoop中的MapReduce程序 &#x3D; Hadoop作业</p>
<p>作业被分为了map任务和reduce任务，多个任务可以整合为workflow。</p>
<p>作业提交：</p>
<ul>
<li>client创建作业，配置，提交到JobTracker。作业是jar文件和XML文件，包含序列化的程序配置选项。</li>
</ul>
<p>运行MapReduce作业：</p>
<ul>
<li>将jar和XML文件放入HDFS</li>
<li>通知TaskTracker从何处检索相关程序代码</li>
</ul>
<p>计算Input splits<br>JobTracker将作业数据放在HDFS的共享位置，排队<br>TaskTrackers轮询任务。</p>
<h4 id="Hadoop-IO"><a href="#Hadoop-IO" class="headerlink" title="Hadoop IO"></a>Hadoop IO</h4><p>输入格式：按行输入，键值对形式，序列化文件</p>
<p>输出格式：键值对，序列化文件</p>
<h4 id="Shuffle-和sort"><a href="#Shuffle-和sort" class="headerlink" title="Shuffle 和sort"></a>Shuffle 和sort</h4><p>Map</p>
<ul>
<li>映射输出缓冲在循环缓冲区中的内存中</li>
<li>当缓冲区达到阈值时，内容溢出到磁盘</li>
<li>溢出合并到单个分区文件中（在每个分区内排序）：合并器在合并期间运行</li>
</ul>
<p>Reduce</p>
<ul>
<li>映射输出被复制到reducer机器上</li>
<li>“sort”是映射输出的多次合并（发生在内存和磁盘上）：合并器在合并过程中运行</li>
<li>最终的合并过程直接进入reducer</li>
</ul>
<h2 id="9-MapReduce-Algorithm-Design"><a href="#9-MapReduce-Algorithm-Design" class="headerlink" title="9. MapReduce Algorithm Design"></a>9. MapReduce Algorithm Design</h2><p>框架负责：</p>
<ul>
<li>调度任务，分配worker去做map和reduce任务</li>
<li>数据分发</li>
<li>同步：收集、排序、洗牌</li>
<li>发现和处理错误</li>
</ul>
<p>程序员只用写mrcp四个函数，无法控制mapper和reducer</p>
<p>但是可以：</p>
<ul>
<li>选择合适的数据类型</li>
<li>中间值key的排序顺序</li>
<li>Partitioner：哪个reducer进程处理哪个key</li>
<li>保存mapper和reducer的状态</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qkkGK1"><img src="https://s1.ax1x.com/2022/03/18/qkkGK1.png" srcset="/img/loading.gif" lazyload alt="qkkGK1.png" style="zoom:50%;" /></a></p>
<p>如何让Hadoop算法可伸缩</p>
<ul>
<li>避免创建对象：昂贵的操作，垃圾回收影响效率</li>
<li>避免缓存：堆空间有限；用于小数据集</li>
</ul>
<p>理想状态：运行时间和数据量成正比，和资源量成反比<br>为什么达不到：shuffle和sort需要同步机制，同步要求交流，交流影响性能</p>
<p>因此，要尽量避免交流</p>
<ul>
<li>在本地reduce中间数据</li>
<li>combiner帮忙（可选，不一定会用）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qkEQXR"><img src="https://s1.ax1x.com/2022/03/18/qkEQXR.png" srcset="/img/loading.gif" lazyload alt="qkEQXR.png" style="zoom:50%;" /></a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/other/daily-report/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">daily_report</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/other/interview/">
                        <span class="hidden-mobile">interview</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
